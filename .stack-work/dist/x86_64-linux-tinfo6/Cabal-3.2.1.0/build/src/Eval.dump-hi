
==================== FINAL INTERFACE ====================
2021-04-09 05:06:16.0939319 UTC

interface Topos-0.1.0.0-L2hSunVxFDyol1qAzNo2F:Eval 8104
  interface hash: 1944b6eaac711d40d41ea0b755c97fff
  ABI hash: 4e4c9691647e3ff40573745f4fbf148e
  export-list hash: fae837bd0269baac588762786705c785
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 358a18e1043fc7ac1b015a88503b1325
  opt_hash: cb09a535710eb16767a299f2ded44a31
  hpc_hash: 93b885adfe0da089cdf634904fd59f71
  plugin_hash: ad164012d6b1e14942349d58b1132007
  sig of: Nothing
  used TH splices: False
  where
exports:
  Eval._applyFunction
  Eval._applyOp
  Eval._bind
  Eval._eval
  Eval._evalFunctionSignature
  Eval._evalFunctions
  Eval._evalWrd
  Eval._findParenthesis
  Eval._isFunction
  Eval._isOp
  Eval._isReplaceable
  Eval._iterOps
  Eval._mulSubOp
  Eval._numIn
  Eval._subOp
  Eval._traceIf
  Eval._traceShow
  Eval._typeExprGen
  Eval.findParenthesis
  Eval.functionTypeCheck
  Eval.myReadBool
  Eval.myReadDouble
  Eval.myReadInt
  Eval.Parenthesis{Eval.Error Eval.Found Eval.NotFound}
  Eval.TypeOrTypeContents{Eval.TContents Eval.TP}
module dependencies: Ops Parser Types Utils
package dependencies: base-4.14.1.0 ghc-prim-0.6.1
                      integer-gmp-1.0.3.0
orphans: base-4.14.1.0:GHC.Float base-4.14.1.0:GHC.Base
family instance modules: base-4.14.1.0:Control.Applicative
                         base-4.14.1.0:Control.Arrow base-4.14.1.0:Data.Functor.Const
                         base-4.14.1.0:Data.Functor.Identity base-4.14.1.0:Data.Monoid
                         base-4.14.1.0:Data.Semigroup.Internal base-4.14.1.0:GHC.Generics
                         base-4.14.1.0:GHC.IO.Exception
import  -/  Ops 9ccd6b0b2d6b998e873165db1714d518
  exports: 24531ef125d46d1c52ba79243a43b497
  _getType 61ce3e584263fb0db0af18116e87db36
  _opls_dec 4fdae104e3cb477fac4af3f60e9882f1
  _typeFunction ee95a08bf525ca090c305cc8c1f3aeb0
  toList 27a51ba87381b8245ff7c9b364acdd1f
import  -/  Parser 3443f1228a5fa43ab36605baa220d75c
  exports: 4e79c2f1fd013aabc39c8f81cd5374c7
  divList 5b67dd131f974ed42cde15b86592ddf7
  divListBy fb299016722c4bbaadf79441fb5b885a
  divListInto 11665a6afda1cb6f9b8180e31f195576
import  -/  Types 2870f235e2eecb0b3d25891749dd9b60
  exports: fb3343c70ce167cabb463f2e586dc9ec
  BinOp 248347d51f0d70dee7324f48b9d0a2d1
  Bind 7815ac138b80fbf2b2de57eb1e30ff32
  Bind 41e7a32a3a97b64b95a9c2dd25716e8f
  Bool 1241c9fc4fc65d256e8c45a8fcd8d7ba
  Contents fa4819666f5e830574317c5431de464a
  Double e9e581551e257a870b35d7e222321699
  Err 5729e6192c4942b542d650e149e72f10
  EvalMode 033e148ab2ed3368fa8a91bde533879d
  Exp 41e7a32a3a97b64b95a9c2dd25716e8f
  Fun 42a0d5cd29c2177dcdfaca7cd63323dc
  Func 5d1e31720c6814351c1d5fe881a7a5eb
  FuncOp 8397c94a2f2349a2dd9e300a2647eb27
  Function 9a9eb8e4986ec4d109057707af53cf06
  Function 41e7a32a3a97b64b95a9c2dd25716e8f
  Int 006171945d67657ef6faae9f16159d2e
  List f0bad1f4683a6ff5d4c475bfda9c9085
  M_Normal 3a8c8dc348274cb5cc27d78334ca6775
  M_TypeCheck 56a174d0c5bad7ac68dc38880bde511e
  Null 04b71613b842f7a04f5bc3ed46abb1b3
  Operator 6909136eade762426066db644700f71f
  PreList a5b96693bc60e76099302e7495352709
  StrOp 41e7a32a3a97b64b95a9c2dd25716e8f
  T_Any ebca11f0674a4eec23948a43c7ba4df1
  T_Func cd50891eac1225bdba2c21c3e89ab64b
  T_Function af0bd724946c4e4e99d0a5e688bd8bec
  T_Operator 4e8715ebb2c8a3afa27ac366a90ea4dd
  T_Tuple b991f1bb08adca19e3581f5caaa8ae73
  T_TypeCheck b2619f3ff28d8d4e8d01bdee740a65e6
  Tobe 3e1c049fbf40275e2d316fdeb88ae7b7
  Tuple 787aea3d9ecc843af9c34b94030802d6
  Type 2cf69a7355f245a5f0d937b4915d0db8
  Type 41e7a32a3a97b64b95a9c2dd25716e8f
  TypeCheck 743327823be34d4f772a0b2575b49c47
  UnOp 4de264f457e8ae24d30e2ee9293e99a7
  Wrd 41e7a32a3a97b64b95a9c2dd25716e8f
  args 41e7a32a3a97b64b95a9c2dd25716e8f
  args_t 41e7a32a3a97b64b95a9c2dd25716e8f
  identifier 41e7a32a3a97b64b95a9c2dd25716e8f
  ret 41e7a32a3a97b64b95a9c2dd25716e8f
  ret_t 41e7a32a3a97b64b95a9c2dd25716e8f
  return_t 41e7a32a3a97b64b95a9c2dd25716e8f
  typeEq 18f0eaa319b737788e6e4d55a60bd643
  value 41e7a32a3a97b64b95a9c2dd25716e8f
  vtype 41e7a32a3a97b64b95a9c2dd25716e8f
import  -/  Utils d92d30900a25e92c20923717ad185bc6
  exports: 6b58bb7b7116017e16bec3393566cc01
  _macroGen e4d7368d969df7fb3ed6c7b5ee8874ee
  _mulSubst d91fd77e0cc5273b6ec49db560259d74
  _typeCheck 7ceacfd3b7af9dc25ef466d6bf3ed1c6
  toType bd09ffb4537576cfd2569a1d3d7bf812
import  -/  base-4.14.1.0:Data.Either 261c1c71635999cbd73ed5ff84e95050
import  -/  base-4.14.1.0:Data.Foldable 4c6f334a0c8a83bff823b6d582dec41d
import  -/  base-4.14.1.0:Data.Tuple f7decaa9c10bbc586b56da3667e5fd19
import  -/  base-4.14.1.0:Debug.Trace 311b1d0b6fcef7b89debc64460553e8a
import  -/  base-4.14.1.0:GHC.Base ede51775731a544ddfcb02b5a427fd38
import  -/  base-4.14.1.0:GHC.List 7a32e59b6a27bd558cb52809f6fb6df5
import  -/  base-4.14.1.0:GHC.Num 5f3708b0d1d7a8d15017be85d4a06a34
import  -/  base-4.14.1.0:GHC.Show 57e93b26a19b08606d2ae3a6ff8065f2
import  -/  base-4.14.1.0:Prelude 5c84dfddbb8583fc340ecd15bead164a
import  -/  base-4.14.1.0:Text.Read 0911327a13afea52a966558532a1fec4
import  -/  ghc-prim-0.6.1:GHC.Classes e50fb3f1cbf74ce4d3874442e4300a09
import  -/  integer-gmp-1.0.3.0:GHC.Integer.Type 692ea03853035897360fd91a343e151c
92c1eabac9c556a477c11dc7a528d839
  $tc'Error :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   3852992882000343059##
                   11104107412478287843##
                   Eval.$trModule
                   Eval.$tc'Error2
                   0#
                   Eval.$tc'Error1) -}
98dbd0e37e40f91fb137095e87887836
  $tc'Error1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
d5c5e7b1c07dea3c00432c74ab0bac7e
  $tc'Error2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Eval.$tc'Error3) -}
037383ff0c7a4d6ed4829cb079c85124
  $tc'Error3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Error"#) -}
b7544967a75b826f7295766b3ecf4d4f
  $tc'Found :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   17868968753658796897##
                   1924262880586328747##
                   Eval.$trModule
                   Eval.$tc'Found2
                   0#
                   Eval.$tc'Found1) -}
f8f076fc8ce02ef5838f95e2ceef9856
  $tc'Found1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
02559bf96054a23503eaabf4625054db
  $tc'Found2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Eval.$tc'Found3) -}
3dd38b15424dcc1e14b0117534b8cd5e
  $tc'Found3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Found"#) -}
de719506cec3748addff7b050a1f0db0
  $tc'NotFound :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   5335424202051304702##
                   6197829828193728745##
                   Eval.$trModule
                   Eval.$tc'NotFound2
                   0#
                   Eval.$tc'NotFound1) -}
2346e2898d584b514ef116c43f4f2e3e
  $tc'NotFound1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m1, Inline: [~] -}
dee281248d61d4cb3633339e39c00017
  $tc'NotFound2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Eval.$tc'NotFound3) -}
393d5e2476d55cc8bf5ce41f7517bdd5
  $tc'NotFound3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'NotFound"#) -}
c165ec4adc867b6b93ba15bd7a00288e
  $tc'TContents :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   16636122198560988098##
                   12588151818967999666##
                   Eval.$trModule
                   Eval.$tc'TContents2
                   0#
                   Eval.$tc'TContents1) -}
8add87eac07ea317590483030051e899
  $tc'TContents1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
bfaf5f68b904b33e8d56f08f97acf748
  $tc'TContents2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Eval.$tc'TContents3) -}
792469eaeddb6f2c614cb1e94bc6dede
  $tc'TContents3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'TContents"#) -}
961e210d46f72e1c84bd114c67613eb5
  $tc'TP :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   18095669855534512871##
                   12716915826453060038##
                   Eval.$trModule
                   Eval.$tc'TP2
                   0#
                   Eval.$tc'TP1) -}
c34e4ce915ccae08e6d1cec27b209d2a
  $tc'TP1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
d93acb0fce4ffb5fdf174df32b13fc40
  $tc'TP2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Eval.$tc'TP3) -}
b7ed7d80c8be57866197f18774cffaa2
  $tc'TP3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'TP"#) -}
86673e019d84e82c593da8fa09fc9de4
  $tcParenthesis :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   10131005374187343440##
                   3528675147260299273##
                   Eval.$trModule
                   Eval.$tcParenthesis1
                   0#
                   GHC.Types.krep$*) -}
62b4238e634a90f9794f45747fb58186
  $tcParenthesis1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Eval.$tcParenthesis2) -}
47cf606f7bc5458c3000537cafcf07ab
  $tcParenthesis2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Parenthesis"#) -}
86bd66b0b173e82897ea7026b8f887e7
  $tcTypeOrTypeContents :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   11688581601600529428##
                   9037348583055608607##
                   Eval.$trModule
                   Eval.$tcTypeOrTypeContents1
                   0#
                   GHC.Types.krep$*) -}
5c18124c515ba20d463af2425f8176a9
  $tcTypeOrTypeContents1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Eval.$tcTypeOrTypeContents2) -}
d67677ac93d0240f62f557abded2f92e
  $tcTypeOrTypeContents2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("TypeOrTypeContents"#) -}
38709c92d8318c4db5d0f268a19b0289
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module Eval.$trModule3 Eval.$trModule1) -}
769d99eecf1b224bfd16735962578943
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Eval.$trModule2) -}
c4e4d240dffa2b76464792a6fa7c579d
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Eval"#) -}
2f13a54e3e2a9b24b1fab47ac7f53627
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Eval.$trModule4) -}
b41cea65493456c7feb0079bba0caa11
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("Topos-0.1.0.0-L2hSunVxFDyol1qAzNo2F"#) -}
4b5a1d8fd3e9cb06d961dc9ad6a680c8
  $w_applyOp :: Types.Op -> Types.Exp -> Types.Exp -> Types.Exp
  {- Arity: 3, Strictness: <S,1*U><S,1*U><S,1*U>, Inline: [2],
     Unfolding: (\ (ww :: Types.Op)
                   (w :: Types.Exp)
                   (w1 :: Types.Exp) ->
                 case w1 of wild {
                   [] -> Eval._applyOp1
                   : y rest2
                   -> case ww of wild1 {
                        Types.BinOp binop
                        -> case w of wild2 {
                             [] -> case GHC.List.init2 ret_ty Types.Exp of {}
                             : x18 xs
                             -> GHC.Base.++
                                  @ Types.Wrd
                                  (GHC.List.init1 @ Types.Wrd x18 xs)
                                  (GHC.Types.:
                                     @ Types.Wrd
                                     (binop
                                        (Eval._applyOp_go wild2 (GHC.List.lastError @ Types.Wrd))
                                        y)
                                     rest2) }
                        Types.UnOp unop
                        -> GHC.Base.++
                             @ Types.Wrd
                             w
                             (GHC.Types.: @ Types.Wrd (unop y) rest2)
                        Types.FuncOp ds
                        -> case ds of wild2 { (,) nargs fnop ->
                           GHC.Base.++
                             @ Types.Wrd
                             w
                             (GHC.Types.:
                                @ Types.Wrd
                                (fnop
                                   (case nargs of wild3 { GHC.Types.I# y1 ->
                                    case GHC.Prim.<# 0# y1 of lwild {
                                      DEFAULT -> GHC.Types.[] @ Types.Wrd
                                      1# -> GHC.List.$wunsafeTake @ Types.Wrd y1 wild } }))
                                (case nargs of wild3 { GHC.Types.I# x18 ->
                                 case GHC.Prim.<=# x18 0# of lwild {
                                   DEFAULT -> Eval.$wunsafeDrop @ Types.Wrd x18 wild
                                   1# -> wild } })) } } }) -}
c0cc9b0411a1c0023a6bb3f605fe9a7b
  $w_eval ::
    Types.EvalMode
    -> [Types.Bind] -> Types.Exp -> (# Types.Wrd, [Types.Bind] #)
  {- Arity: 3, Strictness: <L,U><L,U><S,U>, Inline: [2] -}
9d9a5bf414180fe72f49ee43d0032260
  $w_evalFunctions ::
    Types.EvalMode
    -> [Types.Bind] -> Types.Exp -> (# Types.Wrd, [Types.Bind] #)
  {- Arity: 3, Strictness: <L,U><S,U><S,U>, Inline: [2] -}
11869cd7de8cedf201a0173a49d8e8fd
  $w_subOp ::
    Types.EvalMode
    -> GHC.Base.String -> Types.Op -> Types.Exp -> Types.Exp
  {- Arity: 4, Strictness: <L,1*U><L,U><L,U><S,U>, Inline: [2] -}
84ebe8a07c7478ad99b8a2e2a749e408
  $wunsafeDrop :: GHC.Prim.Int# -> [a1] -> [a1]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U><S,1*U>,
     Inline: [2] -}
bf4b19671208914762c7345625bea170
  type Parenthesis :: *
  data Parenthesis
    = Found (Types.Exp, Types.Exp, Types.Exp)
    | NotFound
    | Error GHC.Base.String
9e3aba1a7b4bfa0606e7113aee751796
  type TypeOrTypeContents :: *
  data TypeOrTypeContents = TP Types.Type | TContents [Types.Type]
4599a5b5ca8b335e09d521644cc78f98
  _applyFunction ::
    Types.EvalMode
    -> Types.Wrd
    -> Types.Exp
    -> Types.Exp
    -> Data.Either.Either GHC.Base.String Types.Exp
  {- Arity: 4, Strictness: <S,1*U><S,1*U><L,1*U><L,U> -}
ecabdff4dd5babb7a4c7dea2a0c22798
  _applyOp :: Types.StrOp -> Types.Exp -> Types.Exp -> Types.Exp
  {- Arity: 3, Strictness: <S(LS),1*U(A,1*U)><S,1*U><S,1*U>,
     Inline: [2],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: Types.StrOp) (w1 :: Types.Exp) (w2 :: Types.Exp) ->
                 case w of ww { (,) ww1 ww2 -> Eval.$w_applyOp ww2 w1 w2 }) -}
d72e965c3b75b85502b191f480d46c06
  _applyOp1 :: Types.Exp
  {- Strictness: b -}
61568165f3d403c5af357c0650357af3
  _applyOp_go :: [Types.Wrd] -> Types.Wrd -> Types.Wrd
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U> -}
cb4e7b9e6135b08bf008516059382c2d
  _bind ::
    Types.EvalMode
    -> [Types.Bind] -> Types.Exp -> (Types.Wrd, [Types.Bind])
  {- Arity: 3, Strictness: <L,U><L,U><S,1*U>m, Inline: [2],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: Types.EvalMode) (w1 :: [Types.Bind]) (w2 :: Types.Exp) ->
                 case Parser._divList
                        @ Types.Wrd
                        Eval._bind7
                        w2
                        (GHC.Types.[] @ Types.Wrd) of wild {
                   GHC.Maybe.Nothing -> (Eval._bind4, w1)
                   GHC.Maybe.Just ds
                   -> case ds of wild1 { (,,) ds1 ds2 expr ->
                      case ds2 of wild2 {
                        [] -> (Eval._bind1, w1)
                        : ds3 ds4
                        -> case ds3 of wild3 {
                             DEFAULT -> (Eval._bind1, w1)
                             Types.Tobe w3
                             -> case ds4 of wild4 {
                                  []
                                  -> let {
                                       rhs :: Types.Wrd
                                       = case Eval.$w_eval w w1 expr of ww { (#,#) ww1 ww2 -> ww1 }
                                     } in
                                     (rhs,
                                      GHC.Types.:
                                        @ Types.Bind
                                        (Types.Bind w3 rhs (Ops._getType rhs))
                                        w1)
                                  : ipv ipv1 -> (Eval._bind1, w1) } } } } }) -}
3d415d3c2bd7bda8e57bc013dc8cc275
  _bind1 :: Types.Wrd
  {- Strictness: m12, Unfolding: (Types.Err Eval._bind2) -}
9204712a8b40809fd22e0a9d4e1ed2d8
  _bind2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Eval._bind3) -}
ef03c9d1a606a5614e98e736f5bb80d6
  _bind3 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("Syntax error: You should specify only one symbol to bind value."#) -}
b02a0a608170207ca9ec35dc73c87136
  _bind4 :: Types.Wrd
  {- Strictness: m12, Unfolding: (Types.Err Eval._bind5) -}
ee1486b0647076940cca16b6ef8b0a72
  _bind5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Eval._bind6) -}
1cd4434747ed5c1fa9a603e39f96e0c1
  _bind6 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Syntax error: missing `=`"#) -}
3166b1589a2c240c404aec31aad94214
  _bind7 :: Types.Wrd -> GHC.Types.Bool
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Types.Wrd) -> Types.$fEqBind_$c==2 ds Eval._bind_x) -}
f15138fbef1656de638e9cf287137482
  _bind8 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Eval._bind9) -}
cf5d5931b47c40313ece545d0af74838
  _bind9 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("="#) -}
07b6a9be218a3b65ecba7b757d45b15e
  _bind_x :: Types.Wrd
  {- Strictness: m5, Unfolding: (Types.Tobe Eval._bind8) -}
70ea316df9ff9343bf76f95ba0406048
  _eval ::
    Types.EvalMode
    -> [Types.Bind] -> Types.Exp -> (Types.Wrd, [Types.Bind])
  {- Arity: 3, Strictness: <L,U><L,U><S,U>m, Inline: [2],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: Types.EvalMode) (w1 :: [Types.Bind]) (w2 :: Types.Exp) ->
                 case Eval.$w_eval w w1 w2 of ww { (#,#) ww1 ww2 -> (ww1, ww2) }) -}
57bca50d9408bdb70054f641bbf940ae
  _evalFunctionSignature ::
    Types.Exp
    -> Data.Either.Either GHC.Base.String Eval.TypeOrTypeContents
  {- Arity: 1, Strictness: <S,U> -}
eb8bc986211a7500c9417c4c52d33395
  _evalFunctions ::
    Types.EvalMode
    -> [Types.Bind] -> Types.Exp -> (Types.Wrd, [Types.Bind])
  {- Arity: 3, Strictness: <L,U><S,U><S,U>m, Inline: [2],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: Types.EvalMode) (w1 :: [Types.Bind]) (w2 :: Types.Exp) ->
                 case Eval.$w_evalFunctions w w1 w2 of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2) }) -}
45d7a64bb5f94d9b0ed1e540604c1ce7
  _evalWrd :: Types.EvalMode -> Types.Wrd -> Types.Wrd
  {- Arity: 2, Strictness: <L,1*U><S,1*U>,
     Unfolding: (\ (mode :: Types.EvalMode) (ds :: Types.Wrd) ->
                 case ds of wild {
                   DEFAULT -> wild
                   Types.Tobe s
                   -> let {
                        $j :: GHC.Base.String -> Types.Wrd
                          <join 1> {- Arity: 1, Strictness: <L,U> -}
                        = \ (s1 :: GHC.Base.String)[OneShot] ->
                          let {
                            $j1 :: GHC.Base.String -> Types.Wrd
                              <join 1> {- Arity: 1, Strictness: <L,U> -}
                            = \ (s2 :: GHC.Base.String)[OneShot] ->
                              case Text.Read.readEither8
                                     @ GHC.Types.Bool
                                     (Text.ParserCombinators.ReadP.run
                                        @ GHC.Types.Bool
                                        Eval._evalWrd3
                                        s2) of wild1 {
                                [] -> wild
                                : x18 ds1
                                -> case ds1 of wild2 {
                                     []
                                     -> case mode of wild3 {
                                          Types.M_Normal -> Types.Bool x18
                                          Types.M_TypeCheck
                                          -> Types.TypeCheck (Ops._getType (Types.Bool x18)) }
                                     : ipv ipv1 -> wild } }
                          } in
                          case Text.Read.readEither8
                                 @ GHC.Types.Double
                                 (Text.ParserCombinators.ReadP.run
                                    @ GHC.Types.Double
                                    Eval._evalWrd2
                                    s1) of wild1 {
                            [] -> $j1 s1
                            : x18 ds1
                            -> case ds1 of wild2 {
                                 []
                                 -> case mode of wild3 {
                                      Types.M_Normal -> Types.Double x18
                                      Types.M_TypeCheck
                                      -> Types.TypeCheck (Ops._getType (Types.Double x18)) }
                                 : ipv ipv1 -> $j1 s1 } }
                      } in
                      case Text.Read.readEither8
                             @ GHC.Types.Int
                             (Text.ParserCombinators.ReadP.run
                                @ GHC.Types.Int
                                Eval._evalWrd1
                                s) of wild1 {
                        [] -> $j s
                        : x18 ds1
                        -> case ds1 of wild2 {
                             []
                             -> case mode of wild3 {
                                  Types.M_Normal -> Types.Int x18
                                  Types.M_TypeCheck
                                  -> Types.TypeCheck (Ops._getType (Types.Int x18)) }
                             : ipv ipv1 -> $j s } } }) -}
4764377ecaf9222ef4113df37ccaee2d
  _evalWrd1 :: Text.ParserCombinators.ReadP.P GHC.Types.Int
  {- Unfolding: (GHC.Read.$fReadInt_$sreadNumber
                   GHC.Read.$fReadInt2
                   Text.ParserCombinators.ReadPrec.minPrec
                   @ GHC.Types.Int
                   (Text.Read.readEither7 @ GHC.Types.Int)) -}
0d31e95ccaf49d58e3e047617901790e
  _evalWrd2 :: Text.ParserCombinators.ReadP.P GHC.Types.Double
  {- Unfolding: (GHC.Read.$fReadDouble_$sreadNumber
                   GHC.Read.$fReadDouble_$sconvertFrac
                   Text.ParserCombinators.ReadPrec.minPrec
                   @ GHC.Types.Double
                   (Text.Read.readEither7 @ GHC.Types.Double)) -}
d27293affeb602f2f90f3cbaf474d4ec
  _evalWrd3 :: Text.ParserCombinators.ReadP.P GHC.Types.Bool
  {- Unfolding: (GHC.Read.$fRead()7
                   @ GHC.Types.Bool
                   GHC.Read.$fReadBool2
                     `cast`
                   ((<Text.ParserCombinators.ReadPrec.Prec>_R
                     ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                   <GHC.Types.Bool>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                   <GHC.Types.Bool>_R))
                   Text.ParserCombinators.ReadPrec.minPrec
                   @ GHC.Types.Bool
                   (Text.Read.readEither7 @ GHC.Types.Bool)) -}
dc6ffd823540ee769b46cca280b79162
  _findParenthesis ::
    Types.Exp
    -> GHC.Integer.Type.Integer
    -> Types.Wrd
    -> Types.Wrd
    -> Eval.Parenthesis
  {- Arity: 4, Strictness: <S,1*U><L,U><L,U><L,U> -}
15fc5ca94a0d9c894fdf127c339a2c03
  _isFunction :: Types.EvalMode -> Types.Wrd -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: Types.EvalMode) (ds1 :: Types.Wrd) ->
                 case ds of wild {
                   Types.M_Normal
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Types.Func ds2 -> GHC.Types.True }
                   Types.M_TypeCheck
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Types.TypeCheck ds2
                        -> case ds2 of wild2 {
                             DEFAULT -> GHC.Types.False
                             Types.T_Func ds3 -> GHC.Types.True } } }) -}
c02a724a32407bfaa3e91db36902657d
  _isOp :: Types.Wrd -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Types.Wrd) ->
                 case ds of wild {
                   DEFAULT -> GHC.Types.False
                   Types.Func ds1
                   -> case ds1 of wild1 {
                        Types.Fun ipv -> GHC.Types.False
                        Types.Operator ds2 -> GHC.Types.True } }) -}
3b128e2d0340ebda892c317b44f6f18d
  _isReplaceable :: [Types.Bind] -> Types.Exp -> GHC.Types.Bool
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: (\ (binds :: [Types.Bind]) (ex :: Types.Exp) ->
                 letrec {
                   go1 :: [Types.Bind] -> GHC.Integer.Type.Integer -> GHC.Types.Bool
                     <join 2> {- Arity: 2, Strictness: <S,1*U><S,U> -}
                   = \ (ds :: [Types.Bind]) (eta :: GHC.Integer.Type.Integer) ->
                     case ds of wild {
                       []
                       -> case GHC.Integer.Type.ltInteger#
                                 Eval._numIn2
                                 eta of wild1 { DEFAULT ->
                          GHC.Prim.tagToEnum# @ GHC.Types.Bool wild1 }
                       : y ys
                       -> go1
                            ys
                            (GHC.Integer.Type.plusInteger
                               eta
                               (Eval._numIn
                                  (Types.Tobe (case y of wild1 { Types.Bind ds1 ds2 ds3 -> ds1 }))
                                  ex)) }
                 } in
                 go1 binds Eval._numIn2) -}
336c4f3c9fc583ad1959c1f3bc894243
  _iterOps ::
    Types.EvalMode
    -> [Types.StrOp]
    -> Types.Exp
    -> GHC.Maybe.Maybe (Types.StrOp, Types.Exp, Types.Exp)
  {- Arity: 3, Strictness: <L,U><S,1*U><L,U>,
     Unfolding: (\ (mode :: Types.EvalMode)
                   (strops :: [Types.StrOp])
                   (expr :: Types.Exp) ->
                 case GHC.List.dropWhile
                        @ Types.StrOp
                        (\ (sop :: Types.StrOp) ->
                         let {
                           x18 :: Types.Wrd
                           = case mode of wild {
                               Types.M_Normal -> Types.Func (Types.Operator sop)
                               Types.M_TypeCheck
                               -> Types.TypeCheck (Types.T_Func (Types.T_Operator sop)) }
                         } in
                         case Parser._divList
                                @ Types.Wrd
                                (\ (ds :: Types.Wrd) -> Types.$fEqBind_$c==2 ds x18)
                                expr
                                (GHC.Types.[] @ Types.Wrd) of wild {
                           GHC.Maybe.Nothing -> GHC.Types.True
                           GHC.Maybe.Just a1 -> GHC.Types.False })
                        strops of wild {
                   [] -> GHC.Maybe.Nothing @ (Types.StrOp, Types.Exp, Types.Exp)
                   : sop ds
                   -> let {
                        ds1 :: ([Types.Wrd], [Types.Wrd])
                        = let {
                            x18 :: Types.Wrd
                            = case mode of wild1 {
                                Types.M_Normal -> Types.Func (Types.Operator sop)
                                Types.M_TypeCheck
                                -> Types.TypeCheck (Types.T_Func (Types.T_Operator sop)) }
                          } in
                          case Parser._divList
                                 @ Types.Wrd
                                 (\ (ds2 :: Types.Wrd) -> Types.$fEqBind_$c==2 ds2 x18)
                                 expr
                                 (GHC.Types.[] @ Types.Wrd) of wild1 {
                            GHC.Maybe.Nothing -> Eval._iterOps1
                            GHC.Maybe.Just ds2
                            -> case ds2 of wild2 { (,,) ds3 ws1 ws2 -> (ws1, ws2) } }
                      } in
                      case mode of wild1 {
                        Types.M_Normal
                        -> GHC.Maybe.Just
                             @ (Types.StrOp, [Types.Wrd], [Types.Wrd])
                             (sop, case ds1 of ds2 { (,) ws1 ws2 -> ws1 },
                              case ds1 of ds2 { (,) ws1 ws2 -> ws2 })
                        Types.M_TypeCheck
                        -> let {
                             opName :: GHC.Base.String
                             = case sop of wild2 { (,) x18 ds2 -> x18 }
                           } in
                           GHC.Maybe.Just
                             @ ((GHC.Base.String, Types.Op), [Types.Wrd], [Types.Wrd])
                             ((opName, Ops._typeFunction opName),
                              case ds1 of ds2 { (,) ws1 ws2 -> ws1 },
                              case ds1 of ds2 { (,) ws1 ws2 -> ws2 }) } }) -}
2b7145ea0215f82e97a15593a4a8a278
  _iterOps1 :: ([Types.Wrd], [Types.Wrd])
  {- Strictness: b -}
4c5dcecb7551e81fd0a5b3f4196cfd50
  _mulSubOp ::
    Types.EvalMode -> [Types.StrOp] -> Types.Exp -> Types.Exp
  {- Arity: 3, Strictness: <L,U><S,1*U><S,U> -}
f75271e94dba78a637f78d7c31677efb
  _numIn :: Types.Wrd -> Types.Exp -> GHC.Integer.Type.Integer
  {- Arity: 2, Strictness: <L,U><S,1*U>,
     Unfolding: (\ (w :: Types.Wrd) (ex :: Types.Exp) ->
                 letrec {
                   go1 :: [Types.Wrd]
                          -> GHC.Integer.Type.Integer -> GHC.Integer.Type.Integer
                     <join 2> {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
                   = \ (ds :: [Types.Wrd]) (eta :: GHC.Integer.Type.Integer) ->
                     case ds of wild {
                       [] -> eta
                       : y ys
                       -> case Types.$fEqBind_$c==2 y w of wild1 {
                            GHC.Types.False
                            -> go1 ys (GHC.Integer.Type.plusInteger eta Eval._numIn2)
                            GHC.Types.True
                            -> go1 ys (GHC.Integer.Type.plusInteger eta Eval._numIn1) } }
                 } in
                 go1 ex Eval._numIn2) -}
4757a8b2ac9f8eb28588bbc854ccd179
  _numIn1 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (1) -}
629fc779c168c4022c0ee1fa5c91bb53
  _numIn2 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (0) -}
31b7eeeb27aa895543ebc1335d215065
  _subOp :: Types.EvalMode -> Types.StrOp -> Types.Exp -> Types.Exp
  {- Arity: 3, Strictness: <L,1*U><S,1*U(U,U)><S,U>, Inline: [2],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: Types.EvalMode) (w1 :: Types.StrOp) (w2 :: Types.Exp) ->
                 case w1 of ww { (,) ww1 ww2 -> Eval.$w_subOp w ww1 ww2 w2 }) -}
e6bb26d8e51bfb19646d0861304ae496
  _traceIf ::
    GHC.Show.Show a => GHC.Types.Bool -> GHC.Base.String -> a -> a
  {- Arity: 4, Strictness: <L,A><S,1*U><L,1*U><L,U>,
     Unfolding: InlineRule (4, True, True)
                (\ @ a
                   ($dShow :: GHC.Show.Show a)
                   (b :: GHC.Types.Bool)
                   (s :: GHC.Base.String)
                   (x18 :: a) ->
                 case b of wild {
                   GHC.Types.False -> x18
                   GHC.Types.True -> Debug.Trace.trace @ a s x18 }) -}
8480e8bbccd2330c17820115a8fcfa91
  _traceShow :: GHC.Show.Show a => a -> a
  {- Arity: 2, Strictness: <L,1*U(A,1*C1(U),A)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a ($dShow :: GHC.Show.Show a) (x18 :: a) ->
                 Debug.Trace.trace @ a (GHC.Show.show @ a $dShow x18) x18) -}
9c53448375d53dcb4aba8e7d4289f99e
  _typeExprGen :: Types.Function -> Types.Exp
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SLS),1*U(1*U,A,U)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Types.Function) ->
                 case ds of wild { Types.Function ds1 ds2 ds3 ->
                 Utils._mulSubst
                   ds3
                   (GHC.Base.build
                      @ Types.Bind
                      (\ @ b1
                         (c :: Types.Bind -> b1 -> b1)[OneShot]
                         (n :: b1)[OneShot] ->
                       GHC.Base.foldr
                         @ (Types.Type, GHC.Base.String)
                         @ b1
                         (GHC.Base.mapFB
                            @ Types.Bind
                            @ b1
                            @ (Types.Type, GHC.Base.String)
                            c
                            Eval._typeExprGen1)
                         n
                         ds1)) }) -}
37a74cd81c57b80190a8eb7df3902c08
  _typeExprGen1 :: (Types.Type, GHC.Base.String) -> Types.Bind
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U,U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: (Types.Type, GHC.Base.String)) ->
                 case ds of wild { (,) t id ->
                 Types.Bind id (Types.TypeCheck t) Types.T_TypeCheck }) -}
d94dc0f5ab1b567a61a88d46384f47bb
  findParenthesis ::
    Types.Exp -> GHC.Base.String -> GHC.Base.String -> Eval.Parenthesis
  {- Arity: 3, Strictness: <S,1*U><L,U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ (ws :: Types.Exp)
                   (b :: GHC.Base.String)
                   (e :: GHC.Base.String) ->
                 Eval._findParenthesis
                   ws
                   Eval.findParenthesis1
                   (Types.Tobe b)
                   (Types.Tobe e)) -}
f5f1681883e530571395fe93091dfec0
  findParenthesis1 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (-1) -}
0a4cc260c7c040500f63063e91cbc441
  functionTypeCheck :: [Types.Bind] -> Types.Function -> Types.Wrd
  {- Arity: 2, Strictness: <L,U><S(SLS),1*U(1*U,A,U)>,
     Unfolding: InlineRule (2, True, False)
                (\ (binds :: [Types.Bind]) (f :: Types.Function) ->
                 case f of wild { Types.Function ds ds1 ds2 ->
                 case Eval._eval
                        Types.M_TypeCheck
                        binds
                        (Utils._mulSubst
                           ds2
                           (GHC.Base.build
                              @ Types.Bind
                              (\ @ b1
                                 (c :: Types.Bind -> b1 -> b1)[OneShot]
                                 (n :: b1)[OneShot] ->
                               GHC.Base.foldr
                                 @ (Types.Type, GHC.Base.String)
                                 @ b1
                                 (GHC.Base.mapFB
                                    @ Types.Bind
                                    @ b1
                                    @ (Types.Type, GHC.Base.String)
                                    c
                                    Eval._typeExprGen1)
                                 n
                                 ds))) of wild1 { (,) x18 ds3 ->
                 x18 } }) -}
1592147282a93b7867e1f08a13d6e272
  myReadBool ::
    Data.Either.Either GHC.Base.String Types.Wrd
    -> Data.Either.Either GHC.Base.String Types.Wrd
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: Data.Either.Either
                            GHC.Base.String Types.Wrd) ->
                 case ds of wild {
                   Data.Either.Left s
                   -> case Text.Read.readEither8
                             @ GHC.Types.Bool
                             (Text.ParserCombinators.ReadP.run
                                @ GHC.Types.Bool
                                Eval._evalWrd3
                                s) of wild1 {
                        [] -> wild
                        : x18 ds1
                        -> case ds1 of wild2 {
                             []
                             -> Data.Either.Right @ GHC.Base.String @ Types.Wrd (Types.Bool x18)
                             : ipv ipv1 -> wild } }
                   Data.Either.Right w -> wild }) -}
21683cf2d0105488bb5a4cd200ab8f21
  myReadDouble ::
    Data.Either.Either GHC.Base.String Types.Wrd
    -> Data.Either.Either GHC.Base.String Types.Wrd
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: Data.Either.Either
                            GHC.Base.String Types.Wrd) ->
                 case ds of wild {
                   Data.Either.Left s
                   -> case Text.Read.readEither8
                             @ GHC.Types.Double
                             (Text.ParserCombinators.ReadP.run
                                @ GHC.Types.Double
                                Eval._evalWrd2
                                s) of wild1 {
                        [] -> wild
                        : x18 ds1
                        -> case ds1 of wild2 {
                             []
                             -> Data.Either.Right
                                  @ GHC.Base.String
                                  @ Types.Wrd
                                  (Types.Double x18)
                             : ipv ipv1 -> wild } }
                   Data.Either.Right u -> wild }) -}
4e4adaa3a6ae9efe5fe1b6a139cd4da3
  myReadInt ::
    Data.Either.Either GHC.Base.String Types.Wrd
    -> Data.Either.Either GHC.Base.String Types.Wrd
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: Data.Either.Either
                            GHC.Base.String Types.Wrd) ->
                 case ds of wild {
                   Data.Either.Left s
                   -> case Text.Read.readEither8
                             @ GHC.Types.Int
                             (Text.ParserCombinators.ReadP.run
                                @ GHC.Types.Int
                                Eval._evalWrd1
                                s) of wild1 {
                        [] -> wild
                        : x18 ds1
                        -> case ds1 of wild2 {
                             []
                             -> Data.Either.Right @ GHC.Base.String @ Types.Wrd (Types.Int x18)
                             : ipv ipv1 -> wild } }
                   Data.Either.Right u -> wild }) -}
trusted: none
require own pkg trusted: False
module header:
  Nothing
declaration docs:
arg docs:


==================== FINAL INTERFACE ====================
2021-04-09 05:06:16.3764439 UTC

interface Topos-0.1.0.0-L2hSunVxFDyol1qAzNo2F:Eval 8104
  interface hash: 1944b6eaac711d40d41ea0b755c97fff
  ABI hash: 4e4c9691647e3ff40573745f4fbf148e
  export-list hash: fae837bd0269baac588762786705c785
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 358a18e1043fc7ac1b015a88503b1325
  opt_hash: cb09a535710eb16767a299f2ded44a31
  hpc_hash: 93b885adfe0da089cdf634904fd59f71
  plugin_hash: ad164012d6b1e14942349d58b1132007
  sig of: Nothing
  used TH splices: False
  where
exports:
  Eval._applyFunction
  Eval._applyOp
  Eval._bind
  Eval._eval
  Eval._evalFunctionSignature
  Eval._evalFunctions
  Eval._evalWrd
  Eval._findParenthesis
  Eval._isFunction
  Eval._isOp
  Eval._isReplaceable
  Eval._iterOps
  Eval._mulSubOp
  Eval._numIn
  Eval._subOp
  Eval._traceIf
  Eval._traceShow
  Eval._typeExprGen
  Eval.findParenthesis
  Eval.functionTypeCheck
  Eval.myReadBool
  Eval.myReadDouble
  Eval.myReadInt
  Eval.Parenthesis{Eval.Error Eval.Found Eval.NotFound}
  Eval.TypeOrTypeContents{Eval.TContents Eval.TP}
module dependencies: Ops Parser Types Utils
package dependencies: base-4.14.1.0 ghc-prim-0.6.1
                      integer-gmp-1.0.3.0
orphans: base-4.14.1.0:GHC.Float base-4.14.1.0:GHC.Base
family instance modules: base-4.14.1.0:Control.Applicative
                         base-4.14.1.0:Control.Arrow base-4.14.1.0:Data.Functor.Const
                         base-4.14.1.0:Data.Functor.Identity base-4.14.1.0:Data.Monoid
                         base-4.14.1.0:Data.Semigroup.Internal base-4.14.1.0:GHC.Generics
                         base-4.14.1.0:GHC.IO.Exception
import  -/  Ops 9ccd6b0b2d6b998e873165db1714d518
  exports: 24531ef125d46d1c52ba79243a43b497
  _getType 61ce3e584263fb0db0af18116e87db36
  _opls_dec 4fdae104e3cb477fac4af3f60e9882f1
  _typeFunction ee95a08bf525ca090c305cc8c1f3aeb0
  toList 27a51ba87381b8245ff7c9b364acdd1f
import  -/  Parser 3443f1228a5fa43ab36605baa220d75c
  exports: 4e79c2f1fd013aabc39c8f81cd5374c7
  divList 5b67dd131f974ed42cde15b86592ddf7
  divListBy fb299016722c4bbaadf79441fb5b885a
  divListInto 11665a6afda1cb6f9b8180e31f195576
import  -/  Types 2870f235e2eecb0b3d25891749dd9b60
  exports: fb3343c70ce167cabb463f2e586dc9ec
  BinOp 248347d51f0d70dee7324f48b9d0a2d1
  Bind 7815ac138b80fbf2b2de57eb1e30ff32
  Bind 41e7a32a3a97b64b95a9c2dd25716e8f
  Bool 1241c9fc4fc65d256e8c45a8fcd8d7ba
  Contents fa4819666f5e830574317c5431de464a
  Double e9e581551e257a870b35d7e222321699
  Err 5729e6192c4942b542d650e149e72f10
  EvalMode 033e148ab2ed3368fa8a91bde533879d
  Exp 41e7a32a3a97b64b95a9c2dd25716e8f
  Fun 42a0d5cd29c2177dcdfaca7cd63323dc
  Func 5d1e31720c6814351c1d5fe881a7a5eb
  FuncOp 8397c94a2f2349a2dd9e300a2647eb27
  Function 9a9eb8e4986ec4d109057707af53cf06
  Function 41e7a32a3a97b64b95a9c2dd25716e8f
  Int 006171945d67657ef6faae9f16159d2e
  List f0bad1f4683a6ff5d4c475bfda9c9085
  M_Normal 3a8c8dc348274cb5cc27d78334ca6775
  M_TypeCheck 56a174d0c5bad7ac68dc38880bde511e
  Null 04b71613b842f7a04f5bc3ed46abb1b3
  Operator 6909136eade762426066db644700f71f
  PreList a5b96693bc60e76099302e7495352709
  StrOp 41e7a32a3a97b64b95a9c2dd25716e8f
  T_Any ebca11f0674a4eec23948a43c7ba4df1
  T_Func cd50891eac1225bdba2c21c3e89ab64b
  T_Function af0bd724946c4e4e99d0a5e688bd8bec
  T_Operator 4e8715ebb2c8a3afa27ac366a90ea4dd
  T_Tuple b991f1bb08adca19e3581f5caaa8ae73
  T_TypeCheck b2619f3ff28d8d4e8d01bdee740a65e6
  Tobe 3e1c049fbf40275e2d316fdeb88ae7b7
  Tuple 787aea3d9ecc843af9c34b94030802d6
  Type 2cf69a7355f245a5f0d937b4915d0db8
  Type 41e7a32a3a97b64b95a9c2dd25716e8f
  TypeCheck 743327823be34d4f772a0b2575b49c47
  UnOp 4de264f457e8ae24d30e2ee9293e99a7
  Wrd 41e7a32a3a97b64b95a9c2dd25716e8f
  args 41e7a32a3a97b64b95a9c2dd25716e8f
  args_t 41e7a32a3a97b64b95a9c2dd25716e8f
  identifier 41e7a32a3a97b64b95a9c2dd25716e8f
  ret 41e7a32a3a97b64b95a9c2dd25716e8f
  ret_t 41e7a32a3a97b64b95a9c2dd25716e8f
  return_t 41e7a32a3a97b64b95a9c2dd25716e8f
  typeEq 18f0eaa319b737788e6e4d55a60bd643
  value 41e7a32a3a97b64b95a9c2dd25716e8f
  vtype 41e7a32a3a97b64b95a9c2dd25716e8f
import  -/  Utils d92d30900a25e92c20923717ad185bc6
  exports: 6b58bb7b7116017e16bec3393566cc01
  _macroGen e4d7368d969df7fb3ed6c7b5ee8874ee
  _mulSubst d91fd77e0cc5273b6ec49db560259d74
  _typeCheck 7ceacfd3b7af9dc25ef466d6bf3ed1c6
  toType bd09ffb4537576cfd2569a1d3d7bf812
import  -/  base-4.14.1.0:Data.Either 261c1c71635999cbd73ed5ff84e95050
import  -/  base-4.14.1.0:Data.Foldable 4c6f334a0c8a83bff823b6d582dec41d
import  -/  base-4.14.1.0:Data.Tuple f7decaa9c10bbc586b56da3667e5fd19
import  -/  base-4.14.1.0:Debug.Trace 311b1d0b6fcef7b89debc64460553e8a
import  -/  base-4.14.1.0:GHC.Base ede51775731a544ddfcb02b5a427fd38
import  -/  base-4.14.1.0:GHC.List 7a32e59b6a27bd558cb52809f6fb6df5
import  -/  base-4.14.1.0:GHC.Num 5f3708b0d1d7a8d15017be85d4a06a34
import  -/  base-4.14.1.0:GHC.Show 57e93b26a19b08606d2ae3a6ff8065f2
import  -/  base-4.14.1.0:Prelude 5c84dfddbb8583fc340ecd15bead164a
import  -/  base-4.14.1.0:Text.Read 0911327a13afea52a966558532a1fec4
import  -/  ghc-prim-0.6.1:GHC.Classes e50fb3f1cbf74ce4d3874442e4300a09
import  -/  integer-gmp-1.0.3.0:GHC.Integer.Type 692ea03853035897360fd91a343e151c
92c1eabac9c556a477c11dc7a528d839
  $tc'Error :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   3852992882000343059##
                   11104107412478287843##
                   Eval.$trModule
                   Eval.$tc'Error2
                   0#
                   Eval.$tc'Error1) -}
98dbd0e37e40f91fb137095e87887836
  $tc'Error1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
d5c5e7b1c07dea3c00432c74ab0bac7e
  $tc'Error2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Eval.$tc'Error3) -}
037383ff0c7a4d6ed4829cb079c85124
  $tc'Error3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Error"#) -}
b7544967a75b826f7295766b3ecf4d4f
  $tc'Found :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   17868968753658796897##
                   1924262880586328747##
                   Eval.$trModule
                   Eval.$tc'Found2
                   0#
                   Eval.$tc'Found1) -}
f8f076fc8ce02ef5838f95e2ceef9856
  $tc'Found1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
02559bf96054a23503eaabf4625054db
  $tc'Found2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Eval.$tc'Found3) -}
3dd38b15424dcc1e14b0117534b8cd5e
  $tc'Found3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Found"#) -}
de719506cec3748addff7b050a1f0db0
  $tc'NotFound :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   5335424202051304702##
                   6197829828193728745##
                   Eval.$trModule
                   Eval.$tc'NotFound2
                   0#
                   Eval.$tc'NotFound1) -}
2346e2898d584b514ef116c43f4f2e3e
  $tc'NotFound1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m1, Inline: [~] -}
dee281248d61d4cb3633339e39c00017
  $tc'NotFound2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Eval.$tc'NotFound3) -}
393d5e2476d55cc8bf5ce41f7517bdd5
  $tc'NotFound3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'NotFound"#) -}
c165ec4adc867b6b93ba15bd7a00288e
  $tc'TContents :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   16636122198560988098##
                   12588151818967999666##
                   Eval.$trModule
                   Eval.$tc'TContents2
                   0#
                   Eval.$tc'TContents1) -}
8add87eac07ea317590483030051e899
  $tc'TContents1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
bfaf5f68b904b33e8d56f08f97acf748
  $tc'TContents2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Eval.$tc'TContents3) -}
792469eaeddb6f2c614cb1e94bc6dede
  $tc'TContents3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'TContents"#) -}
961e210d46f72e1c84bd114c67613eb5
  $tc'TP :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   18095669855534512871##
                   12716915826453060038##
                   Eval.$trModule
                   Eval.$tc'TP2
                   0#
                   Eval.$tc'TP1) -}
c34e4ce915ccae08e6d1cec27b209d2a
  $tc'TP1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
d93acb0fce4ffb5fdf174df32b13fc40
  $tc'TP2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Eval.$tc'TP3) -}
b7ed7d80c8be57866197f18774cffaa2
  $tc'TP3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'TP"#) -}
86673e019d84e82c593da8fa09fc9de4
  $tcParenthesis :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   10131005374187343440##
                   3528675147260299273##
                   Eval.$trModule
                   Eval.$tcParenthesis1
                   0#
                   GHC.Types.krep$*) -}
62b4238e634a90f9794f45747fb58186
  $tcParenthesis1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Eval.$tcParenthesis2) -}
47cf606f7bc5458c3000537cafcf07ab
  $tcParenthesis2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Parenthesis"#) -}
86bd66b0b173e82897ea7026b8f887e7
  $tcTypeOrTypeContents :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   11688581601600529428##
                   9037348583055608607##
                   Eval.$trModule
                   Eval.$tcTypeOrTypeContents1
                   0#
                   GHC.Types.krep$*) -}
5c18124c515ba20d463af2425f8176a9
  $tcTypeOrTypeContents1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Eval.$tcTypeOrTypeContents2) -}
d67677ac93d0240f62f557abded2f92e
  $tcTypeOrTypeContents2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("TypeOrTypeContents"#) -}
38709c92d8318c4db5d0f268a19b0289
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module Eval.$trModule3 Eval.$trModule1) -}
769d99eecf1b224bfd16735962578943
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Eval.$trModule2) -}
c4e4d240dffa2b76464792a6fa7c579d
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Eval"#) -}
2f13a54e3e2a9b24b1fab47ac7f53627
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Eval.$trModule4) -}
b41cea65493456c7feb0079bba0caa11
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("Topos-0.1.0.0-L2hSunVxFDyol1qAzNo2F"#) -}
4b5a1d8fd3e9cb06d961dc9ad6a680c8
  $w_applyOp :: Types.Op -> Types.Exp -> Types.Exp -> Types.Exp
  {- Arity: 3, Strictness: <S,1*U><S,1*U><S,1*U>, Inline: [2],
     Unfolding: (\ (ww :: Types.Op)
                   (w :: Types.Exp)
                   (w1 :: Types.Exp) ->
                 case w1 of wild {
                   [] -> Eval._applyOp1
                   : y rest2
                   -> case ww of wild1 {
                        Types.BinOp binop
                        -> case w of wild2 {
                             [] -> case GHC.List.init2 ret_ty Types.Exp of {}
                             : x18 xs
                             -> GHC.Base.++
                                  @ Types.Wrd
                                  (GHC.List.init1 @ Types.Wrd x18 xs)
                                  (GHC.Types.:
                                     @ Types.Wrd
                                     (binop
                                        (Eval._applyOp_go wild2 (GHC.List.lastError @ Types.Wrd))
                                        y)
                                     rest2) }
                        Types.UnOp unop
                        -> GHC.Base.++
                             @ Types.Wrd
                             w
                             (GHC.Types.: @ Types.Wrd (unop y) rest2)
                        Types.FuncOp ds
                        -> case ds of wild2 { (,) nargs fnop ->
                           GHC.Base.++
                             @ Types.Wrd
                             w
                             (GHC.Types.:
                                @ Types.Wrd
                                (fnop
                                   (case nargs of wild3 { GHC.Types.I# y1 ->
                                    case GHC.Prim.<# 0# y1 of lwild {
                                      DEFAULT -> GHC.Types.[] @ Types.Wrd
                                      1# -> GHC.List.$wunsafeTake @ Types.Wrd y1 wild } }))
                                (case nargs of wild3 { GHC.Types.I# x18 ->
                                 case GHC.Prim.<=# x18 0# of lwild {
                                   DEFAULT -> Eval.$wunsafeDrop @ Types.Wrd x18 wild
                                   1# -> wild } })) } } }) -}
c0cc9b0411a1c0023a6bb3f605fe9a7b
  $w_eval ::
    Types.EvalMode
    -> [Types.Bind] -> Types.Exp -> (# Types.Wrd, [Types.Bind] #)
  {- Arity: 3, Strictness: <L,U><L,U><S,U>, Inline: [2] -}
9d9a5bf414180fe72f49ee43d0032260
  $w_evalFunctions ::
    Types.EvalMode
    -> [Types.Bind] -> Types.Exp -> (# Types.Wrd, [Types.Bind] #)
  {- Arity: 3, Strictness: <L,U><S,U><S,U>, Inline: [2] -}
11869cd7de8cedf201a0173a49d8e8fd
  $w_subOp ::
    Types.EvalMode
    -> GHC.Base.String -> Types.Op -> Types.Exp -> Types.Exp
  {- Arity: 4, Strictness: <L,1*U><L,U><L,U><S,U>, Inline: [2] -}
84ebe8a07c7478ad99b8a2e2a749e408
  $wunsafeDrop :: GHC.Prim.Int# -> [a1] -> [a1]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U><S,1*U>,
     Inline: [2] -}
bf4b19671208914762c7345625bea170
  type Parenthesis :: *
  data Parenthesis
    = Found (Types.Exp, Types.Exp, Types.Exp)
    | NotFound
    | Error GHC.Base.String
9e3aba1a7b4bfa0606e7113aee751796
  type TypeOrTypeContents :: *
  data TypeOrTypeContents = TP Types.Type | TContents [Types.Type]
4599a5b5ca8b335e09d521644cc78f98
  _applyFunction ::
    Types.EvalMode
    -> Types.Wrd
    -> Types.Exp
    -> Types.Exp
    -> Data.Either.Either GHC.Base.String Types.Exp
  {- Arity: 4, Strictness: <S,1*U><S,1*U><L,1*U><L,U> -}
ecabdff4dd5babb7a4c7dea2a0c22798
  _applyOp :: Types.StrOp -> Types.Exp -> Types.Exp -> Types.Exp
  {- Arity: 3, Strictness: <S(LS),1*U(A,1*U)><S,1*U><S,1*U>,
     Inline: [2],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: Types.StrOp) (w1 :: Types.Exp) (w2 :: Types.Exp) ->
                 case w of ww { (,) ww1 ww2 -> Eval.$w_applyOp ww2 w1 w2 }) -}
d72e965c3b75b85502b191f480d46c06
  _applyOp1 :: Types.Exp
  {- Strictness: b -}
61568165f3d403c5af357c0650357af3
  _applyOp_go :: [Types.Wrd] -> Types.Wrd -> Types.Wrd
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U> -}
cb4e7b9e6135b08bf008516059382c2d
  _bind ::
    Types.EvalMode
    -> [Types.Bind] -> Types.Exp -> (Types.Wrd, [Types.Bind])
  {- Arity: 3, Strictness: <L,U><L,U><S,1*U>m, Inline: [2],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: Types.EvalMode) (w1 :: [Types.Bind]) (w2 :: Types.Exp) ->
                 case Parser._divList
                        @ Types.Wrd
                        Eval._bind7
                        w2
                        (GHC.Types.[] @ Types.Wrd) of wild {
                   GHC.Maybe.Nothing -> (Eval._bind4, w1)
                   GHC.Maybe.Just ds
                   -> case ds of wild1 { (,,) ds1 ds2 expr ->
                      case ds2 of wild2 {
                        [] -> (Eval._bind1, w1)
                        : ds3 ds4
                        -> case ds3 of wild3 {
                             DEFAULT -> (Eval._bind1, w1)
                             Types.Tobe w3
                             -> case ds4 of wild4 {
                                  []
                                  -> let {
                                       rhs :: Types.Wrd
                                       = case Eval.$w_eval w w1 expr of ww { (#,#) ww1 ww2 -> ww1 }
                                     } in
                                     (rhs,
                                      GHC.Types.:
                                        @ Types.Bind
                                        (Types.Bind w3 rhs (Ops._getType rhs))
                                        w1)
                                  : ipv ipv1 -> (Eval._bind1, w1) } } } } }) -}
3d415d3c2bd7bda8e57bc013dc8cc275
  _bind1 :: Types.Wrd
  {- Strictness: m12, Unfolding: (Types.Err Eval._bind2) -}
9204712a8b40809fd22e0a9d4e1ed2d8
  _bind2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Eval._bind3) -}
ef03c9d1a606a5614e98e736f5bb80d6
  _bind3 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("Syntax error: You should specify only one symbol to bind value."#) -}
b02a0a608170207ca9ec35dc73c87136
  _bind4 :: Types.Wrd
  {- Strictness: m12, Unfolding: (Types.Err Eval._bind5) -}
ee1486b0647076940cca16b6ef8b0a72
  _bind5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Eval._bind6) -}
1cd4434747ed5c1fa9a603e39f96e0c1
  _bind6 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Syntax error: missing `=`"#) -}
3166b1589a2c240c404aec31aad94214
  _bind7 :: Types.Wrd -> GHC.Types.Bool
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Types.Wrd) -> Types.$fEqBind_$c==2 ds Eval._bind_x) -}
f15138fbef1656de638e9cf287137482
  _bind8 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Eval._bind9) -}
cf5d5931b47c40313ece545d0af74838
  _bind9 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("="#) -}
07b6a9be218a3b65ecba7b757d45b15e
  _bind_x :: Types.Wrd
  {- Strictness: m5, Unfolding: (Types.Tobe Eval._bind8) -}
70ea316df9ff9343bf76f95ba0406048
  _eval ::
    Types.EvalMode
    -> [Types.Bind] -> Types.Exp -> (Types.Wrd, [Types.Bind])
  {- Arity: 3, Strictness: <L,U><L,U><S,U>m, Inline: [2],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: Types.EvalMode) (w1 :: [Types.Bind]) (w2 :: Types.Exp) ->
                 case Eval.$w_eval w w1 w2 of ww { (#,#) ww1 ww2 -> (ww1, ww2) }) -}
57bca50d9408bdb70054f641bbf940ae
  _evalFunctionSignature ::
    Types.Exp
    -> Data.Either.Either GHC.Base.String Eval.TypeOrTypeContents
  {- Arity: 1, Strictness: <S,U> -}
eb8bc986211a7500c9417c4c52d33395
  _evalFunctions ::
    Types.EvalMode
    -> [Types.Bind] -> Types.Exp -> (Types.Wrd, [Types.Bind])
  {- Arity: 3, Strictness: <L,U><S,U><S,U>m, Inline: [2],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: Types.EvalMode) (w1 :: [Types.Bind]) (w2 :: Types.Exp) ->
                 case Eval.$w_evalFunctions w w1 w2 of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2) }) -}
45d7a64bb5f94d9b0ed1e540604c1ce7
  _evalWrd :: Types.EvalMode -> Types.Wrd -> Types.Wrd
  {- Arity: 2, Strictness: <L,1*U><S,1*U>,
     Unfolding: (\ (mode :: Types.EvalMode) (ds :: Types.Wrd) ->
                 case ds of wild {
                   DEFAULT -> wild
                   Types.Tobe s
                   -> let {
                        $j :: GHC.Base.String -> Types.Wrd
                          <join 1> {- Arity: 1, Strictness: <L,U> -}
                        = \ (s1 :: GHC.Base.String)[OneShot] ->
                          let {
                            $j1 :: GHC.Base.String -> Types.Wrd
                              <join 1> {- Arity: 1, Strictness: <L,U> -}
                            = \ (s2 :: GHC.Base.String)[OneShot] ->
                              case Text.Read.readEither8
                                     @ GHC.Types.Bool
                                     (Text.ParserCombinators.ReadP.run
                                        @ GHC.Types.Bool
                                        Eval._evalWrd3
                                        s2) of wild1 {
                                [] -> wild
                                : x18 ds1
                                -> case ds1 of wild2 {
                                     []
                                     -> case mode of wild3 {
                                          Types.M_Normal -> Types.Bool x18
                                          Types.M_TypeCheck
                                          -> Types.TypeCheck (Ops._getType (Types.Bool x18)) }
                                     : ipv ipv1 -> wild } }
                          } in
                          case Text.Read.readEither8
                                 @ GHC.Types.Double
                                 (Text.ParserCombinators.ReadP.run
                                    @ GHC.Types.Double
                                    Eval._evalWrd2
                                    s1) of wild1 {
                            [] -> $j1 s1
                            : x18 ds1
                            -> case ds1 of wild2 {
                                 []
                                 -> case mode of wild3 {
                                      Types.M_Normal -> Types.Double x18
                                      Types.M_TypeCheck
                                      -> Types.TypeCheck (Ops._getType (Types.Double x18)) }
                                 : ipv ipv1 -> $j1 s1 } }
                      } in
                      case Text.Read.readEither8
                             @ GHC.Types.Int
                             (Text.ParserCombinators.ReadP.run
                                @ GHC.Types.Int
                                Eval._evalWrd1
                                s) of wild1 {
                        [] -> $j s
                        : x18 ds1
                        -> case ds1 of wild2 {
                             []
                             -> case mode of wild3 {
                                  Types.M_Normal -> Types.Int x18
                                  Types.M_TypeCheck
                                  -> Types.TypeCheck (Ops._getType (Types.Int x18)) }
                             : ipv ipv1 -> $j s } } }) -}
4764377ecaf9222ef4113df37ccaee2d
  _evalWrd1 :: Text.ParserCombinators.ReadP.P GHC.Types.Int
  {- Unfolding: (GHC.Read.$fReadInt_$sreadNumber
                   GHC.Read.$fReadInt2
                   Text.ParserCombinators.ReadPrec.minPrec
                   @ GHC.Types.Int
                   (Text.Read.readEither7 @ GHC.Types.Int)) -}
0d31e95ccaf49d58e3e047617901790e
  _evalWrd2 :: Text.ParserCombinators.ReadP.P GHC.Types.Double
  {- Unfolding: (GHC.Read.$fReadDouble_$sreadNumber
                   GHC.Read.$fReadDouble_$sconvertFrac
                   Text.ParserCombinators.ReadPrec.minPrec
                   @ GHC.Types.Double
                   (Text.Read.readEither7 @ GHC.Types.Double)) -}
d27293affeb602f2f90f3cbaf474d4ec
  _evalWrd3 :: Text.ParserCombinators.ReadP.P GHC.Types.Bool
  {- Unfolding: (GHC.Read.$fRead()7
                   @ GHC.Types.Bool
                   GHC.Read.$fReadBool2
                     `cast`
                   ((<Text.ParserCombinators.ReadPrec.Prec>_R
                     ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                   <GHC.Types.Bool>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                   <GHC.Types.Bool>_R))
                   Text.ParserCombinators.ReadPrec.minPrec
                   @ GHC.Types.Bool
                   (Text.Read.readEither7 @ GHC.Types.Bool)) -}
dc6ffd823540ee769b46cca280b79162
  _findParenthesis ::
    Types.Exp
    -> GHC.Integer.Type.Integer
    -> Types.Wrd
    -> Types.Wrd
    -> Eval.Parenthesis
  {- Arity: 4, Strictness: <S,1*U><L,U><L,U><L,U> -}
15fc5ca94a0d9c894fdf127c339a2c03
  _isFunction :: Types.EvalMode -> Types.Wrd -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: Types.EvalMode) (ds1 :: Types.Wrd) ->
                 case ds of wild {
                   Types.M_Normal
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Types.Func ds2 -> GHC.Types.True }
                   Types.M_TypeCheck
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Types.TypeCheck ds2
                        -> case ds2 of wild2 {
                             DEFAULT -> GHC.Types.False
                             Types.T_Func ds3 -> GHC.Types.True } } }) -}
c02a724a32407bfaa3e91db36902657d
  _isOp :: Types.Wrd -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Types.Wrd) ->
                 case ds of wild {
                   DEFAULT -> GHC.Types.False
                   Types.Func ds1
                   -> case ds1 of wild1 {
                        Types.Fun ipv -> GHC.Types.False
                        Types.Operator ds2 -> GHC.Types.True } }) -}
3b128e2d0340ebda892c317b44f6f18d
  _isReplaceable :: [Types.Bind] -> Types.Exp -> GHC.Types.Bool
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: (\ (binds :: [Types.Bind]) (ex :: Types.Exp) ->
                 letrec {
                   go1 :: [Types.Bind] -> GHC.Integer.Type.Integer -> GHC.Types.Bool
                     <join 2> {- Arity: 2, Strictness: <S,1*U><S,U> -}
                   = \ (ds :: [Types.Bind]) (eta :: GHC.Integer.Type.Integer) ->
                     case ds of wild {
                       []
                       -> case GHC.Integer.Type.ltInteger#
                                 Eval._numIn2
                                 eta of wild1 { DEFAULT ->
                          GHC.Prim.tagToEnum# @ GHC.Types.Bool wild1 }
                       : y ys
                       -> go1
                            ys
                            (GHC.Integer.Type.plusInteger
                               eta
                               (Eval._numIn
                                  (Types.Tobe (case y of wild1 { Types.Bind ds1 ds2 ds3 -> ds1 }))
                                  ex)) }
                 } in
                 go1 binds Eval._numIn2) -}
336c4f3c9fc583ad1959c1f3bc894243
  _iterOps ::
    Types.EvalMode
    -> [Types.StrOp]
    -> Types.Exp
    -> GHC.Maybe.Maybe (Types.StrOp, Types.Exp, Types.Exp)
  {- Arity: 3, Strictness: <L,U><S,1*U><L,U>,
     Unfolding: (\ (mode :: Types.EvalMode)
                   (strops :: [Types.StrOp])
                   (expr :: Types.Exp) ->
                 case GHC.List.dropWhile
                        @ Types.StrOp
                        (\ (sop :: Types.StrOp) ->
                         let {
                           x18 :: Types.Wrd
                           = case mode of wild {
                               Types.M_Normal -> Types.Func (Types.Operator sop)
                               Types.M_TypeCheck
                               -> Types.TypeCheck (Types.T_Func (Types.T_Operator sop)) }
                         } in
                         case Parser._divList
                                @ Types.Wrd
                                (\ (ds :: Types.Wrd) -> Types.$fEqBind_$c==2 ds x18)
                                expr
                                (GHC.Types.[] @ Types.Wrd) of wild {
                           GHC.Maybe.Nothing -> GHC.Types.True
                           GHC.Maybe.Just a1 -> GHC.Types.False })
                        strops of wild {
                   [] -> GHC.Maybe.Nothing @ (Types.StrOp, Types.Exp, Types.Exp)
                   : sop ds
                   -> let {
                        ds1 :: ([Types.Wrd], [Types.Wrd])
                        = let {
                            x18 :: Types.Wrd
                            = case mode of wild1 {
                                Types.M_Normal -> Types.Func (Types.Operator sop)
                                Types.M_TypeCheck
                                -> Types.TypeCheck (Types.T_Func (Types.T_Operator sop)) }
                          } in
                          case Parser._divList
                                 @ Types.Wrd
                                 (\ (ds2 :: Types.Wrd) -> Types.$fEqBind_$c==2 ds2 x18)
                                 expr
                                 (GHC.Types.[] @ Types.Wrd) of wild1 {
                            GHC.Maybe.Nothing -> Eval._iterOps1
                            GHC.Maybe.Just ds2
                            -> case ds2 of wild2 { (,,) ds3 ws1 ws2 -> (ws1, ws2) } }
                      } in
                      case mode of wild1 {
                        Types.M_Normal
                        -> GHC.Maybe.Just
                             @ (Types.StrOp, [Types.Wrd], [Types.Wrd])
                             (sop, case ds1 of ds2 { (,) ws1 ws2 -> ws1 },
                              case ds1 of ds2 { (,) ws1 ws2 -> ws2 })
                        Types.M_TypeCheck
                        -> let {
                             opName :: GHC.Base.String
                             = case sop of wild2 { (,) x18 ds2 -> x18 }
                           } in
                           GHC.Maybe.Just
                             @ ((GHC.Base.String, Types.Op), [Types.Wrd], [Types.Wrd])
                             ((opName, Ops._typeFunction opName),
                              case ds1 of ds2 { (,) ws1 ws2 -> ws1 },
                              case ds1 of ds2 { (,) ws1 ws2 -> ws2 }) } }) -}
2b7145ea0215f82e97a15593a4a8a278
  _iterOps1 :: ([Types.Wrd], [Types.Wrd])
  {- Strictness: b -}
4c5dcecb7551e81fd0a5b3f4196cfd50
  _mulSubOp ::
    Types.EvalMode -> [Types.StrOp] -> Types.Exp -> Types.Exp
  {- Arity: 3, Strictness: <L,U><S,1*U><S,U> -}
f75271e94dba78a637f78d7c31677efb
  _numIn :: Types.Wrd -> Types.Exp -> GHC.Integer.Type.Integer
  {- Arity: 2, Strictness: <L,U><S,1*U>,
     Unfolding: (\ (w :: Types.Wrd) (ex :: Types.Exp) ->
                 letrec {
                   go1 :: [Types.Wrd]
                          -> GHC.Integer.Type.Integer -> GHC.Integer.Type.Integer
                     <join 2> {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
                   = \ (ds :: [Types.Wrd]) (eta :: GHC.Integer.Type.Integer) ->
                     case ds of wild {
                       [] -> eta
                       : y ys
                       -> case Types.$fEqBind_$c==2 y w of wild1 {
                            GHC.Types.False
                            -> go1 ys (GHC.Integer.Type.plusInteger eta Eval._numIn2)
                            GHC.Types.True
                            -> go1 ys (GHC.Integer.Type.plusInteger eta Eval._numIn1) } }
                 } in
                 go1 ex Eval._numIn2) -}
4757a8b2ac9f8eb28588bbc854ccd179
  _numIn1 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (1) -}
629fc779c168c4022c0ee1fa5c91bb53
  _numIn2 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (0) -}
31b7eeeb27aa895543ebc1335d215065
  _subOp :: Types.EvalMode -> Types.StrOp -> Types.Exp -> Types.Exp
  {- Arity: 3, Strictness: <L,1*U><S,1*U(U,U)><S,U>, Inline: [2],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: Types.EvalMode) (w1 :: Types.StrOp) (w2 :: Types.Exp) ->
                 case w1 of ww { (,) ww1 ww2 -> Eval.$w_subOp w ww1 ww2 w2 }) -}
e6bb26d8e51bfb19646d0861304ae496
  _traceIf ::
    GHC.Show.Show a => GHC.Types.Bool -> GHC.Base.String -> a -> a
  {- Arity: 4, Strictness: <L,A><S,1*U><L,1*U><L,U>,
     Unfolding: InlineRule (4, True, True)
                (\ @ a
                   ($dShow :: GHC.Show.Show a)
                   (b :: GHC.Types.Bool)
                   (s :: GHC.Base.String)
                   (x18 :: a) ->
                 case b of wild {
                   GHC.Types.False -> x18
                   GHC.Types.True -> Debug.Trace.trace @ a s x18 }) -}
8480e8bbccd2330c17820115a8fcfa91
  _traceShow :: GHC.Show.Show a => a -> a
  {- Arity: 2, Strictness: <L,1*U(A,1*C1(U),A)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a ($dShow :: GHC.Show.Show a) (x18 :: a) ->
                 Debug.Trace.trace @ a (GHC.Show.show @ a $dShow x18) x18) -}
9c53448375d53dcb4aba8e7d4289f99e
  _typeExprGen :: Types.Function -> Types.Exp
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SLS),1*U(1*U,A,U)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Types.Function) ->
                 case ds of wild { Types.Function ds1 ds2 ds3 ->
                 Utils._mulSubst
                   ds3
                   (GHC.Base.build
                      @ Types.Bind
                      (\ @ b1
                         (c :: Types.Bind -> b1 -> b1)[OneShot]
                         (n :: b1)[OneShot] ->
                       GHC.Base.foldr
                         @ (Types.Type, GHC.Base.String)
                         @ b1
                         (GHC.Base.mapFB
                            @ Types.Bind
                            @ b1
                            @ (Types.Type, GHC.Base.String)
                            c
                            Eval._typeExprGen1)
                         n
                         ds1)) }) -}
37a74cd81c57b80190a8eb7df3902c08
  _typeExprGen1 :: (Types.Type, GHC.Base.String) -> Types.Bind
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U,U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: (Types.Type, GHC.Base.String)) ->
                 case ds of wild { (,) t id ->
                 Types.Bind id (Types.TypeCheck t) Types.T_TypeCheck }) -}
d94dc0f5ab1b567a61a88d46384f47bb
  findParenthesis ::
    Types.Exp -> GHC.Base.String -> GHC.Base.String -> Eval.Parenthesis
  {- Arity: 3, Strictness: <S,1*U><L,U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ (ws :: Types.Exp)
                   (b :: GHC.Base.String)
                   (e :: GHC.Base.String) ->
                 Eval._findParenthesis
                   ws
                   Eval.findParenthesis1
                   (Types.Tobe b)
                   (Types.Tobe e)) -}
f5f1681883e530571395fe93091dfec0
  findParenthesis1 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (-1) -}
0a4cc260c7c040500f63063e91cbc441
  functionTypeCheck :: [Types.Bind] -> Types.Function -> Types.Wrd
  {- Arity: 2, Strictness: <L,U><S(SLS),1*U(1*U,A,U)>,
     Unfolding: InlineRule (2, True, False)
                (\ (binds :: [Types.Bind]) (f :: Types.Function) ->
                 case f of wild { Types.Function ds ds1 ds2 ->
                 case Eval._eval
                        Types.M_TypeCheck
                        binds
                        (Utils._mulSubst
                           ds2
                           (GHC.Base.build
                              @ Types.Bind
                              (\ @ b1
                                 (c :: Types.Bind -> b1 -> b1)[OneShot]
                                 (n :: b1)[OneShot] ->
                               GHC.Base.foldr
                                 @ (Types.Type, GHC.Base.String)
                                 @ b1
                                 (GHC.Base.mapFB
                                    @ Types.Bind
                                    @ b1
                                    @ (Types.Type, GHC.Base.String)
                                    c
                                    Eval._typeExprGen1)
                                 n
                                 ds))) of wild1 { (,) x18 ds3 ->
                 x18 } }) -}
1592147282a93b7867e1f08a13d6e272
  myReadBool ::
    Data.Either.Either GHC.Base.String Types.Wrd
    -> Data.Either.Either GHC.Base.String Types.Wrd
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: Data.Either.Either
                            GHC.Base.String Types.Wrd) ->
                 case ds of wild {
                   Data.Either.Left s
                   -> case Text.Read.readEither8
                             @ GHC.Types.Bool
                             (Text.ParserCombinators.ReadP.run
                                @ GHC.Types.Bool
                                Eval._evalWrd3
                                s) of wild1 {
                        [] -> wild
                        : x18 ds1
                        -> case ds1 of wild2 {
                             []
                             -> Data.Either.Right @ GHC.Base.String @ Types.Wrd (Types.Bool x18)
                             : ipv ipv1 -> wild } }
                   Data.Either.Right w -> wild }) -}
21683cf2d0105488bb5a4cd200ab8f21
  myReadDouble ::
    Data.Either.Either GHC.Base.String Types.Wrd
    -> Data.Either.Either GHC.Base.String Types.Wrd
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: Data.Either.Either
                            GHC.Base.String Types.Wrd) ->
                 case ds of wild {
                   Data.Either.Left s
                   -> case Text.Read.readEither8
                             @ GHC.Types.Double
                             (Text.ParserCombinators.ReadP.run
                                @ GHC.Types.Double
                                Eval._evalWrd2
                                s) of wild1 {
                        [] -> wild
                        : x18 ds1
                        -> case ds1 of wild2 {
                             []
                             -> Data.Either.Right
                                  @ GHC.Base.String
                                  @ Types.Wrd
                                  (Types.Double x18)
                             : ipv ipv1 -> wild } }
                   Data.Either.Right u -> wild }) -}
4e4adaa3a6ae9efe5fe1b6a139cd4da3
  myReadInt ::
    Data.Either.Either GHC.Base.String Types.Wrd
    -> Data.Either.Either GHC.Base.String Types.Wrd
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: Data.Either.Either
                            GHC.Base.String Types.Wrd) ->
                 case ds of wild {
                   Data.Either.Left s
                   -> case Text.Read.readEither8
                             @ GHC.Types.Int
                             (Text.ParserCombinators.ReadP.run
                                @ GHC.Types.Int
                                Eval._evalWrd1
                                s) of wild1 {
                        [] -> wild
                        : x18 ds1
                        -> case ds1 of wild2 {
                             []
                             -> Data.Either.Right @ GHC.Base.String @ Types.Wrd (Types.Int x18)
                             : ipv ipv1 -> wild } }
                   Data.Either.Right u -> wild }) -}
trusted: none
require own pkg trusted: False
module header:
  Nothing
declaration docs:
arg docs:


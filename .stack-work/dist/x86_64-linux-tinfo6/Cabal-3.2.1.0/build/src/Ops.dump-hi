
==================== FINAL INTERFACE ====================
2021-04-08 12:27:35.0572706 UTC

interface Topos-0.1.0.0-L2hSunVxFDyol1qAzNo2F:Ops 8104
  interface hash: ea8c7895a3d1a7a01fa1777bc2c23497
  ABI hash: d150b60c27dc32f3b81e8e6b8ed7e7e9
  export-list hash: 24531ef125d46d1c52ba79243a43b497
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 358a18e1043fc7ac1b015a88503b1325
  opt_hash: cb09a535710eb16767a299f2ded44a31
  hpc_hash: 93b885adfe0da089cdf634904fd59f71
  plugin_hash: ad164012d6b1e14942349d58b1132007
  sig of: Nothing
  used TH splices: False
  where
exports:
  Ops._add
  Ops._add0
  Ops._add_t
  Ops._and
  Ops._and_t
  Ops._div
  Ops._div0
  Ops._div_t
  Ops._eq
  Ops._eq_t
  Ops._fst
  Ops._fst_t
  Ops._geq
  Ops._geq0
  Ops._geq_t
  Ops._getType
  Ops._gt
  Ops._gt0
  Ops._gt_t
  Ops._head
  Ops._head0
  Ops._head_t
  Ops._isConsistentType
  Ops._isEmpty
  Ops._isEmpty_t
  Ops._leq
  Ops._leq0
  Ops._leq_t
  Ops._lt
  Ops._lt0
  Ops._lt_t
  Ops._map
  Ops._map0
  Ops._map_t
  Ops._mul
  Ops._mul0
  Ops._mul_t
  Ops._neq
  Ops._neq_t
  Ops._not
  Ops._not_t
  Ops._opls
  Ops._opls_dec
  Ops._or
  Ops._or_t
  Ops._pop
  Ops._pop0
  Ops._pop_t
  Ops._print
  Ops._print0
  Ops._print_t
  Ops._seq
  Ops._seq0
  Ops._seq_t
  Ops._snd
  Ops._snd_t
  Ops._sub
  Ops._sub0
  Ops._sub_t
  Ops._succ
  Ops._succ0
  Ops._succ_t
  Ops._tail
  Ops._tail0
  Ops._tail_t
  Ops._take
  Ops._take0
  Ops._take_t
  Ops._typeFunction
  Ops.isConsistentType
  Ops.toList
module dependencies: Parser Types
package dependencies: base-4.14.1.0 ghc-prim-0.6.1
                      integer-gmp-1.0.3.0
orphans: base-4.14.1.0:GHC.Float base-4.14.1.0:GHC.Base
family instance modules: base-4.14.1.0:Control.Applicative
                         base-4.14.1.0:Control.Arrow base-4.14.1.0:Data.Functor.Const
                         base-4.14.1.0:Data.Functor.Identity base-4.14.1.0:Data.Monoid
                         base-4.14.1.0:Data.Semigroup.Internal base-4.14.1.0:GHC.Generics
                         base-4.14.1.0:GHC.IO.Exception
import  -/  Parser 3443f1228a5fa43ab36605baa220d75c
  exports: 4e79c2f1fd013aabc39c8f81cd5374c7
import  -/  Types b9822497053d2122dc73d0cfdd1b339f
  exports: 39b07b7f7957277f50c7c4dd7689ef5f
  BinOp d26ca552c0a6cb13c3d3e231f243d460
  Bool b70cd53ad7a85dab48bcef177c38636b
  Double b891f973d45771521238fab46a6ae819
  Err 49657f448604d6729aba97b2988953b9
  Exp 607e5ce3f9595614a9cb77b2c4210b74
  Fun 6815ac0e2ecfff4e0c829eba93adbd8b
  Func c1251ac84fede6c4ca7d3c4f0601d771
  FuncOp 97bc2911206d2b50aa94a433bccfe820
  Function 267e8a4d83f0f1e1729f2be1e5904e81
  Int 1626c1e059773b609f52829c5bb3fa74
  List bf4e22584c08f0cbc93d4ad500ad7f0d
  Op 607e5ce3f9595614a9cb77b2c4210b74
  Operator 89cca03e93ee20a41b3c3642d9fd3bba
  PreList 2cd63c03f6681ef78c8cf47e3c7f2b35
  Print e87b8ebec85f3fc24f975cc1e7e3e2cd
  Str 8b8af5b0acf7e0323f4cbb1ea5827222
  StrOp 607e5ce3f9595614a9cb77b2c4210b74
  T_Bool 3d5d104ad17812f63feb2aef3b1ad4cd
  T_Double 5e54cc1d20b392ed3d5fa02d6324f88c
  T_EmptyList 260f30ad032fd2d54f4552772b925552
  T_Error 235a36067aa706ad3f38a03931790620
  T_Func cd5569cdd28f55b0418b44742170970e
  T_Function 8cc668be17da098d88dc5ce953523aaa
  T_Int 4e42539dd2ce6e4876d946eaf17319c8
  T_List 54c5b828c2e4f1c661388c72c68886ad
  T_Operator 2b724b9e8f3f49af40f551abcf01d31a
  T_PreList c17694220febf02b1e3f97947f51ad95
  T_Print c36f4bc1af49ddd4b4541db838e6f9c0
  T_String 236f270036a6e60f712f937a8a1e2ed8
  T_Tuple e233fd3595057c845dc31260603df806
  T_Type c87dc5b3bf8d798697d64f66a60f27f0
  T_Unknown 6666a7ed1e898402891d2d748621a86d
  Tobe 114668cd72acff1452b72cb75dca7503
  Tuple 24eb98ce397df75e853fb8c92b81a145
  Type bd4ecaf43435ec6d916df969f32b0e1c
  Type 607e5ce3f9595614a9cb77b2c4210b74
  TypeCheck 7a98c1d9491014e3cc63bc169a5dd418
  UnOp 8c7eed723ee8887a5e082490f6ddf7d6
  Wrd 607e5ce3f9595614a9cb77b2c4210b74
  args 607e5ce3f9595614a9cb77b2c4210b74
  args_t 607e5ce3f9595614a9cb77b2c4210b74
  ret 607e5ce3f9595614a9cb77b2c4210b74
  ret_t 607e5ce3f9595614a9cb77b2c4210b74
  return_t 607e5ce3f9595614a9cb77b2c4210b74
import  -/  base-4.14.1.0:Data.List aa48efeea2e877aaa8c12a1a2e589508
import  -/  base-4.14.1.0:Debug.Trace 311b1d0b6fcef7b89debc64460553e8a
import  -/  base-4.14.1.0:GHC.Base ede51775731a544ddfcb02b5a427fd38
import  -/  base-4.14.1.0:GHC.List 7a32e59b6a27bd558cb52809f6fb6df5
import  -/  base-4.14.1.0:GHC.Num 5f3708b0d1d7a8d15017be85d4a06a34
import  -/  base-4.14.1.0:GHC.Real 4d6025ac56d7c23e0804ecdff4f69d75
import  -/  base-4.14.1.0:GHC.Show 57e93b26a19b08606d2ae3a6ff8065f2
import  -/  base-4.14.1.0:Prelude 5c84dfddbb8583fc340ecd15bead164a
import  -/  ghc-prim-0.6.1:GHC.Classes e50fb3f1cbf74ce4d3874442e4300a09
0077ca7edccd6222f88376e346118960
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module Ops.$trModule3 Ops.$trModule1) -}
c0e5d35f6a7bc4656ee570ea88581d20
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Ops.$trModule2) -}
f9b25b5dbdc46f2d265939d718e84bed
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Ops"#) -}
dfcd064acd8070b26ffa8c69c30fddf9
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Ops.$trModule4) -}
ca9bc36dca399398b222432313c4b910
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("Topos-0.1.0.0-L2hSunVxFDyol1qAzNo2F"#) -}
103fbd3fa54e1684446b8b9b09d6e3c7
  $wshowl :: [Types.Wrd] -> (# GHC.Types.Char, [GHC.Types.Char] #)
  {- Arity: 1, Strictness: <S,1*U>, Inline: [2] -}
b09cc786b72fd2818f6d6eea05286af0
  _add :: Types.Op
  {- Strictness: m1, Unfolding: (Types.BinOp Ops._add0) -}
f75419664c688defc087f76d32d22656
  _add0 :: Types.Wrd -> Types.Wrd -> Types.Wrd
  {- Arity: 2, Strictness: <S,U><L,U>,
     Unfolding: (\ (ds :: Types.Wrd) (ds1 :: Types.Wrd) ->
                 let {
                   fail :: GHC.Prim.Void# -> Types.Wrd
                     <join 1> {- Arity: 1, Strictness: <L,A> -}
                   = \ (ds2 :: GHC.Prim.Void#)[OneShot] ->
                     Types.Err
                       (GHC.CString.unpackAppendCString#
                          Ops._add2
                          (GHC.Base.++
                             @ GHC.Types.Char
                             (Types.$fShowBind_$cshow ds)
                             (GHC.CString.unpackAppendCString#
                                Ops._add1
                                (Types.$fShowBind_$cshow ds1))))
                 } in
                 case ds of wild {
                   DEFAULT -> fail GHC.Prim.void#
                   Types.Str s1
                   -> case ds1 of wild1 {
                        DEFAULT -> fail GHC.Prim.void#
                        Types.Str s2 -> Types.Str (GHC.Base.++ @ GHC.Types.Char s1 s2) }
                   Types.Double x
                   -> case ds1 of wild1 {
                        DEFAULT -> fail GHC.Prim.void#
                        Types.Double y -> Types.Double (GHC.Float.plusDouble x y)
                        Types.Int y
                        -> Types.Double
                             (case x of wild2 { GHC.Types.D# x1 ->
                              case y of wild3 { GHC.Types.I# i ->
                              GHC.Types.D# (GHC.Prim.+## x1 (GHC.Prim.int2Double# i)) } }) }
                   Types.Int x
                   -> case ds1 of wild1 {
                        DEFAULT -> fail GHC.Prim.void#
                        Types.Double y
                        -> Types.Double
                             (case x of wild2 { GHC.Types.I# i ->
                              case y of wild3 { GHC.Types.D# y1 ->
                              GHC.Types.D# (GHC.Prim.+## (GHC.Prim.int2Double# i) y1) } })
                        Types.Int y -> Types.Int (GHC.Num.$fNumInt_$c+ x y) }
                   Types.List l1
                   -> case ds1 of wild1 {
                        DEFAULT -> fail GHC.Prim.void#
                        Types.List l2 -> Ops.toList (GHC.Base.++ @ Types.Wrd l1 l2) } }) -}
9a2955ab09703cd32219213c1c5551c7
  _add1 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: (", y="#) -}
a8bc2cb4b2ded22b4496a1fbed2cab76
  _add2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("`+`: Illegal input value: x="#) -}
30b5baf3006a0617b9d4a275f0812218
  _add_t :: Types.Wrd -> Types.Wrd -> Types.Wrd
  {- Arity: 2, Strictness: <S,U><L,U>,
     Unfolding: (\ (ds :: Types.Wrd) (ds1 :: Types.Wrd) ->
                 let {
                   fail :: GHC.Prim.Void# -> Types.Wrd
                     <join 1> {- Arity: 1, Strictness: <L,A> -}
                   = \ (ds2 :: GHC.Prim.Void#)[OneShot] ->
                     Types.Err
                       (GHC.CString.unpackAppendCString#
                          Ops._add_t7
                          (GHC.Base.++
                             @ GHC.Types.Char
                             (Types.$fShowBind_$cshow ds)
                             (GHC.CString.unpackAppendCString#
                                Ops._add_t6
                                (Types.$fShowBind_$cshow ds1))))
                 } in
                 case ds of wild {
                   DEFAULT -> fail GHC.Prim.void#
                   Types.TypeCheck ds2
                   -> case ds2 of wild1 {
                        DEFAULT -> fail GHC.Prim.void#
                        Types.T_Int
                        -> case ds1 of wild2 {
                             DEFAULT -> fail GHC.Prim.void#
                             Types.TypeCheck ds3
                             -> case ds3 of wild3 {
                                  DEFAULT -> fail GHC.Prim.void#
                                  Types.T_Int -> Ops._add_t5
                                  Types.T_Double -> Ops._add_t4 } }
                        Types.T_Double
                        -> case ds1 of wild2 {
                             DEFAULT -> fail GHC.Prim.void#
                             Types.TypeCheck ds3
                             -> case ds3 of wild3 {
                                  DEFAULT -> fail GHC.Prim.void#
                                  Types.T_Int -> Ops._add_t4
                                  Types.T_Double -> Ops._add_t4 } }
                        Types.T_String
                        -> case ds1 of wild2 {
                             DEFAULT -> fail GHC.Prim.void#
                             Types.TypeCheck ds3
                             -> case ds3 of wild3 {
                                  DEFAULT -> fail GHC.Prim.void# Types.T_String -> Ops._add_t3 } }
                        Types.T_List t1
                        -> case ds1 of wild2 {
                             DEFAULT -> fail GHC.Prim.void#
                             Types.TypeCheck ds3
                             -> case ds3 of wild3 {
                                  DEFAULT -> fail GHC.Prim.void#
                                  Types.T_List t2
                                  -> case Types.$fEqBind_$c==1 t1 t2 of wild4 {
                                       GHC.Types.False
                                       -> Types.Err
                                            (GHC.CString.unpackAppendCString#
                                               Ops._add_t2
                                               (GHC.Base.++
                                                  @ GHC.Types.Char
                                                  (Types.$fShowBind_$cshowsPrec1
                                                     Types.$fShowBind2
                                                     t1
                                                     (GHC.Types.[] @ GHC.Types.Char))
                                                  (GHC.CString.unpackAppendCString#
                                                     Ops._add_t1
                                                     (Types.$fShowBind_$cshowsPrec1
                                                        Types.$fShowBind2
                                                        t2
                                                        (GHC.Types.[] @ GHC.Types.Char)))))
                                       GHC.Types.True -> wild } } } } }) -}
5c8d703e7770c4e8447f48c788ccdb0d
  _add_t1 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: (", t2="#) -}
d3a83146be059780d910ef8ebb52a172
  _add_t2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("`+`: Wrd mismatch of lists: t1="#) -}
d190d3240a169a5858d83ca487319ad4
  _add_t3 :: Types.Wrd
  {- HasNoCafRefs, Strictness: m18,
     Unfolding: (Types.TypeCheck Types.T_String) -}
fb5b4c1dffad40319e2e1fbb0f2e20df
  _add_t4 :: Types.Wrd
  {- HasNoCafRefs, Strictness: m18,
     Unfolding: (Types.TypeCheck Types.T_Double) -}
5f4ddcb9f19056ec283cac24ff6f6c55
  _add_t5 :: Types.Wrd
  {- HasNoCafRefs, Strictness: m18,
     Unfolding: (Types.TypeCheck Types.T_Int) -}
239af5d931f67d83328a03e6fe09ee73
  _add_t6 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: (", t_y="#) -}
6854d4481a0f7da1f8adb1f67c37d344
  _add_t7 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("`+`: Illegal input type: t_x="#) -}
fa9d3d44a843355e1a149e4f4bc13246
  _and :: Types.Op
  {- Strictness: m1, Unfolding: (Types.BinOp Ops._and1) -}
65fdf0575a74fc92b6ff2a5e6dff7cb8
  _and1 :: Types.Wrd -> Types.Wrd -> Types.Wrd
  {- Arity: 2, Strictness: <S,1*U><S,1*U>m8, Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Types.Wrd) (w1 :: Types.Wrd) ->
                 case w of wild {
                   DEFAULT
                   -> Control.Exception.Base.patError
                        @ 'GHC.Types.LiftedRep
                        @ Types.Wrd
                        Ops._and2
                   Types.Bool a
                   -> case w1 of wild1 {
                        DEFAULT
                        -> Control.Exception.Base.patError
                             @ 'GHC.Types.LiftedRep
                             @ Types.Wrd
                             Ops._and2
                        Types.Bool b
                        -> Types.Bool
                             (case a of wild2 {
                                GHC.Types.False -> GHC.Types.False GHC.Types.True -> b }) } }) -}
1f7134b1bcd7b2d76cf3ff28f5e470eb
  _and2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("src/Ops.hs:246:15-51|lambda"#) -}
fc2743656532e0ef05c809643682003d
  _and_t :: Types.Wrd -> Types.Wrd -> Types.Wrd
  {- Arity: 2, Strictness: <S,1*U><S,U>,
     Unfolding: (\ (ds :: Types.Wrd) (ds1 :: Types.Wrd) ->
                 case ds of wild {
                   DEFAULT -> Ops._and_t4
                   Types.TypeCheck ds2
                   -> let {
                        fail :: GHC.Prim.Void# -> Types.Wrd
                          <join 1> {- Arity: 1, Strictness: <L,A> -}
                        = \ (ds3 :: GHC.Prim.Void#)[OneShot] ->
                          case ds1 of wild1 {
                            DEFAULT -> Ops._and_t4
                            Types.TypeCheck t2
                            -> Types.Err
                                 (GHC.CString.unpackAppendCString#
                                    Ops._and_t3
                                    (GHC.Base.++
                                       @ GHC.Types.Char
                                       (Types.$fShowBind_$cshowsPrec1
                                          Types.$fShowBind2
                                          ds2
                                          (GHC.Types.[] @ GHC.Types.Char))
                                       (GHC.CString.unpackAppendCString#
                                          Ops._and_t2
                                          (Types.$fShowBind_$cshowsPrec1
                                             Types.$fShowBind2
                                             t2
                                             (GHC.Types.[] @ GHC.Types.Char))))) }
                      } in
                      case ds2 of wild1 {
                        DEFAULT -> fail GHC.Prim.void#
                        Types.T_Bool
                        -> case ds1 of wild2 {
                             DEFAULT -> fail GHC.Prim.void#
                             Types.TypeCheck ds3
                             -> case ds3 of wild3 {
                                  DEFAULT -> fail GHC.Prim.void#
                                  Types.T_Bool -> Ops._and_t1 } } } }) -}
0575596eea8627eaa7ec602fa858dd65
  _and_t1 :: Types.Wrd
  {- HasNoCafRefs, Strictness: m18,
     Unfolding: (Types.TypeCheck Types.T_Bool) -}
c14ad5c14b5d2e5fb364d19e075b9eee
  _and_t2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: (", RHS="#) -}
21a5a768a8a30fa169189ca503f4e131
  _and_t3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("`&&`: Illegal input type: LHS="#) -}
9693e7053c71e48558cd3548c629ee1d
  _and_t4 :: Types.Wrd
  {- Strictness: b -}
16e5c02c7fdde6e2b46ac08b12e746ed
  _div :: Types.Op
  {- Strictness: m1, Unfolding: (Types.BinOp Ops._div0) -}
98ac439b5a9aaf318bcd7c354a12eac4
  _div0 :: Types.Wrd -> Types.Wrd -> Types.Wrd
  {- Arity: 2, Strictness: <L,U><S,U>,
     Unfolding: (\ (ds :: Types.Wrd) (ds1 :: Types.Wrd) ->
                 let {
                   fail :: GHC.Prim.Void# -> Types.Wrd
                     <join 1> {- Arity: 1, Strictness: <L,A> -}
                   = \ (ds2 :: GHC.Prim.Void#)[OneShot] ->
                     let {
                       fail1 :: GHC.Prim.Void# -> Types.Wrd
                         <join 1> {- Arity: 1, Strictness: <L,A> -}
                       = \ (ds3 :: GHC.Prim.Void#)[OneShot] ->
                         Types.Err
                           (GHC.CString.unpackAppendCString#
                              Ops._div4
                              (GHC.Base.++
                                 @ GHC.Types.Char
                                 (Types.$fShowBind_$cshow ds)
                                 (GHC.CString.unpackAppendCString#
                                    Ops._add1
                                    (Types.$fShowBind_$cshow ds1))))
                     } in
                     case ds of wild {
                       DEFAULT -> fail1 GHC.Prim.void#
                       Types.Double x
                       -> case ds1 of wild1 {
                            DEFAULT -> fail1 GHC.Prim.void#
                            Types.Double y -> Types.Double (GHC.Float.divideDouble x y)
                            Types.Int y
                            -> Types.Double
                                 (case x of wild2 { GHC.Types.D# x1 ->
                                  case y of wild3 { GHC.Types.I# i ->
                                  case GHC.Prim./##
                                         x1
                                         (GHC.Prim.int2Double# i) of wild4 { DEFAULT ->
                                  GHC.Types.D# wild4 } } }) }
                       Types.Int x
                       -> case ds1 of wild1 {
                            DEFAULT -> fail1 GHC.Prim.void#
                            Types.Double y
                            -> Types.Double
                                 (case x of wild2 { GHC.Types.I# i ->
                                  case y of wild3 { GHC.Types.D# y1 ->
                                  case GHC.Prim./##
                                         (GHC.Prim.int2Double# i)
                                         y1 of wild4 { DEFAULT ->
                                  GHC.Types.D# wild4 } } })
                            Types.Int y
                            -> Types.Double
                                 (case x of wild2 { GHC.Types.I# i ->
                                  case y of wild3 { GHC.Types.I# i1 ->
                                  case GHC.Prim./##
                                         (GHC.Prim.int2Double# i)
                                         (GHC.Prim.int2Double# i1) of wild4 { DEFAULT ->
                                  GHC.Types.D# wild4 } } }) } }
                 } in
                 case ds1 of wild {
                   DEFAULT -> fail GHC.Prim.void#
                   Types.Double ds2
                   -> case ds2 of wild1 { GHC.Types.D# x ->
                      case GHC.Prim.==## x 0.0## of lwild {
                        DEFAULT -> fail GHC.Prim.void# 1# -> Ops._div1 } }
                   Types.Int ds2
                   -> case ds2 of wild1 { GHC.Types.I# ds3 ->
                      case ds3 of ds4 {
                        DEFAULT -> fail GHC.Prim.void# 0# -> Ops._div1 } } }) -}
19dda39c709a76a75b855b37d8c43079
  _div1 :: Types.Wrd
  {- Strictness: m12, Unfolding: (Types.Err Ops._div2) -}
8fca883992df908dfd44fa917f4b0d94
  _div2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Ops._div3) -}
dc79cca681dd9fde60bfc3224e841ebb
  _div3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Zero division error."#) -}
24854537f568b7ddd76b5c1c5f5d12d9
  _div4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("`/`: Illegal input value: x="#) -}
57a81904c4c4fcff5f48389606fe3995
  _div_t :: Types.Wrd -> Types.Wrd -> Types.Wrd
  {- Arity: 2, Strictness: <S,U><L,U>,
     Unfolding: (\ (ds :: Types.Wrd) (ds1 :: Types.Wrd) ->
                 let {
                   fail :: GHC.Prim.Void# -> Types.Wrd
                     <join 1> {- Arity: 1, Strictness: <L,A> -}
                   = \ (ds2 :: GHC.Prim.Void#)[OneShot] ->
                     Types.Err
                       (GHC.CString.unpackAppendCString#
                          Ops._div_t1
                          (GHC.Base.++
                             @ GHC.Types.Char
                             (Types.$fShowBind_$cshow ds)
                             (GHC.CString.unpackAppendCString#
                                Ops._add_t6
                                (Types.$fShowBind_$cshow ds1))))
                 } in
                 case ds of wild {
                   DEFAULT -> fail GHC.Prim.void#
                   Types.TypeCheck ds2
                   -> case ds2 of wild1 {
                        DEFAULT -> fail GHC.Prim.void#
                        Types.T_Int
                        -> case ds1 of wild2 {
                             DEFAULT -> fail GHC.Prim.void#
                             Types.TypeCheck ds3
                             -> case ds3 of wild3 {
                                  DEFAULT -> fail GHC.Prim.void#
                                  Types.T_Int -> Ops._add_t4
                                  Types.T_Double -> Ops._add_t4 } }
                        Types.T_Double
                        -> case ds1 of wild2 {
                             DEFAULT -> fail GHC.Prim.void#
                             Types.TypeCheck ds3
                             -> case ds3 of wild3 {
                                  DEFAULT -> fail GHC.Prim.void#
                                  Types.T_Int -> Ops._add_t4
                                  Types.T_Double -> Ops._add_t4 } } } }) -}
4ccdf900e6414f9d5439cf6f1f1322a6
  _div_t1 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("`/`: Illegal input type: t_x="#) -}
2fde59f8571c8c3c3fa3bdd5c020064e
  _eq :: Types.Op
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (Types.BinOp Ops._eq1) -}
1a00180c42e0b2b55d2f58601964e6b6
  _eq1 :: Types.Wrd -> Types.Wrd -> Types.Wrd
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U><L,1*U>m8,
     Unfolding: InlineRule (2, True, False)
                (\ (a :: Types.Wrd) (b :: Types.Wrd) ->
                 Types.Bool (Types.$fEqBind_$c==2 a b)) -}
d1338c4a35a837bd4872ab8c0fde2433
  _eq_t :: Types.Wrd -> Types.Wrd -> Types.Wrd
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (ds :: Types.Wrd) (ds1 :: Types.Wrd) ->
                 case ds of wild {
                   DEFAULT -> Ops._eq_t2
                   Types.TypeCheck t1
                   -> case ds1 of wild1 {
                        DEFAULT -> Ops._eq_t2
                        Types.TypeCheck t2
                        -> case Types.$fEqBind_$c==1 t1 t2 of wild2 {
                             GHC.Types.False
                             -> Types.Err
                                  (GHC.CString.unpackAppendCString#
                                     Ops._eq_t1
                                     (GHC.Base.++
                                        @ GHC.Types.Char
                                        (Types.$fShowBind_$cshowsPrec1
                                           Types.$fShowBind2
                                           t1
                                           (GHC.Types.[] @ GHC.Types.Char))
                                        (GHC.CString.unpackAppendCString#
                                           Ops._and_t2
                                           (Types.$fShowBind_$cshowsPrec1
                                              Types.$fShowBind2
                                              t2
                                              (GHC.Types.[] @ GHC.Types.Char)))))
                             GHC.Types.True -> Ops._and_t1 } } }) -}
0b4c5bafe1abd3d6896f903edaf7e6e6
  _eq_t1 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("`=`: Wrd mismatch of both sides: LHS="#) -}
53759b9cbfc052c8891b8ffe90d7f3d6
  _eq_t2 :: Types.Wrd
  {- Strictness: b -}
0eb18df97009ded23de5d637589860c4
  _fst :: Types.Op
  {- Strictness: m2, Unfolding: (Types.UnOp Ops._fst1) -}
4959f964ff44e95bae217658d155b02e
  _fst1 :: Types.Wrd -> Types.Wrd
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Types.Wrd) ->
                 case ds of wild {
                   DEFAULT
                   -> Control.Exception.Base.patError
                        @ 'GHC.Types.LiftedRep
                        @ Types.Wrd
                        Ops._fst2
                   Types.Tuple ds1
                   -> case ds1 of wild1 {
                        []
                        -> Control.Exception.Base.patError
                             @ 'GHC.Types.LiftedRep
                             @ Types.Wrd
                             Ops._fst2
                        : w1 ds2 -> w1 } }) -}
891d4cbd35d062601eaf7ec0eb646755
  _fst2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("src/Ops.hs:340:14-37|lambda"#) -}
c4545c97a056aabd7444aca279e04d89
  _fst_t :: Types.Wrd -> Types.Wrd
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: Types.Wrd) ->
                 case ds of wild {
                   DEFAULT
                   -> Types.Err
                        (GHC.CString.unpackAppendCString#
                           Ops._fst_t1
                           (Types.$fShowBind_$cshow wild))
                   Types.TypeCheck ds1
                   -> case ds1 of wild1 {
                        DEFAULT
                        -> Types.Err
                             (GHC.CString.unpackAppendCString#
                                Ops._fst_t1
                                (Types.$fShowBind_$cshow wild))
                        Types.T_Tuple ds2
                        -> case ds2 of wild2 {
                             []
                             -> Types.Err
                                  (GHC.CString.unpackAppendCString#
                                     Ops._fst_t1
                                     (Types.$fShowBind_$cshow wild))
                             : t ds3 -> Types.TypeCheck t } } }) -}
b6bc0ed9cd47a6358c2ac6aace023af5
  _fst_t1 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("fst: Illegal input type: "#) -}
80d146b862fbd4f89add80c9ea8a883e
  _geq :: Types.Op
  {- Strictness: m1, Unfolding: (Types.BinOp Ops._geq0) -}
cbbca7b326cd07229b83dd97fc973ea5
  _geq0 :: Types.Wrd -> Types.Wrd -> Types.Wrd
  {- Arity: 2, Strictness: <S,1*U><S,1*U>m8, Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Types.Wrd) (w1 :: Types.Wrd) ->
                 case w of wild {
                   DEFAULT -> Ops._geq1
                   Types.Double x
                   -> case w1 of wild1 {
                        DEFAULT -> Ops._geq1
                        Types.Double y
                        -> Types.Bool
                             (case x of wild2 { GHC.Types.D# x1 ->
                              case y of wild3 { GHC.Types.D# y1 ->
                              GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.>=## x1 y1) } })
                        Types.Int y
                        -> Types.Bool
                             (case x of wild2 { GHC.Types.D# x1 ->
                              case y of wild3 { GHC.Types.I# i ->
                              GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.>=## x1 (GHC.Prim.int2Double# i)) } }) }
                   Types.Int x
                   -> case w1 of wild1 {
                        DEFAULT -> Ops._geq1
                        Types.Double y
                        -> Types.Bool
                             (case x of wild2 { GHC.Types.I# i ->
                              case y of wild3 { GHC.Types.D# y1 ->
                              GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.>=## (GHC.Prim.int2Double# i) y1) } })
                        Types.Int y -> Types.Bool (GHC.Classes.geInt x y) } }) -}
e562e95ce449faeda829e75ce75e884a
  _geq1 :: Types.Wrd
  {- Strictness: b -}
72da17c0c2b301d31a74998cda225ef3
  _geq_t :: Types.Wrd -> Types.Wrd -> Types.Wrd
  {- Arity: 2, Strictness: <S,1*U><S,U>,
     Unfolding: (\ (ds :: Types.Wrd) (ds1 :: Types.Wrd) ->
                 case ds of wild {
                   DEFAULT -> Ops._geq_t2
                   Types.TypeCheck ds2
                   -> let {
                        fail :: GHC.Prim.Void# -> Types.Wrd
                          <join 1> {- Arity: 1, Strictness: <L,A> -}
                        = \ (ds3 :: GHC.Prim.Void#)[OneShot] ->
                          case ds1 of wild1 {
                            DEFAULT -> Ops._geq_t2
                            Types.TypeCheck t2
                            -> Types.Err
                                 (GHC.CString.unpackAppendCString#
                                    Ops._geq_t1
                                    (GHC.Base.++
                                       @ GHC.Types.Char
                                       (Types.$fShowBind_$cshowsPrec1
                                          Types.$fShowBind2
                                          ds2
                                          (GHC.Types.[] @ GHC.Types.Char))
                                       (GHC.CString.unpackAppendCString#
                                          Ops._and_t2
                                          (Types.$fShowBind_$cshowsPrec1
                                             Types.$fShowBind2
                                             t2
                                             (GHC.Types.[] @ GHC.Types.Char))))) }
                      } in
                      case ds2 of wild1 {
                        DEFAULT -> fail GHC.Prim.void#
                        Types.T_Int
                        -> case ds1 of wild2 {
                             DEFAULT -> fail GHC.Prim.void#
                             Types.TypeCheck ds3
                             -> case ds3 of wild3 {
                                  DEFAULT -> fail GHC.Prim.void#
                                  Types.T_Int -> Ops._and_t1
                                  Types.T_Double -> Ops._and_t1 } }
                        Types.T_Double
                        -> case ds1 of wild2 {
                             DEFAULT -> fail GHC.Prim.void#
                             Types.TypeCheck ds3
                             -> case ds3 of wild3 {
                                  DEFAULT -> fail GHC.Prim.void#
                                  Types.T_Int -> Ops._and_t1
                                  Types.T_Double -> Ops._and_t1 } } } }) -}
bd2539ed84360f360a08990f0a8f318d
  _geq_t1 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("`>=`: Illegal input type: LHS="#) -}
317729e344ddf18d8949163a7d1c6659
  _geq_t2 :: Types.Wrd
  {- Strictness: b -}
90ff28e62a99dc82d7325615ac131599
  _getType :: Types.Wrd -> Types.Type
  {- Arity: 1, Strictness: <S,1*U> -}
dc62302f1b88389c68771da62d81a1e4
  _gt :: Types.Op
  {- Strictness: m1, Unfolding: (Types.BinOp Ops._gt0) -}
7c9ea80660d23b8e39137c03dacc0935
  _gt0 :: Types.Wrd -> Types.Wrd -> Types.Wrd
  {- Arity: 2, Strictness: <S,1*U><S,1*U>m8, Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Types.Wrd) (w1 :: Types.Wrd) ->
                 case w of wild {
                   DEFAULT -> Ops._gt1
                   Types.Double x
                   -> case w1 of wild1 {
                        DEFAULT -> Ops._gt1
                        Types.Double y
                        -> Types.Bool
                             (case x of wild2 { GHC.Types.D# x1 ->
                              case y of wild3 { GHC.Types.D# y1 ->
                              GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.>## x1 y1) } })
                        Types.Int y
                        -> Types.Bool
                             (case x of wild2 { GHC.Types.D# x1 ->
                              case y of wild3 { GHC.Types.I# i ->
                              GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.>## x1 (GHC.Prim.int2Double# i)) } }) }
                   Types.Int x
                   -> case w1 of wild1 {
                        DEFAULT -> Ops._gt1
                        Types.Double y
                        -> Types.Bool
                             (case x of wild2 { GHC.Types.I# i ->
                              case y of wild3 { GHC.Types.D# y1 ->
                              GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.>## (GHC.Prim.int2Double# i) y1) } })
                        Types.Int y -> Types.Bool (GHC.Classes.gtInt x y) } }) -}
eac7e6aa9fab27c3a709863a100d8491
  _gt1 :: Types.Wrd
  {- Strictness: b -}
15981ed38b5bf349c4a1cefb70e86295
  _gt_t :: Types.Wrd -> Types.Wrd -> Types.Wrd
  {- Arity: 2, Strictness: <S,1*U><S,U>,
     Unfolding: (\ (ds :: Types.Wrd) (ds1 :: Types.Wrd) ->
                 case ds of wild {
                   DEFAULT -> Ops._gt_t2
                   Types.TypeCheck ds2
                   -> let {
                        fail :: GHC.Prim.Void# -> Types.Wrd
                          <join 1> {- Arity: 1, Strictness: <L,A> -}
                        = \ (ds3 :: GHC.Prim.Void#)[OneShot] ->
                          case ds1 of wild1 {
                            DEFAULT -> Ops._gt_t2
                            Types.TypeCheck t2
                            -> Types.Err
                                 (GHC.CString.unpackAppendCString#
                                    Ops._gt_t1
                                    (GHC.Base.++
                                       @ GHC.Types.Char
                                       (Types.$fShowBind_$cshowsPrec1
                                          Types.$fShowBind2
                                          ds2
                                          (GHC.Types.[] @ GHC.Types.Char))
                                       (GHC.CString.unpackAppendCString#
                                          Ops._and_t2
                                          (Types.$fShowBind_$cshowsPrec1
                                             Types.$fShowBind2
                                             t2
                                             (GHC.Types.[] @ GHC.Types.Char))))) }
                      } in
                      case ds2 of wild1 {
                        DEFAULT -> fail GHC.Prim.void#
                        Types.T_Int
                        -> case ds1 of wild2 {
                             DEFAULT -> fail GHC.Prim.void#
                             Types.TypeCheck ds3
                             -> case ds3 of wild3 {
                                  DEFAULT -> fail GHC.Prim.void#
                                  Types.T_Int -> Ops._and_t1
                                  Types.T_Double -> Ops._and_t1 } }
                        Types.T_Double
                        -> case ds1 of wild2 {
                             DEFAULT -> fail GHC.Prim.void#
                             Types.TypeCheck ds3
                             -> case ds3 of wild3 {
                                  DEFAULT -> fail GHC.Prim.void#
                                  Types.T_Int -> Ops._and_t1
                                  Types.T_Double -> Ops._and_t1 } } } }) -}
59092bd74d2d278cba5cfbd0fa9b8e41
  _gt_t1 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("`>`: Illegal input type: LHS="#) -}
36684904f0776b02ee8213787e9d788c
  _gt_t2 :: Types.Wrd
  {- Strictness: b -}
09b17a90ddd9920901c34f63ec960a4f
  _head :: Types.Op
  {- Strictness: m2, Unfolding: (Types.UnOp Ops._head0) -}
03ea664eed18c7fb6729feddae94701e
  _head0 :: Types.Wrd -> Types.Wrd
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Types.Wrd) ->
                 case ds of wild {
                   DEFAULT -> Ops._head4
                   Types.List ds1
                   -> case ds1 of wild1 { [] -> Ops._head1 : x ds2 -> x } }) -}
6f852c778c53446089bd6af0fb1bf910
  _head1 :: Types.Wrd
  {- Strictness: m12, Unfolding: (Types.Err Ops._head2) -}
10595b0063f9a03ed93ee60883e08627
  _head2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Ops._head3) -}
3872cd20e640f04e630362819e26fdd3
  _head3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("head: Empty list."#) -}
fcae7ce061bdbd1164e63fc64a78dcf6
  _head4 :: Types.Wrd
  {- Strictness: b -}
2b27a262e2cee0e6012d0f773c37726c
  _head_t :: Types.Wrd -> Types.Wrd
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: Types.Wrd) ->
                 case ds of wild {
                   DEFAULT -> Ops._head_t2
                   Types.TypeCheck ds1
                   -> case ds1 of wild1 {
                        DEFAULT
                        -> Types.Err
                             (GHC.CString.unpackAppendCString#
                                Ops._head_t1
                                (Types.$fShowBind_$cshowsPrec1
                                   Types.$fShowBind2
                                   wild1
                                   (GHC.Types.[] @ GHC.Types.Char)))
                        Types.T_List t -> Types.TypeCheck t } }) -}
341a78104a1baa5a630af1beff815252
  _head_t1 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("head: Illegal input type: "#) -}
32283288a9801ad3e6c92855ef73629e
  _head_t2 :: Types.Wrd
  {- Strictness: b -}
21070a18bc5e91b4ed6dd4e6dcba2d17
  _isConsistentType :: Types.Exp -> GHC.Maybe.Maybe Types.Type
  {- Arity: 1, Strictness: <S,1*U> -}
2cab4733c94f1324e85361c661e2f965
  _isEmpty :: Types.Op
  {- Strictness: m2, Unfolding: (Types.UnOp Ops._isEmpty1) -}
069f04523ee84c456f4d2d941471e72e
  _isEmpty1 :: Types.Wrd -> Types.Wrd
  {- Arity: 1, Strictness: <S,1*U>m8,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Types.Wrd) ->
                 case ds of wild {
                   DEFAULT -> Ops._isEmpty2
                   Types.List ls
                   -> Types.Bool
                        (GHC.Classes.$fEq[]_$c==
                           @ Types.Wrd
                           Types.$fEqWrd
                           ls
                           (GHC.Types.[] @ Types.Wrd)) }) -}
0c2023312bf6364e43345ca3f69983e6
  _isEmpty2 :: Types.Wrd
  {- Strictness: b -}
2130fc56c55fd1b0c46640600408c9db
  _isEmpty_t :: Types.Wrd -> Types.Wrd
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: Types.Wrd) ->
                 case ds of wild {
                   DEFAULT -> Ops._isEmpty_t2
                   Types.TypeCheck ds1
                   -> case ds1 of wild1 {
                        DEFAULT
                        -> Types.Err
                             (GHC.CString.unpackAppendCString#
                                Ops._isEmpty_t1
                                (Types.$fShowBind_$cshowsPrec1
                                   Types.$fShowBind2
                                   wild1
                                   (GHC.Types.[] @ GHC.Types.Char)))
                        Types.T_List ds2 -> Ops._and_t1 } }) -}
7ee732c9199798439f16df2880508448
  _isEmpty_t1 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("isEmpty: Illegal input type: "#) -}
ab80dec497becdf5e41a02c3e730a2e8
  _isEmpty_t2 :: Types.Wrd
  {- Strictness: b -}
28cddcf7ff18d628d61e0df31b301893
  _leq :: Types.Op
  {- Strictness: m1, Unfolding: (Types.BinOp Ops._leq0) -}
ef20658217a524afdcb7faedfc30efc1
  _leq0 :: Types.Wrd -> Types.Wrd -> Types.Wrd
  {- Arity: 2, Strictness: <S,1*U><S,1*U>m8, Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Types.Wrd) (w1 :: Types.Wrd) ->
                 case w of wild {
                   DEFAULT -> Ops._leq1
                   Types.Double x
                   -> case w1 of wild1 {
                        DEFAULT -> Ops._leq1
                        Types.Double y
                        -> Types.Bool
                             (case x of wild2 { GHC.Types.D# x1 ->
                              case y of wild3 { GHC.Types.D# y1 ->
                              GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<=## x1 y1) } })
                        Types.Int y
                        -> Types.Bool
                             (case x of wild2 { GHC.Types.D# x1 ->
                              case y of wild3 { GHC.Types.I# i ->
                              GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.<=## x1 (GHC.Prim.int2Double# i)) } }) }
                   Types.Int x
                   -> case w1 of wild1 {
                        DEFAULT -> Ops._leq1
                        Types.Double y
                        -> Types.Bool
                             (case x of wild2 { GHC.Types.I# i ->
                              case y of wild3 { GHC.Types.D# y1 ->
                              GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.<=## (GHC.Prim.int2Double# i) y1) } })
                        Types.Int y -> Types.Bool (GHC.Classes.leInt x y) } }) -}
5d98df5d29f38260d0d315b543f4616a
  _leq1 :: Types.Wrd
  {- Strictness: b -}
0c4480fba1bdffbf3d1fbe1f4ff243fb
  _leq_t :: Types.Wrd -> Types.Wrd -> Types.Wrd
  {- Arity: 2, Strictness: <S,1*U><S,U>,
     Unfolding: (\ (ds :: Types.Wrd) (ds1 :: Types.Wrd) ->
                 case ds of wild {
                   DEFAULT -> Ops._leq_t1
                   Types.TypeCheck ds2
                   -> let {
                        fail :: GHC.Prim.Void# -> Types.Wrd
                          <join 1> {- Arity: 1, Strictness: <L,A> -}
                        = \ (ds3 :: GHC.Prim.Void#)[OneShot] ->
                          case ds1 of wild1 {
                            DEFAULT -> Ops._leq_t1
                            Types.TypeCheck t2
                            -> Types.Err
                                 (GHC.CString.unpackAppendCString#
                                    Ops._geq_t1
                                    (GHC.Base.++
                                       @ GHC.Types.Char
                                       (Types.$fShowBind_$cshowsPrec1
                                          Types.$fShowBind2
                                          ds2
                                          (GHC.Types.[] @ GHC.Types.Char))
                                       (GHC.CString.unpackAppendCString#
                                          Ops._and_t2
                                          (Types.$fShowBind_$cshowsPrec1
                                             Types.$fShowBind2
                                             t2
                                             (GHC.Types.[] @ GHC.Types.Char))))) }
                      } in
                      case ds2 of wild1 {
                        DEFAULT -> fail GHC.Prim.void#
                        Types.T_Int
                        -> case ds1 of wild2 {
                             DEFAULT -> fail GHC.Prim.void#
                             Types.TypeCheck ds3
                             -> case ds3 of wild3 {
                                  DEFAULT -> fail GHC.Prim.void#
                                  Types.T_Int -> Ops._and_t1
                                  Types.T_Double -> Ops._and_t1 } }
                        Types.T_Double
                        -> case ds1 of wild2 {
                             DEFAULT -> fail GHC.Prim.void#
                             Types.TypeCheck ds3
                             -> case ds3 of wild3 {
                                  DEFAULT -> fail GHC.Prim.void#
                                  Types.T_Int -> Ops._and_t1
                                  Types.T_Double -> Ops._and_t1 } } } }) -}
dbde1984146efbe9a371a2234b807329
  _leq_t1 :: Types.Wrd
  {- Strictness: b -}
b7ffa68aa46040f7c58f7806bc1a6468
  _lt :: Types.Op
  {- Strictness: m1, Unfolding: (Types.BinOp Ops._lt0) -}
b7310d1a5ac336aee8be98b65f3d41c1
  _lt0 :: Types.Wrd -> Types.Wrd -> Types.Wrd
  {- Arity: 2, Strictness: <S,1*U><S,1*U>m8, Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Types.Wrd) (w1 :: Types.Wrd) ->
                 case w of wild {
                   DEFAULT -> Ops._lt1
                   Types.Double x
                   -> case w1 of wild1 {
                        DEFAULT -> Ops._lt1
                        Types.Double y
                        -> Types.Bool
                             (case x of wild2 { GHC.Types.D# x1 ->
                              case y of wild3 { GHC.Types.D# y1 ->
                              GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<## x1 y1) } })
                        Types.Int y
                        -> Types.Bool
                             (case x of wild2 { GHC.Types.D# x1 ->
                              case y of wild3 { GHC.Types.I# i ->
                              GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.<## x1 (GHC.Prim.int2Double# i)) } }) }
                   Types.Int x
                   -> case w1 of wild1 {
                        DEFAULT -> Ops._lt1
                        Types.Double y
                        -> Types.Bool
                             (case x of wild2 { GHC.Types.I# i ->
                              case y of wild3 { GHC.Types.D# y1 ->
                              GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.<## (GHC.Prim.int2Double# i) y1) } })
                        Types.Int y -> Types.Bool (GHC.Classes.ltInt x y) } }) -}
c4ef4d9118bf40ca7b44369fd1f2e73b
  _lt1 :: Types.Wrd
  {- Strictness: b -}
a73d93a4e9ac002fee4b4370a5666be0
  _lt_t :: Types.Wrd -> Types.Wrd -> Types.Wrd
  {- Arity: 2, Strictness: <S,1*U><S,U>,
     Unfolding: (\ (ds :: Types.Wrd) (ds1 :: Types.Wrd) ->
                 case ds of wild {
                   DEFAULT -> Ops._lt_t2
                   Types.TypeCheck ds2
                   -> let {
                        fail :: GHC.Prim.Void# -> Types.Wrd
                          <join 1> {- Arity: 1, Strictness: <L,A> -}
                        = \ (ds3 :: GHC.Prim.Void#)[OneShot] ->
                          case ds1 of wild1 {
                            DEFAULT -> Ops._lt_t2
                            Types.TypeCheck t2
                            -> Types.Err
                                 (GHC.CString.unpackAppendCString#
                                    Ops._lt_t1
                                    (GHC.Base.++
                                       @ GHC.Types.Char
                                       (Types.$fShowBind_$cshowsPrec1
                                          Types.$fShowBind2
                                          ds2
                                          (GHC.Types.[] @ GHC.Types.Char))
                                       (GHC.CString.unpackAppendCString#
                                          Ops._and_t2
                                          (Types.$fShowBind_$cshowsPrec1
                                             Types.$fShowBind2
                                             t2
                                             (GHC.Types.[] @ GHC.Types.Char))))) }
                      } in
                      case ds2 of wild1 {
                        DEFAULT -> fail GHC.Prim.void#
                        Types.T_Int
                        -> case ds1 of wild2 {
                             DEFAULT -> fail GHC.Prim.void#
                             Types.TypeCheck ds3
                             -> case ds3 of wild3 {
                                  DEFAULT -> fail GHC.Prim.void#
                                  Types.T_Int -> Ops._and_t1
                                  Types.T_Double -> Ops._and_t1 } }
                        Types.T_Double
                        -> case ds1 of wild2 {
                             DEFAULT -> fail GHC.Prim.void#
                             Types.TypeCheck ds3
                             -> case ds3 of wild3 {
                                  DEFAULT -> fail GHC.Prim.void#
                                  Types.T_Int -> Ops._and_t1
                                  Types.T_Double -> Ops._and_t1 } } } }) -}
ad669454c0d29617cb7160243300953c
  _lt_t1 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("`<`: Illegal input type: LHS="#) -}
f13cf934ef7dfae56efd6391bf315353
  _lt_t2 :: Types.Wrd
  {- Strictness: b -}
8a570f44f9ede9d4f31d86264de830b8
  _map :: Types.Op
  {- Strictness: m3, Unfolding: (Types.FuncOp Ops._map1) -}
e4d6aa335075ef53e05ec7ef0c32b34a
  _map0 :: Types.Exp -> Types.Wrd
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ (ds :: [Types.Wrd]) ->
                 let {
                   fail :: GHC.Prim.Void# -> Types.Wrd
                     <join 1> {- Arity: 1, Strictness: <L,A> -}
                   = \ (ds1 :: GHC.Prim.Void#)[OneShot] ->
                     Types.Err
                       (GHC.CString.unpackAppendCString#
                          Ops._map2
                          (case ds of wild {
                             [] -> Ops.toList1
                             : x xs
                             -> GHC.Types.:
                                  @ GHC.Types.Char
                                  GHC.Show.showList__3
                                  (GHC.Base.++
                                     @ GHC.Types.Char
                                     (Types.$fShowBind_$cshow x)
                                     (case Ops.$wshowl xs of ww { (#,#) ww1 ww2 ->
                                      GHC.Types.: @ GHC.Types.Char ww1 ww2 })) }))
                 } in
                 case ds of wild {
                   [] -> fail GHC.Prim.void#
                   : ds1 ds2
                   -> case ds1 of wild1 {
                        DEFAULT -> fail GHC.Prim.void#
                        Types.Func f
                        -> case ds2 of wild2 {
                             [] -> fail GHC.Prim.void#
                             : ds3 ds4
                             -> case ds3 of wild3 {
                                  DEFAULT -> fail GHC.Prim.void#
                                  Types.List ls
                                  -> case ds4 of wild4 {
                                       []
                                       -> Types.PreList
                                            (GHC.Base.map
                                               @ Types.Wrd
                                               @ [Types.Wrd]
                                               (\ (w :: Types.Wrd) ->
                                                GHC.Types.:
                                                  @ Types.Wrd
                                                  wild1
                                                  (GHC.Types.:
                                                     @ Types.Wrd
                                                     w
                                                     (GHC.Types.[] @ Types.Wrd)))
                                               ls)
                                       : ipv ipv1 -> fail GHC.Prim.void# } } } } }) -}
6d1260b15c31039e31bb308506c332dc
  _map1 :: (GHC.Types.Int, Types.Exp -> Types.Wrd)
  {- Strictness: m, Unfolding: ((Ops._map3, Ops._map0)) -}
5a980710633d0031752e33525ab306c7
  _map2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("map: Illegal input value: "#) -}
26cbd2d6ef0999513a82757469e015cc
  _map3 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 2#) -}
a0871b5cad5308036789e4c30dcd1975
  _map_t :: Types.Exp -> Types.Wrd
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ (ds :: [Types.Wrd]) ->
                 let {
                   fail :: GHC.Prim.Void# -> Types.Wrd
                     <join 1> {- Arity: 1, Strictness: <L,A> -}
                   = \ (ds1 :: GHC.Prim.Void#)[OneShot] ->
                     Types.Err
                       (GHC.CString.unpackAppendCString#
                          Ops._map_t2
                          (case ds of wild {
                             [] -> Ops.toList1
                             : x xs
                             -> GHC.Types.:
                                  @ GHC.Types.Char
                                  GHC.Show.showList__3
                                  (GHC.Base.++
                                     @ GHC.Types.Char
                                     (Types.$fShowBind_$cshow x)
                                     (case Ops.$wshowl xs of ww { (#,#) ww1 ww2 ->
                                      GHC.Types.: @ GHC.Types.Char ww1 ww2 })) }))
                 } in
                 case ds of wild {
                   [] -> fail GHC.Prim.void#
                   : ds1 ds2
                   -> case ds1 of wild1 {
                        DEFAULT -> fail GHC.Prim.void#
                        Types.TypeCheck ds3
                        -> case ds3 of wild2 {
                             DEFAULT -> fail GHC.Prim.void#
                             Types.T_Func ds4
                             -> case ds2 of wild3 {
                                  [] -> fail GHC.Prim.void#
                                  : ds5 ds6
                                  -> case ds5 of wild4 {
                                       DEFAULT -> fail GHC.Prim.void#
                                       Types.TypeCheck ds7
                                       -> case ds7 of wild5 {
                                            DEFAULT -> fail GHC.Prim.void#
                                            Types.T_List t
                                            -> case ds6 of wild6 {
                                                 [] -> Ops._map_t1
                                                 : ipv ipv1 -> fail GHC.Prim.void# } } } } } } }) -}
809d5489cfcff84283133afeeec9d63b
  _map_t1 :: Types.Wrd
  {- HasNoCafRefs, Strictness: m18,
     Unfolding: (Types.TypeCheck Types.T_PreList) -}
5666b8c9336195b9a1a82d74f67442c0
  _map_t2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("seq: Illegal input type: "#) -}
d8e49cff69e9b5c75d696ab64d16d0ee
  _mul :: Types.Op
  {- Strictness: m1, Unfolding: (Types.BinOp Ops._mul0) -}
e21899957879cc860f3a9e01ebf09b14
  _mul0 :: Types.Wrd -> Types.Wrd -> Types.Wrd
  {- Arity: 2, Strictness: <S,U><L,U>,
     Unfolding: (\ (ds :: Types.Wrd) (ds1 :: Types.Wrd) ->
                 let {
                   fail :: GHC.Prim.Void# -> Types.Wrd
                     <join 1> {- Arity: 1, Strictness: <L,A> -}
                   = \ (ds2 :: GHC.Prim.Void#)[OneShot] ->
                     Types.Err
                       (GHC.CString.unpackAppendCString#
                          Ops._mul1
                          (GHC.Base.++
                             @ GHC.Types.Char
                             (Types.$fShowBind_$cshow ds)
                             (GHC.CString.unpackAppendCString#
                                Ops._add1
                                (Types.$fShowBind_$cshow ds1))))
                 } in
                 case ds of wild {
                   DEFAULT -> fail GHC.Prim.void#
                   Types.Double x
                   -> case ds1 of wild1 {
                        DEFAULT -> fail GHC.Prim.void#
                        Types.Double y -> Types.Double (GHC.Float.timesDouble x y)
                        Types.Int y
                        -> Types.Double
                             (case x of wild2 { GHC.Types.D# x1 ->
                              case y of wild3 { GHC.Types.I# i ->
                              GHC.Types.D# (GHC.Prim.*## x1 (GHC.Prim.int2Double# i)) } }) }
                   Types.Int x
                   -> case ds1 of wild1 {
                        DEFAULT -> fail GHC.Prim.void#
                        Types.Double y
                        -> Types.Double
                             (case x of wild2 { GHC.Types.I# i ->
                              case y of wild3 { GHC.Types.D# y1 ->
                              GHC.Types.D# (GHC.Prim.*## (GHC.Prim.int2Double# i) y1) } })
                        Types.Int y -> Types.Int (GHC.Num.$fNumInt_$c* x y) } }) -}
872dd2587431d4cda8474aedd8a39577
  _mul1 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("`*`: Illegal input value: x="#) -}
614690b69f01a2495582092fa635b55c
  _mul_t :: Types.Wrd -> Types.Wrd -> Types.Wrd
  {- Arity: 2, Strictness: <S,U><L,U>,
     Unfolding: (\ (ds :: Types.Wrd) (ds1 :: Types.Wrd) ->
                 let {
                   fail :: GHC.Prim.Void# -> Types.Wrd
                     <join 1> {- Arity: 1, Strictness: <L,A> -}
                   = \ (ds2 :: GHC.Prim.Void#)[OneShot] ->
                     Types.Err
                       (GHC.CString.unpackAppendCString#
                          Ops._mul_t1
                          (GHC.Base.++
                             @ GHC.Types.Char
                             (Types.$fShowBind_$cshow ds)
                             (GHC.CString.unpackAppendCString#
                                Ops._add_t6
                                (Types.$fShowBind_$cshow ds1))))
                 } in
                 case ds of wild {
                   DEFAULT -> fail GHC.Prim.void#
                   Types.TypeCheck ds2
                   -> case ds2 of wild1 {
                        DEFAULT -> fail GHC.Prim.void#
                        Types.T_Int
                        -> case ds1 of wild2 {
                             DEFAULT -> fail GHC.Prim.void#
                             Types.TypeCheck ds3
                             -> case ds3 of wild3 {
                                  DEFAULT -> fail GHC.Prim.void#
                                  Types.T_Int -> Ops._add_t5
                                  Types.T_Double -> Ops._add_t4 } }
                        Types.T_Double
                        -> case ds1 of wild2 {
                             DEFAULT -> fail GHC.Prim.void#
                             Types.TypeCheck ds3
                             -> case ds3 of wild3 {
                                  DEFAULT -> fail GHC.Prim.void#
                                  Types.T_Int -> Ops._add_t4
                                  Types.T_Double -> Ops._add_t4 } } } }) -}
3b28df4fd6f5288e63fc840b80fb328a
  _mul_t1 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("`*`: Illegal input type: t_x="#) -}
3cf3b7e7c739d0dfcbc36aab2e3f672e
  _neq :: Types.Op
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (Types.BinOp Ops._neq1) -}
4ecaf62b18e7940ad1197cb34dece61a
  _neq1 :: Types.Wrd -> Types.Wrd -> Types.Wrd
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U><L,1*U>m8,
     Unfolding: InlineRule (2, True, False)
                (\ (a :: Types.Wrd) (b :: Types.Wrd) ->
                 Types.Bool
                   (case Types.$fEqBind_$c==2 a b of wild {
                      GHC.Types.False -> GHC.Types.True
                      GHC.Types.True -> GHC.Types.False })) -}
c98c4cd1f91387bca8a8d3550a01ee78
  _neq_t :: Types.Wrd -> Types.Wrd -> Types.Wrd
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (ds :: Types.Wrd) (ds1 :: Types.Wrd) ->
                 case ds of wild {
                   DEFAULT -> Ops._neq_t2
                   Types.TypeCheck t1
                   -> case ds1 of wild1 {
                        DEFAULT -> Ops._neq_t2
                        Types.TypeCheck t2
                        -> case Types.$fEqBind_$c==1 t1 t2 of wild2 {
                             GHC.Types.False
                             -> Types.Err
                                  (GHC.CString.unpackAppendCString#
                                     Ops._neq_t1
                                     (GHC.Base.++
                                        @ GHC.Types.Char
                                        (Types.$fShowBind_$cshowsPrec1
                                           Types.$fShowBind2
                                           t1
                                           (GHC.Types.[] @ GHC.Types.Char))
                                        (GHC.CString.unpackAppendCString#
                                           Ops._and_t2
                                           (Types.$fShowBind_$cshowsPrec1
                                              Types.$fShowBind2
                                              t2
                                              (GHC.Types.[] @ GHC.Types.Char)))))
                             GHC.Types.True -> Ops._and_t1 } } }) -}
25f61afe81a6cef5b012c00fa422eab8
  _neq_t1 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("`!=`: Wrd mismatch of both sides: LHS="#) -}
4393e764452d50003c80348137b93eec
  _neq_t2 :: Types.Wrd
  {- Strictness: b -}
4994a3036ef01e113f203258eec61f08
  _not :: Types.Op
  {- Strictness: m2, Unfolding: (Types.UnOp Ops._not1) -}
e657d3d5cf9cde2daf82954b596aa71d
  _not1 :: Types.Wrd -> Types.Wrd
  {- Arity: 1, Strictness: <S,1*U>m8,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Types.Wrd) ->
                 case ds of wild {
                   DEFAULT -> Ops._not2
                   Types.Bool b
                   -> Types.Bool
                        (case b of wild1 {
                           GHC.Types.False -> GHC.Types.True
                           GHC.Types.True -> GHC.Types.False }) }) -}
3cc9f4fdfc36e872873e3edfb969dd36
  _not2 :: Types.Wrd
  {- Strictness: b -}
48c8f38dd8f63263b9d8f1a8a3c0ecb8
  _not_t :: Types.Wrd -> Types.Wrd
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: Types.Wrd) ->
                 case ds of wild {
                   DEFAULT -> Ops._not_t2
                   Types.TypeCheck ds1
                   -> case ds1 of wild1 {
                        DEFAULT
                        -> Types.Err
                             (GHC.CString.unpackAppendCString#
                                Ops._not_t1
                                (Types.$fShowBind_$cshowsPrec1
                                   Types.$fShowBind2
                                   wild1
                                   (GHC.Types.[] @ GHC.Types.Char)))
                        Types.T_Bool -> Ops._and_t1 } }) -}
fa61e4f175816c91155851d86c7dc9a6
  _not_t1 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("`!`: Illegal input type: "#) -}
684fd74ead68ea307d44c3cbee16ed93
  _not_t2 :: Types.Wrd
  {- Strictness: b -}
d86f2e063acb94ce4b44e62beb3cdd6e
  _opls :: [Types.StrOp]
  {- Strictness: m2,
     Unfolding: (GHC.Types.: @ Types.StrOp Ops._opls93 Ops._opls1) -}
780181d7f3c24e0f5778250d8310479f
  _opls1 :: [Types.StrOp]
  {- Strictness: m2,
     Unfolding: (GHC.Types.: @ Types.StrOp Ops._opls90 Ops._opls2) -}
e90f2ccb6e1b026aed67e54e56d3104f
  _opls10 :: [Types.StrOp]
  {- Strictness: m2,
     Unfolding: (GHC.Types.: @ Types.StrOp Ops._opls63 Ops._opls11) -}
a3545ceda17e0437e39e37f86899e66c
  _opls11 :: [Types.StrOp]
  {- Strictness: m2,
     Unfolding: (GHC.Types.: @ Types.StrOp Ops._opls60 Ops._opls12) -}
d4bb73ee00e055a417800a068fc36f61
  _opls12 :: [Types.StrOp]
  {- Strictness: m2,
     Unfolding: (GHC.Types.: @ Types.StrOp Ops._opls57 Ops._opls13) -}
009e6483cded296e2b6e85b7b9b1fa16
  _opls13 :: [Types.StrOp]
  {- Strictness: m2,
     Unfolding: (GHC.Types.: @ Types.StrOp Ops._opls54 Ops._opls14) -}
485335f7fcca375fff4dcb66123900f0
  _opls14 :: [Types.StrOp]
  {- Strictness: m2,
     Unfolding: (GHC.Types.: @ Types.StrOp Ops._opls51 Ops._opls15) -}
6dd21a4ad8c2db5195e5661a71327e9d
  _opls15 :: [Types.StrOp]
  {- Strictness: m2,
     Unfolding: (GHC.Types.: @ Types.StrOp Ops._opls48 Ops._opls16) -}
ea0a47cba071d62a2904352fa59d0f47
  _opls16 :: [Types.StrOp]
  {- Strictness: m2,
     Unfolding: (GHC.Types.: @ Types.StrOp Ops._opls45 Ops._opls17) -}
fb16ba160e09f9060050e2d102134a7a
  _opls17 :: [Types.StrOp]
  {- Strictness: m2,
     Unfolding: (GHC.Types.: @ Types.StrOp Ops._opls42 Ops._opls18) -}
a848abc9a8bbc61bc86ea5d88e1082b4
  _opls18 :: [Types.StrOp]
  {- Strictness: m2,
     Unfolding: (GHC.Types.: @ Types.StrOp Ops._opls39 Ops._opls19) -}
c7515c5a994435fac614e065f542af14
  _opls19 :: [Types.StrOp]
  {- Strictness: m2,
     Unfolding: (GHC.Types.: @ Types.StrOp Ops._opls36 Ops._opls20) -}
4decd8779d57fa54fd9715bfd06baa75
  _opls2 :: [Types.StrOp]
  {- Strictness: m2,
     Unfolding: (GHC.Types.: @ Types.StrOp Ops._opls87 Ops._opls3) -}
a2e746668756bd29e8da267276cc2c37
  _opls20 :: [Types.StrOp]
  {- Strictness: m2,
     Unfolding: (GHC.Types.: @ Types.StrOp Ops._opls33 Ops._opls21) -}
2ff07ac7e3bd5248081d1b49d0235a16
  _opls21 :: [Types.StrOp]
  {- Strictness: m2,
     Unfolding: (GHC.Types.: @ Types.StrOp Ops._opls30 Ops._opls22) -}
7aa956e0f916c2a21cbac6704dd5dd0e
  _opls22 :: [Types.StrOp]
  {- Strictness: m2,
     Unfolding: (GHC.Types.: @ Types.StrOp Ops._opls27 Ops._opls23) -}
2451ba16cbe6ac9127a36092c2f6248d
  _opls23 :: [Types.StrOp]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Types.StrOp
                   Ops._opls24
                   (GHC.Types.[] @ Types.StrOp)) -}
4848409e89209d0edae90da3e3a6072b
  _opls24 :: ([GHC.Types.Char], Types.Op)
  {- Strictness: m, Unfolding: ((Ops._opls25, Ops._snd)) -}
b88b8fc9929c1c4af4643d3dd5a72755
  _opls25 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Ops._opls26) -}
f6d6d1045b849e71c2400e298cafe159
  _opls26 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("snd"#) -}
00e88737378008e44ef85713621374b6
  _opls27 :: ([GHC.Types.Char], Types.Op)
  {- Strictness: m, Unfolding: ((Ops._opls28, Ops._fst)) -}
c730c3ad857427250719d9810b3868a0
  _opls28 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Ops._opls29) -}
9a39b858520e54a0ae3292d1cb887f3e
  _opls29 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("fst"#) -}
a4b0ee59bbc2a2539df6a8a695ecc592
  _opls3 :: [Types.StrOp]
  {- Strictness: m2,
     Unfolding: (GHC.Types.: @ Types.StrOp Ops._opls84 Ops._opls4) -}
95e7458d20cc85549fb2f658d3d68461
  _opls30 :: ([GHC.Types.Char], Types.Op)
  {- Strictness: m, Unfolding: ((Ops._opls31, Ops._map)) -}
d097d06a0173844d8f0ed5f15c16af21
  _opls31 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Ops._opls32) -}
20547c1bfb1f11a855800ad592b7d804
  _opls32 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("map"#) -}
d1348dde9ae41187ab37cb9f8eafcdfb
  _opls33 :: ([GHC.Types.Char], Types.Op)
  {- Strictness: m, Unfolding: ((Ops._opls34, Ops._seq)) -}
bef029383f7f054f5dc4d887c23b5308
  _opls34 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Ops._opls35) -}
d0cb0bbb153c2f40d84da7691ad78481
  _opls35 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("seq"#) -}
e63380f0fc0c2f37b2956ea26991f813
  _opls36 :: ([GHC.Types.Char], Types.Op)
  {- Strictness: m, Unfolding: ((Ops._opls37, Ops._take)) -}
bc484a1f13b4457563addcce392fef3a
  _opls37 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Ops._opls38) -}
b00287ca2ad9203459ff29407fe8f4ef
  _opls38 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("take"#) -}
b49f8af01622ff09956b50229cfe6255
  _opls39 :: ([GHC.Types.Char], Types.Op)
  {- Strictness: m, Unfolding: ((Ops._opls40, Ops._isEmpty)) -}
c61f4a12298ab295a4a305638aaefe12
  _opls4 :: [Types.StrOp]
  {- Strictness: m2,
     Unfolding: (GHC.Types.: @ Types.StrOp Ops._opls81 Ops._opls5) -}
6b9dd39b72e6bcba97227a8a571c1675
  _opls40 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Ops._opls41) -}
c362ddada30e4c38c2095049ccb5eded
  _opls41 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("isEmpty"#) -}
8d75f6f61daa0395ee043bfbb261409d
  _opls42 :: ([GHC.Types.Char], Types.Op)
  {- Strictness: m, Unfolding: ((Ops._opls43, Ops._pop)) -}
ab391930ad4b47703e2a372fc33cceeb
  _opls43 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Ops._opls44) -}
adf273349e2eb5c88a12c0f2ca68f6aa
  _opls44 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("pop"#) -}
a795c6a0152eb38714c1f4f4dad06eba
  _opls45 :: ([GHC.Types.Char], Types.Op)
  {- Strictness: m, Unfolding: ((Ops._opls46, Ops._tail)) -}
b46f996224ca64f162de47a2ee3d210b
  _opls46 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Ops._opls47) -}
604b80a69de52eb9631a126ea9bdcbf4
  _opls47 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("tail"#) -}
62f6aa5ba7f1b9cb1915395c4c7d9913
  _opls48 :: ([GHC.Types.Char], Types.Op)
  {- Strictness: m, Unfolding: ((Ops._opls49, Ops._head)) -}
e92fbe548db57e876b4052c9d7c43968
  _opls49 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Ops._opls50) -}
4fce0cd0baf093f439e8b2e594ab9a69
  _opls5 :: [Types.StrOp]
  {- Strictness: m2,
     Unfolding: (GHC.Types.: @ Types.StrOp Ops._opls78 Ops._opls6) -}
f6486a2b694ad4c9c9201bafdc96f49c
  _opls50 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("head"#) -}
0565b899648b6e6bae85fbb6900d580e
  _opls51 :: ([GHC.Types.Char], Types.Op)
  {- Strictness: m, Unfolding: ((Ops._opls52, Ops._succ)) -}
8d538b21620dc8d7ed9271ab6e25155d
  _opls52 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Ops._opls53) -}
55e5ab72180d5c460fdb3239248f9581
  _opls53 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("succ"#) -}
1f1fe1b410f8a67fdf98fd522abda9bc
  _opls54 :: ([GHC.Types.Char], Types.Op)
  {- Strictness: m, Unfolding: ((Ops._opls55, Ops._div)) -}
13f7afebc69a107591209c8572bfb7b3
  _opls55 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Ops._opls56) -}
1e449ce76a81b2bae75a4391fcbe782d
  _opls56 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("/"#) -}
dcc750b2da499828865eb7689d50156b
  _opls57 :: ([GHC.Types.Char], Types.Op)
  {- Strictness: m, Unfolding: ((Ops._opls58, Ops._mul)) -}
86762afb55361060c5c8ee07dc85dc54
  _opls58 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Ops._opls59) -}
830575ddf031d0e4175a79a4d5eb20ad
  _opls59 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("*"#) -}
8b37dfe8405392f485b994cc6fa53550
  _opls6 :: [Types.StrOp]
  {- Strictness: m2,
     Unfolding: (GHC.Types.: @ Types.StrOp Ops._opls75 Ops._opls7) -}
9f36566bd2a3ee80f4656e1ce4e3d5d4
  _opls60 :: ([GHC.Types.Char], Types.Op)
  {- Strictness: m, Unfolding: ((Ops._opls61, Ops._sub)) -}
f26e8fc64340a22e9383ef37347e3a49
  _opls61 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Ops._opls62) -}
6d4847201cfca8adde0a2afe221f6481
  _opls62 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("-"#) -}
3e00ad05831a38bcc72481a335d3250d
  _opls63 :: ([GHC.Types.Char], Types.Op)
  {- Strictness: m, Unfolding: ((Ops._opls64, Ops._add)) -}
ee8849ac7f8733f33453bc48b964ce55
  _opls64 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Ops._opls65) -}
7f465072c7f91da8ce161791cb4eb660
  _opls65 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("+"#) -}
827cf11d437987e80e81674539a12506
  _opls66 :: ([GHC.Types.Char], Types.Op)
  {- Strictness: m, Unfolding: ((Ops._opls67, Ops._leq)) -}
9a5f6895167821d505a7235542ec98b9
  _opls67 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Ops._opls68) -}
b28c0efc2a392a70f53855a5279ec78c
  _opls68 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("<="#) -}
1e72e0846308521d465049c1f5015914
  _opls69 :: ([GHC.Types.Char], Types.Op)
  {- Strictness: m, Unfolding: ((Ops._opls70, Ops._lt)) -}
eeef0c02977de545e5f570d745189ed9
  _opls7 :: [Types.StrOp]
  {- Strictness: m2,
     Unfolding: (GHC.Types.: @ Types.StrOp Ops._opls72 Ops._opls8) -}
d2e9a3240c2f589c49d7826f3a901c4d
  _opls70 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Ops._opls71) -}
117cfd264e23e52794383ec6e0ca1191
  _opls71 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("<"#) -}
3727bc4a8bd1180578b58c882db56c6f
  _opls72 :: ([GHC.Types.Char], Types.Op)
  {- Strictness: m, Unfolding: ((Ops._opls73, Ops._geq)) -}
6509007735eeab324393305a2001de50
  _opls73 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Ops._opls74) -}
3cdadd35db43e0afb722099783af8686
  _opls74 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: (">="#) -}
84440c9981a0fbb0f1f222b9497c6b55
  _opls75 :: ([GHC.Types.Char], Types.Op)
  {- Strictness: m, Unfolding: ((Ops._opls76, Ops._gt)) -}
7274999d9f5eb12b72540e0e5ed864fe
  _opls76 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Ops._opls77) -}
0a32d4011c6818f0a574c8eec8671995
  _opls77 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: (">"#) -}
02231fb387db08471d8826dcad83cc22
  _opls78 :: ([GHC.Types.Char], Types.Op)
  {- Strictness: m, Unfolding: ((Ops._opls79, Ops._neq)) -}
673e2fb7a637aff44195c0b9f16b97ea
  _opls79 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Ops._opls80) -}
4527d5e45413342689182258a50d4c67
  _opls8 :: [Types.StrOp]
  {- Strictness: m2,
     Unfolding: (GHC.Types.: @ Types.StrOp Ops._opls69 Ops._opls9) -}
a97b446e5af557ebc9b461585fc38a03
  _opls80 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("!="#) -}
7a3b3961694eebf292b5769393f44828
  _opls81 :: ([GHC.Types.Char], Types.Op)
  {- Strictness: m, Unfolding: ((Ops._opls82, Ops._eq)) -}
e87650bf00bc7522fbe9a8f17e2dd889
  _opls82 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Ops._opls83) -}
c0ea8113dd5b68bac078f3c6dd253382
  _opls83 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("=="#) -}
aac75561b288e90abed0dc597f1e4a92
  _opls84 :: ([GHC.Types.Char], Types.Op)
  {- Strictness: m, Unfolding: ((Ops._opls85, Ops._not)) -}
1f95dd299eed2d69f11491f6af520b56
  _opls85 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Ops._opls86) -}
eef00eeaee9e7fdbc323d2e4a8f6dce3
  _opls86 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("!"#) -}
2607724c8835890bbcb8e99879494152
  _opls87 :: ([GHC.Types.Char], Types.Op)
  {- Strictness: m, Unfolding: ((Ops._opls88, Ops._and)) -}
3e64020a7ff41fcbc87f39fbeddb2763
  _opls88 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Ops._opls89) -}
d36ef3c7d62a80d628ddd8f05d8465e5
  _opls89 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("&&"#) -}
8f004a3d4e77cbeccbd47c1a866dde36
  _opls9 :: [Types.StrOp]
  {- Strictness: m2,
     Unfolding: (GHC.Types.: @ Types.StrOp Ops._opls66 Ops._opls10) -}
3384440fd9e9184007d115c458bedf81
  _opls90 :: ([GHC.Types.Char], Types.Op)
  {- Strictness: m, Unfolding: ((Ops._opls91, Ops._or)) -}
6dfc362a54503c3d25dbab516cf70894
  _opls91 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Ops._opls92) -}
a94a348462aba4bb2b94ceb983f7215e
  _opls92 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("||"#) -}
d08933d124cbfcbe557f39bb47e2d5d3
  _opls93 :: ([GHC.Types.Char], Types.Op)
  {- Strictness: m, Unfolding: ((Ops._opls94, Ops._print)) -}
62c08972a06d5331db7e28e4470e08fe
  _opls94 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Ops._opls95) -}
0ff339576c251c9fb6e4e5f764ab22c2
  _opls95 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("print"#) -}
6bf4d5616317ad4dbb246754cab7efc9
  _opls_dec :: [Types.StrOp]
  {- Unfolding: (GHC.List.reverse1
                   @ Types.StrOp
                   Ops._opls
                   (GHC.Types.[] @ Types.StrOp)) -}
0d1a3b757b8d222c41f3218f99f20738
  _or :: Types.Op
  {- Strictness: m1, Unfolding: (Types.BinOp Ops._or1) -}
c1e249ed21ccd94709c65047d13cc58a
  _or1 :: Types.Wrd -> Types.Wrd -> Types.Wrd
  {- Arity: 2, Strictness: <S,1*U><S,1*U>m8, Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Types.Wrd) (w1 :: Types.Wrd) ->
                 case w of wild {
                   DEFAULT
                   -> Control.Exception.Base.patError
                        @ 'GHC.Types.LiftedRep
                        @ Types.Wrd
                        Ops._or2
                   Types.Bool a
                   -> case w1 of wild1 {
                        DEFAULT
                        -> Control.Exception.Base.patError
                             @ 'GHC.Types.LiftedRep
                             @ Types.Wrd
                             Ops._or2
                        Types.Bool b
                        -> Types.Bool
                             (case a of wild2 {
                                GHC.Types.False -> b GHC.Types.True -> GHC.Types.True }) } }) -}
19c8cec9d0f561af4b45d78201f1463b
  _or2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("src/Ops.hs:253:14-50|lambda"#) -}
6908699d8e0ea5bc40f18fbf9a0c7a00
  _or_t :: Types.Wrd -> Types.Wrd -> Types.Wrd
  {- Arity: 2, Strictness: <S,1*U><S,U>,
     Unfolding: (\ (ds :: Types.Wrd) (ds1 :: Types.Wrd) ->
                 case ds of wild {
                   DEFAULT -> Ops._or_t2
                   Types.TypeCheck ds2
                   -> let {
                        fail :: GHC.Prim.Void# -> Types.Wrd
                          <join 1> {- Arity: 1, Strictness: <L,A> -}
                        = \ (ds3 :: GHC.Prim.Void#)[OneShot] ->
                          case ds1 of wild1 {
                            DEFAULT -> Ops._or_t2
                            Types.TypeCheck t2
                            -> Types.Err
                                 (GHC.CString.unpackAppendCString#
                                    Ops._or_t1
                                    (GHC.Base.++
                                       @ GHC.Types.Char
                                       (Types.$fShowBind_$cshowsPrec1
                                          Types.$fShowBind2
                                          ds2
                                          (GHC.Types.[] @ GHC.Types.Char))
                                       (GHC.CString.unpackAppendCString#
                                          Ops._and_t2
                                          (Types.$fShowBind_$cshowsPrec1
                                             Types.$fShowBind2
                                             t2
                                             (GHC.Types.[] @ GHC.Types.Char))))) }
                      } in
                      case ds2 of wild1 {
                        DEFAULT -> fail GHC.Prim.void#
                        Types.T_Bool
                        -> case ds1 of wild2 {
                             DEFAULT -> fail GHC.Prim.void#
                             Types.TypeCheck ds3
                             -> case ds3 of wild3 {
                                  DEFAULT -> fail GHC.Prim.void#
                                  Types.T_Bool -> Ops._and_t1 } } } }) -}
856996f8fdef8285cf1f5129fafbb4ef
  _or_t1 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("`||`: Illegal input type: LHS="#) -}
129fd2cfb6aed391ef726af5b5f29609
  _or_t2 :: Types.Wrd
  {- Strictness: b -}
f74146b6986d2f24e32af08a17a0cb8d
  _pop :: Types.Op
  {- Strictness: m2, Unfolding: (Types.UnOp Ops._pop0) -}
78ff3de2a955828d3810b9b234c734f1
  _pop0 :: Types.Wrd -> Types.Wrd
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Types.Wrd) ->
                 case ds of wild {
                   DEFAULT -> Ops._pop4
                   Types.List ds1
                   -> case ds1 of wild1 {
                        [] -> Ops._pop1
                        : x xs
                        -> Types.Tuple
                             (GHC.Types.:
                                @ Types.Wrd
                                x
                                (GHC.Types.:
                                   @ Types.Wrd
                                   (Types.List xs)
                                   (GHC.Types.[] @ Types.Wrd))) } }) -}
096143cf2e129c195e2e7fdbbf75dc42
  _pop1 :: Types.Wrd
  {- Strictness: m12, Unfolding: (Types.Err Ops._pop2) -}
67820d80a490bcd1292746a61771d56a
  _pop2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Ops._pop3) -}
2b468eb485d5183768e6da337648fc34
  _pop3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("pop: Empty list."#) -}
feea901cd6060803d1ef40ae2bfdebba
  _pop4 :: Types.Wrd
  {- Strictness: b -}
8eb46b827bbdd9d4d6a5619009eb6e67
  _pop_t :: Types.Wrd -> Types.Wrd
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: Types.Wrd) ->
                 case ds of wild {
                   DEFAULT -> Ops._pop_t2
                   Types.TypeCheck ds1
                   -> case ds1 of wild1 {
                        DEFAULT
                        -> Types.Err
                             (GHC.CString.unpackAppendCString#
                                Ops._pop_t1
                                (Types.$fShowBind_$cshowsPrec1
                                   Types.$fShowBind2
                                   wild1
                                   (GHC.Types.[] @ GHC.Types.Char)))
                        Types.T_List t
                        -> Types.TypeCheck
                             (Types.T_Tuple
                                (GHC.Types.:
                                   @ Types.Type
                                   t
                                   (GHC.Types.:
                                      @ Types.Type
                                      wild1
                                      (GHC.Types.[] @ Types.Type)))) } }) -}
4ee8181b34bb8af5a603e9b7cd5b63eb
  _pop_t1 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("pop: Illegal input type: "#) -}
d2ed9ea0c6ce9ecb8a02e125ba74a112
  _pop_t2 :: Types.Wrd
  {- Strictness: b -}
59896829b5aa2764f6347abfd56a7914
  _print :: Types.Op
  {- Strictness: m2, Unfolding: (Types.UnOp Ops._print0) -}
a7d8db166e8264be3035052bbc8b2396
  _print0 :: Types.Wrd -> Types.Wrd
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Types.Wrd) ->
                 case ds of wild {
                   DEFAULT -> Types.Print (Types.$fShowBind_$cshow wild)
                   Types.Err e -> Types.Err e }) -}
9bbf503ce6725b8b5d15b8b3769b4b27
  _print_t :: Types.Wrd -> Types.Wrd
  {- Arity: 1, Strictness: <S,1*U>m18,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Types.Wrd) ->
                 case ds of wild {
                   DEFAULT -> Ops._print_t3
                   Types.TypeCheck ds1
                   -> case ds1 of wild1 {
                        DEFAULT -> Ops._print_t2 Types.T_Error -> Ops._print_t1 } }) -}
821397a45bfc366d2f10e609e96c28ae
  _print_t1 :: Types.Wrd
  {- HasNoCafRefs, Strictness: m18,
     Unfolding: (Types.TypeCheck Types.T_Error) -}
f2cd44c874b6894090af7b249afc2caa
  _print_t2 :: Types.Wrd
  {- HasNoCafRefs, Strictness: m18,
     Unfolding: (Types.TypeCheck Types.T_Print) -}
be7342a422bb36ddcde8217442e86e14
  _print_t3 :: Types.Wrd
  {- Strictness: b -}
97867468b3c1a38235eac960f554ccb4
  _seq :: Types.Op
  {- Strictness: m3, Unfolding: (Types.FuncOp Ops._seq1) -}
d5323da05aad0e9c645aaf003eed97b7
  _seq0 :: Types.Exp -> Types.Wrd
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ (ds :: [Types.Wrd]) ->
                 let {
                   fail :: GHC.Prim.Void# -> Types.Wrd
                     <join 1> {- Arity: 1, Strictness: <L,A> -}
                   = \ (ds1 :: GHC.Prim.Void#)[OneShot] ->
                     Types.Err
                       (GHC.CString.unpackAppendCString#
                          Ops._seq2
                          (case ds of wild {
                             [] -> Ops.toList1
                             : x xs
                             -> GHC.Types.:
                                  @ GHC.Types.Char
                                  GHC.Show.showList__3
                                  (GHC.Base.++
                                     @ GHC.Types.Char
                                     (Types.$fShowBind_$cshow x)
                                     (case Ops.$wshowl xs of ww { (#,#) ww1 ww2 ->
                                      GHC.Types.: @ GHC.Types.Char ww1 ww2 })) }))
                 } in
                 case ds of wild {
                   [] -> fail GHC.Prim.void#
                   : ds1 ds2
                   -> case ds1 of wild1 {
                        DEFAULT -> fail GHC.Prim.void#
                        Types.Int n
                        -> case ds2 of wild2 {
                             [] -> fail GHC.Prim.void#
                             : ds3 ds4
                             -> case ds3 of wild3 {
                                  DEFAULT -> fail GHC.Prim.void#
                                  Types.Int m
                                  -> case ds4 of wild4 {
                                       []
                                       -> Types.List
                                            (case n of wild5 { GHC.Types.I# x ->
                                             case m of wild6 { GHC.Types.I# y ->
                                             case GHC.Prim.># x y of lwild {
                                               DEFAULT
                                               -> letrec {
                                                    go :: GHC.Prim.Int# -> [Types.Wrd]
                                                      {- Arity: 1, Strictness: <L,U> -}
                                                    = \ (x1 :: GHC.Prim.Int#) ->
                                                      GHC.Types.:
                                                        @ Types.Wrd
                                                        (Types.Int (GHC.Types.I# x1))
                                                        (case GHC.Prim.==# x1 y of lwild1 {
                                                           DEFAULT -> go (GHC.Prim.+# x1 1#)
                                                           1# -> GHC.Types.[] @ Types.Wrd })
                                                  } in
                                                  go x
                                               1# -> GHC.Types.[] @ Types.Wrd } } })
                                       : ipv ipv1 -> fail GHC.Prim.void# } } } } }) -}
2c79ecf7867be6e9b0fcd45f73e491ee
  _seq1 :: (GHC.Types.Int, Types.Exp -> Types.Wrd)
  {- Strictness: m, Unfolding: ((Ops._map3, Ops._seq0)) -}
459f705f54d958ea106e5d280b7fdd22
  _seq2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("seq: Illegal input value: "#) -}
6b94901691271cf0d6292fcab4489b1f
  _seq_t :: Types.Exp -> Types.Wrd
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ (ds :: [Types.Wrd]) ->
                 let {
                   fail :: GHC.Prim.Void# -> Types.Wrd
                     <join 1> {- Arity: 1, Strictness: <L,A> -}
                   = \ (ds1 :: GHC.Prim.Void#)[OneShot] ->
                     Types.Err
                       (GHC.CString.unpackAppendCString#
                          Ops._map_t2
                          (case ds of wild {
                             [] -> Ops.toList1
                             : x xs
                             -> GHC.Types.:
                                  @ GHC.Types.Char
                                  GHC.Show.showList__3
                                  (GHC.Base.++
                                     @ GHC.Types.Char
                                     (Types.$fShowBind_$cshow x)
                                     (case Ops.$wshowl xs of ww { (#,#) ww1 ww2 ->
                                      GHC.Types.: @ GHC.Types.Char ww1 ww2 })) }))
                 } in
                 case ds of wild {
                   [] -> fail GHC.Prim.void#
                   : ds1 ds2
                   -> case ds1 of wild1 {
                        DEFAULT -> fail GHC.Prim.void#
                        Types.TypeCheck ds3
                        -> case ds3 of wild2 {
                             DEFAULT -> fail GHC.Prim.void#
                             Types.T_Int
                             -> case ds2 of wild3 {
                                  [] -> fail GHC.Prim.void#
                                  : ds4 ds5
                                  -> case ds4 of wild4 {
                                       DEFAULT -> fail GHC.Prim.void#
                                       Types.TypeCheck ds6
                                       -> case ds6 of wild5 {
                                            DEFAULT -> fail GHC.Prim.void#
                                            Types.T_Int
                                            -> case ds5 of wild6 {
                                                 [] -> Ops._seq_t1
                                                 : ipv ipv1 -> fail GHC.Prim.void# } } } } } } }) -}
328691fd0abf14ea1fb62a663314fe0f
  _seq_t1 :: Types.Wrd
  {- HasNoCafRefs, Strictness: m18,
     Unfolding: (Types.TypeCheck Ops._seq_t2) -}
6150290243070a8d0425633c79a1420a
  _seq_t2 :: Types.Type
  {- HasNoCafRefs, Strictness: m10,
     Unfolding: (Types.T_List Types.T_Int) -}
40cb72d194751c81486f0a39e15f16e5
  _snd :: Types.Op
  {- Strictness: m2, Unfolding: (Types.UnOp Ops._snd1) -}
ab7f655f11aa009428f4a39228b1c987
  _snd1 :: Types.Wrd -> Types.Wrd
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: Types.Wrd) ->
                 case ds of wild {
                   DEFAULT -> Ops._snd2
                   Types.Tuple ds1
                   -> case ds1 of wild1 {
                        [] -> Ops._snd2
                        : ds2 ds3
                        -> case ds3 of wild2 { [] -> Ops._snd2 : w2 ds4 -> w2 } } }) -}
f97f638e46ae457d8336a1a206b050ad
  _snd2 :: Types.Wrd
  {- Strictness: b -}
34a45d9c0f3f01b88317fec937d37019
  _snd_t :: Types.Wrd -> Types.Wrd
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: Types.Wrd) ->
                 case ds of wild {
                   DEFAULT
                   -> Types.Err
                        (GHC.CString.unpackAppendCString#
                           Ops._snd_t1
                           (Types.$fShowBind_$cshow wild))
                   Types.TypeCheck ds1
                   -> case ds1 of wild1 {
                        DEFAULT
                        -> Types.Err
                             (GHC.CString.unpackAppendCString#
                                Ops._snd_t1
                                (Types.$fShowBind_$cshow wild))
                        Types.T_Tuple ds2
                        -> case ds2 of wild2 {
                             []
                             -> Types.Err
                                  (GHC.CString.unpackAppendCString#
                                     Ops._snd_t1
                                     (Types.$fShowBind_$cshow wild))
                             : ds3 ds4
                             -> case ds4 of wild3 {
                                  []
                                  -> Types.Err
                                       (GHC.CString.unpackAppendCString#
                                          Ops._snd_t1
                                          (Types.$fShowBind_$cshow wild))
                                  : t ds5 -> Types.TypeCheck t } } } }) -}
fb5fb730789a7a098c792d2650fc4236
  _snd_t1 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("snd: Illegal input type: "#) -}
85224df9a24cbe900299f817409be17f
  _sub :: Types.Op
  {- Strictness: m1, Unfolding: (Types.BinOp Ops._sub0) -}
982b08c7e8e6bf17acda7d615bcd62d1
  _sub0 :: Types.Wrd -> Types.Wrd -> Types.Wrd
  {- Arity: 2, Strictness: <S,U><L,U>,
     Unfolding: (\ (ds :: Types.Wrd) (ds1 :: Types.Wrd) ->
                 let {
                   fail :: GHC.Prim.Void# -> Types.Wrd
                     <join 1> {- Arity: 1, Strictness: <L,A> -}
                   = \ (ds2 :: GHC.Prim.Void#)[OneShot] ->
                     Types.Err
                       (GHC.CString.unpackAppendCString#
                          Ops._sub1
                          (GHC.Base.++
                             @ GHC.Types.Char
                             (Types.$fShowBind_$cshow ds)
                             (GHC.CString.unpackAppendCString#
                                Ops._add1
                                (Types.$fShowBind_$cshow ds1))))
                 } in
                 case ds of wild {
                   DEFAULT -> fail GHC.Prim.void#
                   Types.Double x
                   -> case ds1 of wild1 {
                        DEFAULT -> fail GHC.Prim.void#
                        Types.Double y -> Types.Double (GHC.Float.minusDouble x y)
                        Types.Int y
                        -> Types.Double
                             (case x of wild2 { GHC.Types.D# x1 ->
                              case y of wild3 { GHC.Types.I# i ->
                              GHC.Types.D# (GHC.Prim.-## x1 (GHC.Prim.int2Double# i)) } }) }
                   Types.Int x
                   -> case ds1 of wild1 {
                        DEFAULT -> fail GHC.Prim.void#
                        Types.Double y
                        -> Types.Double
                             (case x of wild2 { GHC.Types.I# i ->
                              case y of wild3 { GHC.Types.D# y1 ->
                              GHC.Types.D# (GHC.Prim.-## (GHC.Prim.int2Double# i) y1) } })
                        Types.Int y -> Types.Int (GHC.Num.$fNumInt_$c- x y) } }) -}
35c261a5b9aaa69c8ef7ad1d509bd398
  _sub1 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("`-`: Illegal input value: x="#) -}
7647ab27e39e51539d6212c2f8f8309b
  _sub_t :: Types.Wrd -> Types.Wrd -> Types.Wrd
  {- Arity: 2, Strictness: <S,U><L,U>,
     Unfolding: (\ (ds :: Types.Wrd) (ds1 :: Types.Wrd) ->
                 let {
                   fail :: GHC.Prim.Void# -> Types.Wrd
                     <join 1> {- Arity: 1, Strictness: <L,A> -}
                   = \ (ds2 :: GHC.Prim.Void#)[OneShot] ->
                     Types.Err
                       (GHC.CString.unpackAppendCString#
                          Ops._sub_t1
                          (GHC.Base.++
                             @ GHC.Types.Char
                             (Types.$fShowBind_$cshow ds)
                             (GHC.CString.unpackAppendCString#
                                Ops._add_t6
                                (Types.$fShowBind_$cshow ds1))))
                 } in
                 case ds of wild {
                   DEFAULT -> fail GHC.Prim.void#
                   Types.TypeCheck ds2
                   -> case ds2 of wild1 {
                        DEFAULT -> fail GHC.Prim.void#
                        Types.T_Int
                        -> case ds1 of wild2 {
                             DEFAULT -> fail GHC.Prim.void#
                             Types.TypeCheck ds3
                             -> case ds3 of wild3 {
                                  DEFAULT -> fail GHC.Prim.void#
                                  Types.T_Int -> Ops._add_t5
                                  Types.T_Double -> Ops._add_t4 } }
                        Types.T_Double
                        -> case ds1 of wild2 {
                             DEFAULT -> fail GHC.Prim.void#
                             Types.TypeCheck ds3
                             -> case ds3 of wild3 {
                                  DEFAULT -> fail GHC.Prim.void#
                                  Types.T_Int -> Ops._add_t4
                                  Types.T_Double -> Ops._add_t4 } } } }) -}
a1f446f17c4d6891251efc4b2fb25dcf
  _sub_t1 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("`-`: Illegal input type: t_x="#) -}
8c7019d6bdc7048340b496fb392e0895
  _succ :: Types.Op
  {- Strictness: m2, Unfolding: (Types.UnOp Ops._succ0) -}
263b03d0bc9e513cdff4e949b54ca757
  _succ0 :: Types.Wrd -> Types.Wrd
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: Types.Wrd) ->
                 case ds of wild {
                   DEFAULT
                   -> Types.Err
                        (GHC.CString.unpackAppendCString#
                           Ops._succ1
                           (Types.$fShowBind_$cshow wild))
                   Types.Double x
                   -> Types.Double
                        (case x of wild1 { GHC.Types.D# x1 ->
                         GHC.Types.D# (GHC.Prim.+## x1 1.0##) })
                   Types.Int x
                   -> Types.Int
                        (case x of wild1 { GHC.Types.I# x1 ->
                         GHC.Types.I# (GHC.Prim.+# x1 1#) }) }) -}
1e1bec2b7d8324d8c8a13fc675c5884a
  _succ1 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("succ: Illegal input value: "#) -}
3772e42a53fcd1b02a264fd1229bde06
  _succ_t :: Types.Wrd -> Types.Wrd
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: Types.Wrd) ->
                 case ds of wild {
                   DEFAULT
                   -> Types.Err
                        (GHC.CString.unpackAppendCString#
                           Ops._succ_t1
                           (Types.$fShowBind_$cshow wild))
                   Types.TypeCheck ds1
                   -> case ds1 of wild1 {
                        DEFAULT
                        -> Types.Err
                             (GHC.CString.unpackAppendCString#
                                Ops._succ_t1
                                (Types.$fShowBind_$cshow wild))
                        Types.T_Int -> Ops._add_t5
                        Types.T_Double -> Ops._add_t4 } }) -}
6b00d16e376d0e6f0254d253382e9977
  _succ_t1 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("succ: Illegal input type: "#) -}
8feadc8c7a9e1d33d049597a1f41b9b2
  _tail :: Types.Op
  {- Strictness: m2, Unfolding: (Types.UnOp Ops._tail0) -}
39c6a8190ccefad69165a6608bb1aca6
  _tail0 :: Types.Wrd -> Types.Wrd
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Types.Wrd) ->
                 case ds of wild {
                   DEFAULT -> Ops._tail4
                   Types.List ds1
                   -> case ds1 of wild1 {
                        [] -> Ops._tail1 : ds2 xs -> Types.List xs } }) -}
4682bc10d98e3a8ea22743c7c8f166c3
  _tail1 :: Types.Wrd
  {- Strictness: m12, Unfolding: (Types.Err Ops._tail2) -}
5b6bde3d420f44567d3b89d1b48068a7
  _tail2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Ops._tail3) -}
7707e6923ff15a353d267fc53e690104
  _tail3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("tail: Empty list."#) -}
a7358c2ca66cb45992b3647f134d697d
  _tail4 :: Types.Wrd
  {- Strictness: b -}
2782328a1be6f268329020823fc8a814
  _tail_t :: Types.Wrd -> Types.Wrd
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: Types.Wrd) ->
                 case ds of wild {
                   DEFAULT -> Ops._tail_t2
                   Types.TypeCheck ds1
                   -> case ds1 of wild1 {
                        DEFAULT
                        -> Types.Err
                             (GHC.CString.unpackAppendCString#
                                Ops._tail_t1
                                (Types.$fShowBind_$cshowsPrec1
                                   Types.$fShowBind2
                                   wild1
                                   (GHC.Types.[] @ GHC.Types.Char)))
                        Types.T_List t -> wild } }) -}
b57e45550d23ed2e01b4e297d7c50947
  _tail_t1 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("tail: Illegal input type: "#) -}
497873be8490efbee1a3738ca937abec
  _tail_t2 :: Types.Wrd
  {- Strictness: b -}
5e0def83df74d395e68ba2dbb4e0b119
  _take :: Types.Op
  {- Strictness: m3, Unfolding: (Types.FuncOp Ops._take1) -}
22a1d8a1498b2747bd38758b48a89e06
  _take0 :: Types.Exp -> Types.Wrd
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ (ds :: [Types.Wrd]) ->
                 let {
                   fail :: GHC.Prim.Void# -> Types.Wrd
                     <join 1> {- Arity: 1, Strictness: <L,A> -}
                   = \ (ds1 :: GHC.Prim.Void#)[OneShot] ->
                     Types.Err
                       (GHC.CString.unpackAppendCString#
                          Ops._take2
                          (case ds of wild {
                             [] -> Ops.toList1
                             : x xs
                             -> GHC.Types.:
                                  @ GHC.Types.Char
                                  GHC.Show.showList__3
                                  (GHC.Base.++
                                     @ GHC.Types.Char
                                     (Types.$fShowBind_$cshow x)
                                     (case Ops.$wshowl xs of ww { (#,#) ww1 ww2 ->
                                      GHC.Types.: @ GHC.Types.Char ww1 ww2 })) }))
                 } in
                 case ds of wild {
                   [] -> fail GHC.Prim.void#
                   : ds1 ds2
                   -> case ds1 of wild1 {
                        DEFAULT -> fail GHC.Prim.void#
                        Types.Int n
                        -> case ds2 of wild2 {
                             [] -> fail GHC.Prim.void#
                             : ds3 ds4
                             -> case ds3 of wild3 {
                                  DEFAULT -> fail GHC.Prim.void#
                                  Types.List ls
                                  -> case ds4 of wild4 {
                                       []
                                       -> Types.List
                                            (case n of wild5 { GHC.Types.I# y ->
                                             case GHC.Prim.<# 0# y of lwild {
                                               DEFAULT -> GHC.Types.[] @ Types.Wrd
                                               1# -> GHC.List.$wunsafeTake @ Types.Wrd y ls } })
                                       : ipv ipv1 -> fail GHC.Prim.void# } } } } }) -}
8db8a13df3688cb3b60e9c6944ec8849
  _take1 :: (GHC.Types.Int, Types.Exp -> Types.Wrd)
  {- Strictness: m, Unfolding: ((Ops._map3, Ops._take0)) -}
dc225380dbafec91e9b60dbf1b066df7
  _take2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("take: Illegal input value: "#) -}
4a1a4b1a09252f5ad3f4f9f2faeb3078
  _take_t :: Types.Exp -> Types.Wrd
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ (ds :: [Types.Wrd]) ->
                 let {
                   fail :: GHC.Prim.Void# -> Types.Wrd
                     <join 1> {- Arity: 1, Strictness: <L,A> -}
                   = \ (ds1 :: GHC.Prim.Void#)[OneShot] ->
                     Types.Err
                       (GHC.CString.unpackAppendCString#
                          Ops._take_t1
                          (case ds of wild {
                             [] -> Ops.toList1
                             : x xs
                             -> GHC.Types.:
                                  @ GHC.Types.Char
                                  GHC.Show.showList__3
                                  (GHC.Base.++
                                     @ GHC.Types.Char
                                     (Types.$fShowBind_$cshow x)
                                     (case Ops.$wshowl xs of ww { (#,#) ww1 ww2 ->
                                      GHC.Types.: @ GHC.Types.Char ww1 ww2 })) }))
                 } in
                 case ds of wild {
                   [] -> fail GHC.Prim.void#
                   : ds1 ds2
                   -> case ds1 of wild1 {
                        DEFAULT -> fail GHC.Prim.void#
                        Types.TypeCheck ds3
                        -> case ds3 of wild2 {
                             DEFAULT -> fail GHC.Prim.void#
                             Types.T_Int
                             -> case ds2 of wild3 {
                                  [] -> fail GHC.Prim.void#
                                  : ds4 ds5
                                  -> case ds4 of wild4 {
                                       DEFAULT -> fail GHC.Prim.void#
                                       Types.TypeCheck ds6
                                       -> case ds6 of wild5 {
                                            DEFAULT -> fail GHC.Prim.void#
                                            Types.T_List t
                                            -> case ds5 of wild6 {
                                                 [] -> wild4
                                                 : ipv ipv1 -> fail GHC.Prim.void# } } } } } } }) -}
9412bd3a2c7ab6d7e81729cb7bf9fb84
  _take_t1 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("take: Illegal input type: "#) -}
8d7df2a6b5d3b9bca57a9d4a834dd5f9
  _typeFunction :: GHC.Base.String -> Types.Op
  {- Arity: 1, Strictness: <S,U> -}
f53f4449bef266b3d07ce3afe393d69f
  isConsistentType :: Types.Exp -> GHC.Types.Bool
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (expr :: Types.Exp) ->
                 case Ops._isConsistentType expr of wild {
                   GHC.Maybe.Nothing -> GHC.Types.False
                   GHC.Maybe.Just a1 -> GHC.Types.True }) -}
3387bddbaface069531d5485507a58dc
  toList :: Types.Exp -> Types.Wrd
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ (expr :: Types.Exp) ->
                 case Ops._isConsistentType expr of wild {
                   GHC.Maybe.Nothing
                   -> Types.Err
                        (GHC.CString.unpackAppendCString#
                           Ops.toList2
                           (case expr of wild1 {
                              [] -> Ops.toList1
                              : x xs
                              -> GHC.Types.:
                                   @ GHC.Types.Char
                                   GHC.Show.showList__3
                                   (GHC.Base.++
                                      @ GHC.Types.Char
                                      (Types.$fShowBind_$cshow x)
                                      (case Ops.$wshowl xs of ww { (#,#) ww1 ww2 ->
                                       GHC.Types.: @ GHC.Types.Char ww1 ww2 })) }))
                   GHC.Maybe.Just a1 -> Types.List expr }) -}
1577133c85b45b42e3461d9132adfe1e
  toList1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackAppendCString#
                   GHC.Show.showList__4
                   (GHC.Types.[] @ GHC.Types.Char)) -}
68cdf96fce1d1672afe67fde5d863d2f
  toList2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("List: Inconsistent type: "#) -}
trusted: none
require own pkg trusted: False
module header:
  Nothing
declaration docs:
arg docs:


==================== FINAL INTERFACE ====================
2021-04-08 12:27:35.4464823 UTC

interface Topos-0.1.0.0-L2hSunVxFDyol1qAzNo2F:Ops 8104
  interface hash: ea8c7895a3d1a7a01fa1777bc2c23497
  ABI hash: d150b60c27dc32f3b81e8e6b8ed7e7e9
  export-list hash: 24531ef125d46d1c52ba79243a43b497
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 358a18e1043fc7ac1b015a88503b1325
  opt_hash: cb09a535710eb16767a299f2ded44a31
  hpc_hash: 93b885adfe0da089cdf634904fd59f71
  plugin_hash: ad164012d6b1e14942349d58b1132007
  sig of: Nothing
  used TH splices: False
  where
exports:
  Ops._add
  Ops._add0
  Ops._add_t
  Ops._and
  Ops._and_t
  Ops._div
  Ops._div0
  Ops._div_t
  Ops._eq
  Ops._eq_t
  Ops._fst
  Ops._fst_t
  Ops._geq
  Ops._geq0
  Ops._geq_t
  Ops._getType
  Ops._gt
  Ops._gt0
  Ops._gt_t
  Ops._head
  Ops._head0
  Ops._head_t
  Ops._isConsistentType
  Ops._isEmpty
  Ops._isEmpty_t
  Ops._leq
  Ops._leq0
  Ops._leq_t
  Ops._lt
  Ops._lt0
  Ops._lt_t
  Ops._map
  Ops._map0
  Ops._map_t
  Ops._mul
  Ops._mul0
  Ops._mul_t
  Ops._neq
  Ops._neq_t
  Ops._not
  Ops._not_t
  Ops._opls
  Ops._opls_dec
  Ops._or
  Ops._or_t
  Ops._pop
  Ops._pop0
  Ops._pop_t
  Ops._print
  Ops._print0
  Ops._print_t
  Ops._seq
  Ops._seq0
  Ops._seq_t
  Ops._snd
  Ops._snd_t
  Ops._sub
  Ops._sub0
  Ops._sub_t
  Ops._succ
  Ops._succ0
  Ops._succ_t
  Ops._tail
  Ops._tail0
  Ops._tail_t
  Ops._take
  Ops._take0
  Ops._take_t
  Ops._typeFunction
  Ops.isConsistentType
  Ops.toList
module dependencies: Parser Types
package dependencies: base-4.14.1.0 ghc-prim-0.6.1
                      integer-gmp-1.0.3.0
orphans: base-4.14.1.0:GHC.Float base-4.14.1.0:GHC.Base
family instance modules: base-4.14.1.0:Control.Applicative
                         base-4.14.1.0:Control.Arrow base-4.14.1.0:Data.Functor.Const
                         base-4.14.1.0:Data.Functor.Identity base-4.14.1.0:Data.Monoid
                         base-4.14.1.0:Data.Semigroup.Internal base-4.14.1.0:GHC.Generics
                         base-4.14.1.0:GHC.IO.Exception
import  -/  Parser 3443f1228a5fa43ab36605baa220d75c
  exports: 4e79c2f1fd013aabc39c8f81cd5374c7
import  -/  Types b9822497053d2122dc73d0cfdd1b339f
  exports: 39b07b7f7957277f50c7c4dd7689ef5f
  BinOp d26ca552c0a6cb13c3d3e231f243d460
  Bool b70cd53ad7a85dab48bcef177c38636b
  Double b891f973d45771521238fab46a6ae819
  Err 49657f448604d6729aba97b2988953b9
  Exp 607e5ce3f9595614a9cb77b2c4210b74
  Fun 6815ac0e2ecfff4e0c829eba93adbd8b
  Func c1251ac84fede6c4ca7d3c4f0601d771
  FuncOp 97bc2911206d2b50aa94a433bccfe820
  Function 267e8a4d83f0f1e1729f2be1e5904e81
  Int 1626c1e059773b609f52829c5bb3fa74
  List bf4e22584c08f0cbc93d4ad500ad7f0d
  Op 607e5ce3f9595614a9cb77b2c4210b74
  Operator 89cca03e93ee20a41b3c3642d9fd3bba
  PreList 2cd63c03f6681ef78c8cf47e3c7f2b35
  Print e87b8ebec85f3fc24f975cc1e7e3e2cd
  Str 8b8af5b0acf7e0323f4cbb1ea5827222
  StrOp 607e5ce3f9595614a9cb77b2c4210b74
  T_Bool 3d5d104ad17812f63feb2aef3b1ad4cd
  T_Double 5e54cc1d20b392ed3d5fa02d6324f88c
  T_EmptyList 260f30ad032fd2d54f4552772b925552
  T_Error 235a36067aa706ad3f38a03931790620
  T_Func cd5569cdd28f55b0418b44742170970e
  T_Function 8cc668be17da098d88dc5ce953523aaa
  T_Int 4e42539dd2ce6e4876d946eaf17319c8
  T_List 54c5b828c2e4f1c661388c72c68886ad
  T_Operator 2b724b9e8f3f49af40f551abcf01d31a
  T_PreList c17694220febf02b1e3f97947f51ad95
  T_Print c36f4bc1af49ddd4b4541db838e6f9c0
  T_String 236f270036a6e60f712f937a8a1e2ed8
  T_Tuple e233fd3595057c845dc31260603df806
  T_Type c87dc5b3bf8d798697d64f66a60f27f0
  T_Unknown 6666a7ed1e898402891d2d748621a86d
  Tobe 114668cd72acff1452b72cb75dca7503
  Tuple 24eb98ce397df75e853fb8c92b81a145
  Type bd4ecaf43435ec6d916df969f32b0e1c
  Type 607e5ce3f9595614a9cb77b2c4210b74
  TypeCheck 7a98c1d9491014e3cc63bc169a5dd418
  UnOp 8c7eed723ee8887a5e082490f6ddf7d6
  Wrd 607e5ce3f9595614a9cb77b2c4210b74
  args 607e5ce3f9595614a9cb77b2c4210b74
  args_t 607e5ce3f9595614a9cb77b2c4210b74
  ret 607e5ce3f9595614a9cb77b2c4210b74
  ret_t 607e5ce3f9595614a9cb77b2c4210b74
  return_t 607e5ce3f9595614a9cb77b2c4210b74
import  -/  base-4.14.1.0:Data.List aa48efeea2e877aaa8c12a1a2e589508
import  -/  base-4.14.1.0:Debug.Trace 311b1d0b6fcef7b89debc64460553e8a
import  -/  base-4.14.1.0:GHC.Base ede51775731a544ddfcb02b5a427fd38
import  -/  base-4.14.1.0:GHC.List 7a32e59b6a27bd558cb52809f6fb6df5
import  -/  base-4.14.1.0:GHC.Num 5f3708b0d1d7a8d15017be85d4a06a34
import  -/  base-4.14.1.0:GHC.Real 4d6025ac56d7c23e0804ecdff4f69d75
import  -/  base-4.14.1.0:GHC.Show 57e93b26a19b08606d2ae3a6ff8065f2
import  -/  base-4.14.1.0:Prelude 5c84dfddbb8583fc340ecd15bead164a
import  -/  ghc-prim-0.6.1:GHC.Classes e50fb3f1cbf74ce4d3874442e4300a09
0077ca7edccd6222f88376e346118960
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module Ops.$trModule3 Ops.$trModule1) -}
c0e5d35f6a7bc4656ee570ea88581d20
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Ops.$trModule2) -}
f9b25b5dbdc46f2d265939d718e84bed
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Ops"#) -}
dfcd064acd8070b26ffa8c69c30fddf9
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Ops.$trModule4) -}
ca9bc36dca399398b222432313c4b910
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("Topos-0.1.0.0-L2hSunVxFDyol1qAzNo2F"#) -}
103fbd3fa54e1684446b8b9b09d6e3c7
  $wshowl :: [Types.Wrd] -> (# GHC.Types.Char, [GHC.Types.Char] #)
  {- Arity: 1, Strictness: <S,1*U>, Inline: [2] -}
b09cc786b72fd2818f6d6eea05286af0
  _add :: Types.Op
  {- Strictness: m1, Unfolding: (Types.BinOp Ops._add0) -}
f75419664c688defc087f76d32d22656
  _add0 :: Types.Wrd -> Types.Wrd -> Types.Wrd
  {- Arity: 2, Strictness: <S,U><L,U>,
     Unfolding: (\ (ds :: Types.Wrd) (ds1 :: Types.Wrd) ->
                 let {
                   fail :: GHC.Prim.Void# -> Types.Wrd
                     <join 1> {- Arity: 1, Strictness: <L,A> -}
                   = \ (ds2 :: GHC.Prim.Void#)[OneShot] ->
                     Types.Err
                       (GHC.CString.unpackAppendCString#
                          Ops._add2
                          (GHC.Base.++
                             @ GHC.Types.Char
                             (Types.$fShowBind_$cshow ds)
                             (GHC.CString.unpackAppendCString#
                                Ops._add1
                                (Types.$fShowBind_$cshow ds1))))
                 } in
                 case ds of wild {
                   DEFAULT -> fail GHC.Prim.void#
                   Types.Str s1
                   -> case ds1 of wild1 {
                        DEFAULT -> fail GHC.Prim.void#
                        Types.Str s2 -> Types.Str (GHC.Base.++ @ GHC.Types.Char s1 s2) }
                   Types.Double x
                   -> case ds1 of wild1 {
                        DEFAULT -> fail GHC.Prim.void#
                        Types.Double y -> Types.Double (GHC.Float.plusDouble x y)
                        Types.Int y
                        -> Types.Double
                             (case x of wild2 { GHC.Types.D# x1 ->
                              case y of wild3 { GHC.Types.I# i ->
                              GHC.Types.D# (GHC.Prim.+## x1 (GHC.Prim.int2Double# i)) } }) }
                   Types.Int x
                   -> case ds1 of wild1 {
                        DEFAULT -> fail GHC.Prim.void#
                        Types.Double y
                        -> Types.Double
                             (case x of wild2 { GHC.Types.I# i ->
                              case y of wild3 { GHC.Types.D# y1 ->
                              GHC.Types.D# (GHC.Prim.+## (GHC.Prim.int2Double# i) y1) } })
                        Types.Int y -> Types.Int (GHC.Num.$fNumInt_$c+ x y) }
                   Types.List l1
                   -> case ds1 of wild1 {
                        DEFAULT -> fail GHC.Prim.void#
                        Types.List l2 -> Ops.toList (GHC.Base.++ @ Types.Wrd l1 l2) } }) -}
9a2955ab09703cd32219213c1c5551c7
  _add1 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: (", y="#) -}
a8bc2cb4b2ded22b4496a1fbed2cab76
  _add2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("`+`: Illegal input value: x="#) -}
30b5baf3006a0617b9d4a275f0812218
  _add_t :: Types.Wrd -> Types.Wrd -> Types.Wrd
  {- Arity: 2, Strictness: <S,U><L,U>,
     Unfolding: (\ (ds :: Types.Wrd) (ds1 :: Types.Wrd) ->
                 let {
                   fail :: GHC.Prim.Void# -> Types.Wrd
                     <join 1> {- Arity: 1, Strictness: <L,A> -}
                   = \ (ds2 :: GHC.Prim.Void#)[OneShot] ->
                     Types.Err
                       (GHC.CString.unpackAppendCString#
                          Ops._add_t7
                          (GHC.Base.++
                             @ GHC.Types.Char
                             (Types.$fShowBind_$cshow ds)
                             (GHC.CString.unpackAppendCString#
                                Ops._add_t6
                                (Types.$fShowBind_$cshow ds1))))
                 } in
                 case ds of wild {
                   DEFAULT -> fail GHC.Prim.void#
                   Types.TypeCheck ds2
                   -> case ds2 of wild1 {
                        DEFAULT -> fail GHC.Prim.void#
                        Types.T_Int
                        -> case ds1 of wild2 {
                             DEFAULT -> fail GHC.Prim.void#
                             Types.TypeCheck ds3
                             -> case ds3 of wild3 {
                                  DEFAULT -> fail GHC.Prim.void#
                                  Types.T_Int -> Ops._add_t5
                                  Types.T_Double -> Ops._add_t4 } }
                        Types.T_Double
                        -> case ds1 of wild2 {
                             DEFAULT -> fail GHC.Prim.void#
                             Types.TypeCheck ds3
                             -> case ds3 of wild3 {
                                  DEFAULT -> fail GHC.Prim.void#
                                  Types.T_Int -> Ops._add_t4
                                  Types.T_Double -> Ops._add_t4 } }
                        Types.T_String
                        -> case ds1 of wild2 {
                             DEFAULT -> fail GHC.Prim.void#
                             Types.TypeCheck ds3
                             -> case ds3 of wild3 {
                                  DEFAULT -> fail GHC.Prim.void# Types.T_String -> Ops._add_t3 } }
                        Types.T_List t1
                        -> case ds1 of wild2 {
                             DEFAULT -> fail GHC.Prim.void#
                             Types.TypeCheck ds3
                             -> case ds3 of wild3 {
                                  DEFAULT -> fail GHC.Prim.void#
                                  Types.T_List t2
                                  -> case Types.$fEqBind_$c==1 t1 t2 of wild4 {
                                       GHC.Types.False
                                       -> Types.Err
                                            (GHC.CString.unpackAppendCString#
                                               Ops._add_t2
                                               (GHC.Base.++
                                                  @ GHC.Types.Char
                                                  (Types.$fShowBind_$cshowsPrec1
                                                     Types.$fShowBind2
                                                     t1
                                                     (GHC.Types.[] @ GHC.Types.Char))
                                                  (GHC.CString.unpackAppendCString#
                                                     Ops._add_t1
                                                     (Types.$fShowBind_$cshowsPrec1
                                                        Types.$fShowBind2
                                                        t2
                                                        (GHC.Types.[] @ GHC.Types.Char)))))
                                       GHC.Types.True -> wild } } } } }) -}
5c8d703e7770c4e8447f48c788ccdb0d
  _add_t1 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: (", t2="#) -}
d3a83146be059780d910ef8ebb52a172
  _add_t2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("`+`: Wrd mismatch of lists: t1="#) -}
d190d3240a169a5858d83ca487319ad4
  _add_t3 :: Types.Wrd
  {- HasNoCafRefs, Strictness: m18,
     Unfolding: (Types.TypeCheck Types.T_String) -}
fb5b4c1dffad40319e2e1fbb0f2e20df
  _add_t4 :: Types.Wrd
  {- HasNoCafRefs, Strictness: m18,
     Unfolding: (Types.TypeCheck Types.T_Double) -}
5f4ddcb9f19056ec283cac24ff6f6c55
  _add_t5 :: Types.Wrd
  {- HasNoCafRefs, Strictness: m18,
     Unfolding: (Types.TypeCheck Types.T_Int) -}
239af5d931f67d83328a03e6fe09ee73
  _add_t6 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: (", t_y="#) -}
6854d4481a0f7da1f8adb1f67c37d344
  _add_t7 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("`+`: Illegal input type: t_x="#) -}
fa9d3d44a843355e1a149e4f4bc13246
  _and :: Types.Op
  {- Strictness: m1, Unfolding: (Types.BinOp Ops._and1) -}
65fdf0575a74fc92b6ff2a5e6dff7cb8
  _and1 :: Types.Wrd -> Types.Wrd -> Types.Wrd
  {- Arity: 2, Strictness: <S,1*U><S,1*U>m8, Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Types.Wrd) (w1 :: Types.Wrd) ->
                 case w of wild {
                   DEFAULT
                   -> Control.Exception.Base.patError
                        @ 'GHC.Types.LiftedRep
                        @ Types.Wrd
                        Ops._and2
                   Types.Bool a
                   -> case w1 of wild1 {
                        DEFAULT
                        -> Control.Exception.Base.patError
                             @ 'GHC.Types.LiftedRep
                             @ Types.Wrd
                             Ops._and2
                        Types.Bool b
                        -> Types.Bool
                             (case a of wild2 {
                                GHC.Types.False -> GHC.Types.False GHC.Types.True -> b }) } }) -}
1f7134b1bcd7b2d76cf3ff28f5e470eb
  _and2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("src/Ops.hs:246:15-51|lambda"#) -}
fc2743656532e0ef05c809643682003d
  _and_t :: Types.Wrd -> Types.Wrd -> Types.Wrd
  {- Arity: 2, Strictness: <S,1*U><S,U>,
     Unfolding: (\ (ds :: Types.Wrd) (ds1 :: Types.Wrd) ->
                 case ds of wild {
                   DEFAULT -> Ops._and_t4
                   Types.TypeCheck ds2
                   -> let {
                        fail :: GHC.Prim.Void# -> Types.Wrd
                          <join 1> {- Arity: 1, Strictness: <L,A> -}
                        = \ (ds3 :: GHC.Prim.Void#)[OneShot] ->
                          case ds1 of wild1 {
                            DEFAULT -> Ops._and_t4
                            Types.TypeCheck t2
                            -> Types.Err
                                 (GHC.CString.unpackAppendCString#
                                    Ops._and_t3
                                    (GHC.Base.++
                                       @ GHC.Types.Char
                                       (Types.$fShowBind_$cshowsPrec1
                                          Types.$fShowBind2
                                          ds2
                                          (GHC.Types.[] @ GHC.Types.Char))
                                       (GHC.CString.unpackAppendCString#
                                          Ops._and_t2
                                          (Types.$fShowBind_$cshowsPrec1
                                             Types.$fShowBind2
                                             t2
                                             (GHC.Types.[] @ GHC.Types.Char))))) }
                      } in
                      case ds2 of wild1 {
                        DEFAULT -> fail GHC.Prim.void#
                        Types.T_Bool
                        -> case ds1 of wild2 {
                             DEFAULT -> fail GHC.Prim.void#
                             Types.TypeCheck ds3
                             -> case ds3 of wild3 {
                                  DEFAULT -> fail GHC.Prim.void#
                                  Types.T_Bool -> Ops._and_t1 } } } }) -}
0575596eea8627eaa7ec602fa858dd65
  _and_t1 :: Types.Wrd
  {- HasNoCafRefs, Strictness: m18,
     Unfolding: (Types.TypeCheck Types.T_Bool) -}
c14ad5c14b5d2e5fb364d19e075b9eee
  _and_t2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: (", RHS="#) -}
21a5a768a8a30fa169189ca503f4e131
  _and_t3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("`&&`: Illegal input type: LHS="#) -}
9693e7053c71e48558cd3548c629ee1d
  _and_t4 :: Types.Wrd
  {- Strictness: b -}
16e5c02c7fdde6e2b46ac08b12e746ed
  _div :: Types.Op
  {- Strictness: m1, Unfolding: (Types.BinOp Ops._div0) -}
98ac439b5a9aaf318bcd7c354a12eac4
  _div0 :: Types.Wrd -> Types.Wrd -> Types.Wrd
  {- Arity: 2, Strictness: <L,U><S,U>,
     Unfolding: (\ (ds :: Types.Wrd) (ds1 :: Types.Wrd) ->
                 let {
                   fail :: GHC.Prim.Void# -> Types.Wrd
                     <join 1> {- Arity: 1, Strictness: <L,A> -}
                   = \ (ds2 :: GHC.Prim.Void#)[OneShot] ->
                     let {
                       fail1 :: GHC.Prim.Void# -> Types.Wrd
                         <join 1> {- Arity: 1, Strictness: <L,A> -}
                       = \ (ds3 :: GHC.Prim.Void#)[OneShot] ->
                         Types.Err
                           (GHC.CString.unpackAppendCString#
                              Ops._div4
                              (GHC.Base.++
                                 @ GHC.Types.Char
                                 (Types.$fShowBind_$cshow ds)
                                 (GHC.CString.unpackAppendCString#
                                    Ops._add1
                                    (Types.$fShowBind_$cshow ds1))))
                     } in
                     case ds of wild {
                       DEFAULT -> fail1 GHC.Prim.void#
                       Types.Double x
                       -> case ds1 of wild1 {
                            DEFAULT -> fail1 GHC.Prim.void#
                            Types.Double y -> Types.Double (GHC.Float.divideDouble x y)
                            Types.Int y
                            -> Types.Double
                                 (case x of wild2 { GHC.Types.D# x1 ->
                                  case y of wild3 { GHC.Types.I# i ->
                                  case GHC.Prim./##
                                         x1
                                         (GHC.Prim.int2Double# i) of wild4 { DEFAULT ->
                                  GHC.Types.D# wild4 } } }) }
                       Types.Int x
                       -> case ds1 of wild1 {
                            DEFAULT -> fail1 GHC.Prim.void#
                            Types.Double y
                            -> Types.Double
                                 (case x of wild2 { GHC.Types.I# i ->
                                  case y of wild3 { GHC.Types.D# y1 ->
                                  case GHC.Prim./##
                                         (GHC.Prim.int2Double# i)
                                         y1 of wild4 { DEFAULT ->
                                  GHC.Types.D# wild4 } } })
                            Types.Int y
                            -> Types.Double
                                 (case x of wild2 { GHC.Types.I# i ->
                                  case y of wild3 { GHC.Types.I# i1 ->
                                  case GHC.Prim./##
                                         (GHC.Prim.int2Double# i)
                                         (GHC.Prim.int2Double# i1) of wild4 { DEFAULT ->
                                  GHC.Types.D# wild4 } } }) } }
                 } in
                 case ds1 of wild {
                   DEFAULT -> fail GHC.Prim.void#
                   Types.Double ds2
                   -> case ds2 of wild1 { GHC.Types.D# x ->
                      case GHC.Prim.==## x 0.0## of lwild {
                        DEFAULT -> fail GHC.Prim.void# 1# -> Ops._div1 } }
                   Types.Int ds2
                   -> case ds2 of wild1 { GHC.Types.I# ds3 ->
                      case ds3 of ds4 {
                        DEFAULT -> fail GHC.Prim.void# 0# -> Ops._div1 } } }) -}
19dda39c709a76a75b855b37d8c43079
  _div1 :: Types.Wrd
  {- Strictness: m12, Unfolding: (Types.Err Ops._div2) -}
8fca883992df908dfd44fa917f4b0d94
  _div2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Ops._div3) -}
dc79cca681dd9fde60bfc3224e841ebb
  _div3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Zero division error."#) -}
24854537f568b7ddd76b5c1c5f5d12d9
  _div4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("`/`: Illegal input value: x="#) -}
57a81904c4c4fcff5f48389606fe3995
  _div_t :: Types.Wrd -> Types.Wrd -> Types.Wrd
  {- Arity: 2, Strictness: <S,U><L,U>,
     Unfolding: (\ (ds :: Types.Wrd) (ds1 :: Types.Wrd) ->
                 let {
                   fail :: GHC.Prim.Void# -> Types.Wrd
                     <join 1> {- Arity: 1, Strictness: <L,A> -}
                   = \ (ds2 :: GHC.Prim.Void#)[OneShot] ->
                     Types.Err
                       (GHC.CString.unpackAppendCString#
                          Ops._div_t1
                          (GHC.Base.++
                             @ GHC.Types.Char
                             (Types.$fShowBind_$cshow ds)
                             (GHC.CString.unpackAppendCString#
                                Ops._add_t6
                                (Types.$fShowBind_$cshow ds1))))
                 } in
                 case ds of wild {
                   DEFAULT -> fail GHC.Prim.void#
                   Types.TypeCheck ds2
                   -> case ds2 of wild1 {
                        DEFAULT -> fail GHC.Prim.void#
                        Types.T_Int
                        -> case ds1 of wild2 {
                             DEFAULT -> fail GHC.Prim.void#
                             Types.TypeCheck ds3
                             -> case ds3 of wild3 {
                                  DEFAULT -> fail GHC.Prim.void#
                                  Types.T_Int -> Ops._add_t4
                                  Types.T_Double -> Ops._add_t4 } }
                        Types.T_Double
                        -> case ds1 of wild2 {
                             DEFAULT -> fail GHC.Prim.void#
                             Types.TypeCheck ds3
                             -> case ds3 of wild3 {
                                  DEFAULT -> fail GHC.Prim.void#
                                  Types.T_Int -> Ops._add_t4
                                  Types.T_Double -> Ops._add_t4 } } } }) -}
4ccdf900e6414f9d5439cf6f1f1322a6
  _div_t1 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("`/`: Illegal input type: t_x="#) -}
2fde59f8571c8c3c3fa3bdd5c020064e
  _eq :: Types.Op
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (Types.BinOp Ops._eq1) -}
1a00180c42e0b2b55d2f58601964e6b6
  _eq1 :: Types.Wrd -> Types.Wrd -> Types.Wrd
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U><L,1*U>m8,
     Unfolding: InlineRule (2, True, False)
                (\ (a :: Types.Wrd) (b :: Types.Wrd) ->
                 Types.Bool (Types.$fEqBind_$c==2 a b)) -}
d1338c4a35a837bd4872ab8c0fde2433
  _eq_t :: Types.Wrd -> Types.Wrd -> Types.Wrd
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (ds :: Types.Wrd) (ds1 :: Types.Wrd) ->
                 case ds of wild {
                   DEFAULT -> Ops._eq_t2
                   Types.TypeCheck t1
                   -> case ds1 of wild1 {
                        DEFAULT -> Ops._eq_t2
                        Types.TypeCheck t2
                        -> case Types.$fEqBind_$c==1 t1 t2 of wild2 {
                             GHC.Types.False
                             -> Types.Err
                                  (GHC.CString.unpackAppendCString#
                                     Ops._eq_t1
                                     (GHC.Base.++
                                        @ GHC.Types.Char
                                        (Types.$fShowBind_$cshowsPrec1
                                           Types.$fShowBind2
                                           t1
                                           (GHC.Types.[] @ GHC.Types.Char))
                                        (GHC.CString.unpackAppendCString#
                                           Ops._and_t2
                                           (Types.$fShowBind_$cshowsPrec1
                                              Types.$fShowBind2
                                              t2
                                              (GHC.Types.[] @ GHC.Types.Char)))))
                             GHC.Types.True -> Ops._and_t1 } } }) -}
0b4c5bafe1abd3d6896f903edaf7e6e6
  _eq_t1 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("`=`: Wrd mismatch of both sides: LHS="#) -}
53759b9cbfc052c8891b8ffe90d7f3d6
  _eq_t2 :: Types.Wrd
  {- Strictness: b -}
0eb18df97009ded23de5d637589860c4
  _fst :: Types.Op
  {- Strictness: m2, Unfolding: (Types.UnOp Ops._fst1) -}
4959f964ff44e95bae217658d155b02e
  _fst1 :: Types.Wrd -> Types.Wrd
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Types.Wrd) ->
                 case ds of wild {
                   DEFAULT
                   -> Control.Exception.Base.patError
                        @ 'GHC.Types.LiftedRep
                        @ Types.Wrd
                        Ops._fst2
                   Types.Tuple ds1
                   -> case ds1 of wild1 {
                        []
                        -> Control.Exception.Base.patError
                             @ 'GHC.Types.LiftedRep
                             @ Types.Wrd
                             Ops._fst2
                        : w1 ds2 -> w1 } }) -}
891d4cbd35d062601eaf7ec0eb646755
  _fst2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("src/Ops.hs:340:14-37|lambda"#) -}
c4545c97a056aabd7444aca279e04d89
  _fst_t :: Types.Wrd -> Types.Wrd
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: Types.Wrd) ->
                 case ds of wild {
                   DEFAULT
                   -> Types.Err
                        (GHC.CString.unpackAppendCString#
                           Ops._fst_t1
                           (Types.$fShowBind_$cshow wild))
                   Types.TypeCheck ds1
                   -> case ds1 of wild1 {
                        DEFAULT
                        -> Types.Err
                             (GHC.CString.unpackAppendCString#
                                Ops._fst_t1
                                (Types.$fShowBind_$cshow wild))
                        Types.T_Tuple ds2
                        -> case ds2 of wild2 {
                             []
                             -> Types.Err
                                  (GHC.CString.unpackAppendCString#
                                     Ops._fst_t1
                                     (Types.$fShowBind_$cshow wild))
                             : t ds3 -> Types.TypeCheck t } } }) -}
b6bc0ed9cd47a6358c2ac6aace023af5
  _fst_t1 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("fst: Illegal input type: "#) -}
80d146b862fbd4f89add80c9ea8a883e
  _geq :: Types.Op
  {- Strictness: m1, Unfolding: (Types.BinOp Ops._geq0) -}
cbbca7b326cd07229b83dd97fc973ea5
  _geq0 :: Types.Wrd -> Types.Wrd -> Types.Wrd
  {- Arity: 2, Strictness: <S,1*U><S,1*U>m8, Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Types.Wrd) (w1 :: Types.Wrd) ->
                 case w of wild {
                   DEFAULT -> Ops._geq1
                   Types.Double x
                   -> case w1 of wild1 {
                        DEFAULT -> Ops._geq1
                        Types.Double y
                        -> Types.Bool
                             (case x of wild2 { GHC.Types.D# x1 ->
                              case y of wild3 { GHC.Types.D# y1 ->
                              GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.>=## x1 y1) } })
                        Types.Int y
                        -> Types.Bool
                             (case x of wild2 { GHC.Types.D# x1 ->
                              case y of wild3 { GHC.Types.I# i ->
                              GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.>=## x1 (GHC.Prim.int2Double# i)) } }) }
                   Types.Int x
                   -> case w1 of wild1 {
                        DEFAULT -> Ops._geq1
                        Types.Double y
                        -> Types.Bool
                             (case x of wild2 { GHC.Types.I# i ->
                              case y of wild3 { GHC.Types.D# y1 ->
                              GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.>=## (GHC.Prim.int2Double# i) y1) } })
                        Types.Int y -> Types.Bool (GHC.Classes.geInt x y) } }) -}
e562e95ce449faeda829e75ce75e884a
  _geq1 :: Types.Wrd
  {- Strictness: b -}
72da17c0c2b301d31a74998cda225ef3
  _geq_t :: Types.Wrd -> Types.Wrd -> Types.Wrd
  {- Arity: 2, Strictness: <S,1*U><S,U>,
     Unfolding: (\ (ds :: Types.Wrd) (ds1 :: Types.Wrd) ->
                 case ds of wild {
                   DEFAULT -> Ops._geq_t2
                   Types.TypeCheck ds2
                   -> let {
                        fail :: GHC.Prim.Void# -> Types.Wrd
                          <join 1> {- Arity: 1, Strictness: <L,A> -}
                        = \ (ds3 :: GHC.Prim.Void#)[OneShot] ->
                          case ds1 of wild1 {
                            DEFAULT -> Ops._geq_t2
                            Types.TypeCheck t2
                            -> Types.Err
                                 (GHC.CString.unpackAppendCString#
                                    Ops._geq_t1
                                    (GHC.Base.++
                                       @ GHC.Types.Char
                                       (Types.$fShowBind_$cshowsPrec1
                                          Types.$fShowBind2
                                          ds2
                                          (GHC.Types.[] @ GHC.Types.Char))
                                       (GHC.CString.unpackAppendCString#
                                          Ops._and_t2
                                          (Types.$fShowBind_$cshowsPrec1
                                             Types.$fShowBind2
                                             t2
                                             (GHC.Types.[] @ GHC.Types.Char))))) }
                      } in
                      case ds2 of wild1 {
                        DEFAULT -> fail GHC.Prim.void#
                        Types.T_Int
                        -> case ds1 of wild2 {
                             DEFAULT -> fail GHC.Prim.void#
                             Types.TypeCheck ds3
                             -> case ds3 of wild3 {
                                  DEFAULT -> fail GHC.Prim.void#
                                  Types.T_Int -> Ops._and_t1
                                  Types.T_Double -> Ops._and_t1 } }
                        Types.T_Double
                        -> case ds1 of wild2 {
                             DEFAULT -> fail GHC.Prim.void#
                             Types.TypeCheck ds3
                             -> case ds3 of wild3 {
                                  DEFAULT -> fail GHC.Prim.void#
                                  Types.T_Int -> Ops._and_t1
                                  Types.T_Double -> Ops._and_t1 } } } }) -}
bd2539ed84360f360a08990f0a8f318d
  _geq_t1 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("`>=`: Illegal input type: LHS="#) -}
317729e344ddf18d8949163a7d1c6659
  _geq_t2 :: Types.Wrd
  {- Strictness: b -}
90ff28e62a99dc82d7325615ac131599
  _getType :: Types.Wrd -> Types.Type
  {- Arity: 1, Strictness: <S,1*U> -}
dc62302f1b88389c68771da62d81a1e4
  _gt :: Types.Op
  {- Strictness: m1, Unfolding: (Types.BinOp Ops._gt0) -}
7c9ea80660d23b8e39137c03dacc0935
  _gt0 :: Types.Wrd -> Types.Wrd -> Types.Wrd
  {- Arity: 2, Strictness: <S,1*U><S,1*U>m8, Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Types.Wrd) (w1 :: Types.Wrd) ->
                 case w of wild {
                   DEFAULT -> Ops._gt1
                   Types.Double x
                   -> case w1 of wild1 {
                        DEFAULT -> Ops._gt1
                        Types.Double y
                        -> Types.Bool
                             (case x of wild2 { GHC.Types.D# x1 ->
                              case y of wild3 { GHC.Types.D# y1 ->
                              GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.>## x1 y1) } })
                        Types.Int y
                        -> Types.Bool
                             (case x of wild2 { GHC.Types.D# x1 ->
                              case y of wild3 { GHC.Types.I# i ->
                              GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.>## x1 (GHC.Prim.int2Double# i)) } }) }
                   Types.Int x
                   -> case w1 of wild1 {
                        DEFAULT -> Ops._gt1
                        Types.Double y
                        -> Types.Bool
                             (case x of wild2 { GHC.Types.I# i ->
                              case y of wild3 { GHC.Types.D# y1 ->
                              GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.>## (GHC.Prim.int2Double# i) y1) } })
                        Types.Int y -> Types.Bool (GHC.Classes.gtInt x y) } }) -}
eac7e6aa9fab27c3a709863a100d8491
  _gt1 :: Types.Wrd
  {- Strictness: b -}
15981ed38b5bf349c4a1cefb70e86295
  _gt_t :: Types.Wrd -> Types.Wrd -> Types.Wrd
  {- Arity: 2, Strictness: <S,1*U><S,U>,
     Unfolding: (\ (ds :: Types.Wrd) (ds1 :: Types.Wrd) ->
                 case ds of wild {
                   DEFAULT -> Ops._gt_t2
                   Types.TypeCheck ds2
                   -> let {
                        fail :: GHC.Prim.Void# -> Types.Wrd
                          <join 1> {- Arity: 1, Strictness: <L,A> -}
                        = \ (ds3 :: GHC.Prim.Void#)[OneShot] ->
                          case ds1 of wild1 {
                            DEFAULT -> Ops._gt_t2
                            Types.TypeCheck t2
                            -> Types.Err
                                 (GHC.CString.unpackAppendCString#
                                    Ops._gt_t1
                                    (GHC.Base.++
                                       @ GHC.Types.Char
                                       (Types.$fShowBind_$cshowsPrec1
                                          Types.$fShowBind2
                                          ds2
                                          (GHC.Types.[] @ GHC.Types.Char))
                                       (GHC.CString.unpackAppendCString#
                                          Ops._and_t2
                                          (Types.$fShowBind_$cshowsPrec1
                                             Types.$fShowBind2
                                             t2
                                             (GHC.Types.[] @ GHC.Types.Char))))) }
                      } in
                      case ds2 of wild1 {
                        DEFAULT -> fail GHC.Prim.void#
                        Types.T_Int
                        -> case ds1 of wild2 {
                             DEFAULT -> fail GHC.Prim.void#
                             Types.TypeCheck ds3
                             -> case ds3 of wild3 {
                                  DEFAULT -> fail GHC.Prim.void#
                                  Types.T_Int -> Ops._and_t1
                                  Types.T_Double -> Ops._and_t1 } }
                        Types.T_Double
                        -> case ds1 of wild2 {
                             DEFAULT -> fail GHC.Prim.void#
                             Types.TypeCheck ds3
                             -> case ds3 of wild3 {
                                  DEFAULT -> fail GHC.Prim.void#
                                  Types.T_Int -> Ops._and_t1
                                  Types.T_Double -> Ops._and_t1 } } } }) -}
59092bd74d2d278cba5cfbd0fa9b8e41
  _gt_t1 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("`>`: Illegal input type: LHS="#) -}
36684904f0776b02ee8213787e9d788c
  _gt_t2 :: Types.Wrd
  {- Strictness: b -}
09b17a90ddd9920901c34f63ec960a4f
  _head :: Types.Op
  {- Strictness: m2, Unfolding: (Types.UnOp Ops._head0) -}
03ea664eed18c7fb6729feddae94701e
  _head0 :: Types.Wrd -> Types.Wrd
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Types.Wrd) ->
                 case ds of wild {
                   DEFAULT -> Ops._head4
                   Types.List ds1
                   -> case ds1 of wild1 { [] -> Ops._head1 : x ds2 -> x } }) -}
6f852c778c53446089bd6af0fb1bf910
  _head1 :: Types.Wrd
  {- Strictness: m12, Unfolding: (Types.Err Ops._head2) -}
10595b0063f9a03ed93ee60883e08627
  _head2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Ops._head3) -}
3872cd20e640f04e630362819e26fdd3
  _head3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("head: Empty list."#) -}
fcae7ce061bdbd1164e63fc64a78dcf6
  _head4 :: Types.Wrd
  {- Strictness: b -}
2b27a262e2cee0e6012d0f773c37726c
  _head_t :: Types.Wrd -> Types.Wrd
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: Types.Wrd) ->
                 case ds of wild {
                   DEFAULT -> Ops._head_t2
                   Types.TypeCheck ds1
                   -> case ds1 of wild1 {
                        DEFAULT
                        -> Types.Err
                             (GHC.CString.unpackAppendCString#
                                Ops._head_t1
                                (Types.$fShowBind_$cshowsPrec1
                                   Types.$fShowBind2
                                   wild1
                                   (GHC.Types.[] @ GHC.Types.Char)))
                        Types.T_List t -> Types.TypeCheck t } }) -}
341a78104a1baa5a630af1beff815252
  _head_t1 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("head: Illegal input type: "#) -}
32283288a9801ad3e6c92855ef73629e
  _head_t2 :: Types.Wrd
  {- Strictness: b -}
21070a18bc5e91b4ed6dd4e6dcba2d17
  _isConsistentType :: Types.Exp -> GHC.Maybe.Maybe Types.Type
  {- Arity: 1, Strictness: <S,1*U> -}
2cab4733c94f1324e85361c661e2f965
  _isEmpty :: Types.Op
  {- Strictness: m2, Unfolding: (Types.UnOp Ops._isEmpty1) -}
069f04523ee84c456f4d2d941471e72e
  _isEmpty1 :: Types.Wrd -> Types.Wrd
  {- Arity: 1, Strictness: <S,1*U>m8,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Types.Wrd) ->
                 case ds of wild {
                   DEFAULT -> Ops._isEmpty2
                   Types.List ls
                   -> Types.Bool
                        (GHC.Classes.$fEq[]_$c==
                           @ Types.Wrd
                           Types.$fEqWrd
                           ls
                           (GHC.Types.[] @ Types.Wrd)) }) -}
0c2023312bf6364e43345ca3f69983e6
  _isEmpty2 :: Types.Wrd
  {- Strictness: b -}
2130fc56c55fd1b0c46640600408c9db
  _isEmpty_t :: Types.Wrd -> Types.Wrd
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: Types.Wrd) ->
                 case ds of wild {
                   DEFAULT -> Ops._isEmpty_t2
                   Types.TypeCheck ds1
                   -> case ds1 of wild1 {
                        DEFAULT
                        -> Types.Err
                             (GHC.CString.unpackAppendCString#
                                Ops._isEmpty_t1
                                (Types.$fShowBind_$cshowsPrec1
                                   Types.$fShowBind2
                                   wild1
                                   (GHC.Types.[] @ GHC.Types.Char)))
                        Types.T_List ds2 -> Ops._and_t1 } }) -}
7ee732c9199798439f16df2880508448
  _isEmpty_t1 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("isEmpty: Illegal input type: "#) -}
ab80dec497becdf5e41a02c3e730a2e8
  _isEmpty_t2 :: Types.Wrd
  {- Strictness: b -}
28cddcf7ff18d628d61e0df31b301893
  _leq :: Types.Op
  {- Strictness: m1, Unfolding: (Types.BinOp Ops._leq0) -}
ef20658217a524afdcb7faedfc30efc1
  _leq0 :: Types.Wrd -> Types.Wrd -> Types.Wrd
  {- Arity: 2, Strictness: <S,1*U><S,1*U>m8, Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Types.Wrd) (w1 :: Types.Wrd) ->
                 case w of wild {
                   DEFAULT -> Ops._leq1
                   Types.Double x
                   -> case w1 of wild1 {
                        DEFAULT -> Ops._leq1
                        Types.Double y
                        -> Types.Bool
                             (case x of wild2 { GHC.Types.D# x1 ->
                              case y of wild3 { GHC.Types.D# y1 ->
                              GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<=## x1 y1) } })
                        Types.Int y
                        -> Types.Bool
                             (case x of wild2 { GHC.Types.D# x1 ->
                              case y of wild3 { GHC.Types.I# i ->
                              GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.<=## x1 (GHC.Prim.int2Double# i)) } }) }
                   Types.Int x
                   -> case w1 of wild1 {
                        DEFAULT -> Ops._leq1
                        Types.Double y
                        -> Types.Bool
                             (case x of wild2 { GHC.Types.I# i ->
                              case y of wild3 { GHC.Types.D# y1 ->
                              GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.<=## (GHC.Prim.int2Double# i) y1) } })
                        Types.Int y -> Types.Bool (GHC.Classes.leInt x y) } }) -}
5d98df5d29f38260d0d315b543f4616a
  _leq1 :: Types.Wrd
  {- Strictness: b -}
0c4480fba1bdffbf3d1fbe1f4ff243fb
  _leq_t :: Types.Wrd -> Types.Wrd -> Types.Wrd
  {- Arity: 2, Strictness: <S,1*U><S,U>,
     Unfolding: (\ (ds :: Types.Wrd) (ds1 :: Types.Wrd) ->
                 case ds of wild {
                   DEFAULT -> Ops._leq_t1
                   Types.TypeCheck ds2
                   -> let {
                        fail :: GHC.Prim.Void# -> Types.Wrd
                          <join 1> {- Arity: 1, Strictness: <L,A> -}
                        = \ (ds3 :: GHC.Prim.Void#)[OneShot] ->
                          case ds1 of wild1 {
                            DEFAULT -> Ops._leq_t1
                            Types.TypeCheck t2
                            -> Types.Err
                                 (GHC.CString.unpackAppendCString#
                                    Ops._geq_t1
                                    (GHC.Base.++
                                       @ GHC.Types.Char
                                       (Types.$fShowBind_$cshowsPrec1
                                          Types.$fShowBind2
                                          ds2
                                          (GHC.Types.[] @ GHC.Types.Char))
                                       (GHC.CString.unpackAppendCString#
                                          Ops._and_t2
                                          (Types.$fShowBind_$cshowsPrec1
                                             Types.$fShowBind2
                                             t2
                                             (GHC.Types.[] @ GHC.Types.Char))))) }
                      } in
                      case ds2 of wild1 {
                        DEFAULT -> fail GHC.Prim.void#
                        Types.T_Int
                        -> case ds1 of wild2 {
                             DEFAULT -> fail GHC.Prim.void#
                             Types.TypeCheck ds3
                             -> case ds3 of wild3 {
                                  DEFAULT -> fail GHC.Prim.void#
                                  Types.T_Int -> Ops._and_t1
                                  Types.T_Double -> Ops._and_t1 } }
                        Types.T_Double
                        -> case ds1 of wild2 {
                             DEFAULT -> fail GHC.Prim.void#
                             Types.TypeCheck ds3
                             -> case ds3 of wild3 {
                                  DEFAULT -> fail GHC.Prim.void#
                                  Types.T_Int -> Ops._and_t1
                                  Types.T_Double -> Ops._and_t1 } } } }) -}
dbde1984146efbe9a371a2234b807329
  _leq_t1 :: Types.Wrd
  {- Strictness: b -}
b7ffa68aa46040f7c58f7806bc1a6468
  _lt :: Types.Op
  {- Strictness: m1, Unfolding: (Types.BinOp Ops._lt0) -}
b7310d1a5ac336aee8be98b65f3d41c1
  _lt0 :: Types.Wrd -> Types.Wrd -> Types.Wrd
  {- Arity: 2, Strictness: <S,1*U><S,1*U>m8, Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Types.Wrd) (w1 :: Types.Wrd) ->
                 case w of wild {
                   DEFAULT -> Ops._lt1
                   Types.Double x
                   -> case w1 of wild1 {
                        DEFAULT -> Ops._lt1
                        Types.Double y
                        -> Types.Bool
                             (case x of wild2 { GHC.Types.D# x1 ->
                              case y of wild3 { GHC.Types.D# y1 ->
                              GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<## x1 y1) } })
                        Types.Int y
                        -> Types.Bool
                             (case x of wild2 { GHC.Types.D# x1 ->
                              case y of wild3 { GHC.Types.I# i ->
                              GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.<## x1 (GHC.Prim.int2Double# i)) } }) }
                   Types.Int x
                   -> case w1 of wild1 {
                        DEFAULT -> Ops._lt1
                        Types.Double y
                        -> Types.Bool
                             (case x of wild2 { GHC.Types.I# i ->
                              case y of wild3 { GHC.Types.D# y1 ->
                              GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.<## (GHC.Prim.int2Double# i) y1) } })
                        Types.Int y -> Types.Bool (GHC.Classes.ltInt x y) } }) -}
c4ef4d9118bf40ca7b44369fd1f2e73b
  _lt1 :: Types.Wrd
  {- Strictness: b -}
a73d93a4e9ac002fee4b4370a5666be0
  _lt_t :: Types.Wrd -> Types.Wrd -> Types.Wrd
  {- Arity: 2, Strictness: <S,1*U><S,U>,
     Unfolding: (\ (ds :: Types.Wrd) (ds1 :: Types.Wrd) ->
                 case ds of wild {
                   DEFAULT -> Ops._lt_t2
                   Types.TypeCheck ds2
                   -> let {
                        fail :: GHC.Prim.Void# -> Types.Wrd
                          <join 1> {- Arity: 1, Strictness: <L,A> -}
                        = \ (ds3 :: GHC.Prim.Void#)[OneShot] ->
                          case ds1 of wild1 {
                            DEFAULT -> Ops._lt_t2
                            Types.TypeCheck t2
                            -> Types.Err
                                 (GHC.CString.unpackAppendCString#
                                    Ops._lt_t1
                                    (GHC.Base.++
                                       @ GHC.Types.Char
                                       (Types.$fShowBind_$cshowsPrec1
                                          Types.$fShowBind2
                                          ds2
                                          (GHC.Types.[] @ GHC.Types.Char))
                                       (GHC.CString.unpackAppendCString#
                                          Ops._and_t2
                                          (Types.$fShowBind_$cshowsPrec1
                                             Types.$fShowBind2
                                             t2
                                             (GHC.Types.[] @ GHC.Types.Char))))) }
                      } in
                      case ds2 of wild1 {
                        DEFAULT -> fail GHC.Prim.void#
                        Types.T_Int
                        -> case ds1 of wild2 {
                             DEFAULT -> fail GHC.Prim.void#
                             Types.TypeCheck ds3
                             -> case ds3 of wild3 {
                                  DEFAULT -> fail GHC.Prim.void#
                                  Types.T_Int -> Ops._and_t1
                                  Types.T_Double -> Ops._and_t1 } }
                        Types.T_Double
                        -> case ds1 of wild2 {
                             DEFAULT -> fail GHC.Prim.void#
                             Types.TypeCheck ds3
                             -> case ds3 of wild3 {
                                  DEFAULT -> fail GHC.Prim.void#
                                  Types.T_Int -> Ops._and_t1
                                  Types.T_Double -> Ops._and_t1 } } } }) -}
ad669454c0d29617cb7160243300953c
  _lt_t1 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("`<`: Illegal input type: LHS="#) -}
f13cf934ef7dfae56efd6391bf315353
  _lt_t2 :: Types.Wrd
  {- Strictness: b -}
8a570f44f9ede9d4f31d86264de830b8
  _map :: Types.Op
  {- Strictness: m3, Unfolding: (Types.FuncOp Ops._map1) -}
e4d6aa335075ef53e05ec7ef0c32b34a
  _map0 :: Types.Exp -> Types.Wrd
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ (ds :: [Types.Wrd]) ->
                 let {
                   fail :: GHC.Prim.Void# -> Types.Wrd
                     <join 1> {- Arity: 1, Strictness: <L,A> -}
                   = \ (ds1 :: GHC.Prim.Void#)[OneShot] ->
                     Types.Err
                       (GHC.CString.unpackAppendCString#
                          Ops._map2
                          (case ds of wild {
                             [] -> Ops.toList1
                             : x xs
                             -> GHC.Types.:
                                  @ GHC.Types.Char
                                  GHC.Show.showList__3
                                  (GHC.Base.++
                                     @ GHC.Types.Char
                                     (Types.$fShowBind_$cshow x)
                                     (case Ops.$wshowl xs of ww { (#,#) ww1 ww2 ->
                                      GHC.Types.: @ GHC.Types.Char ww1 ww2 })) }))
                 } in
                 case ds of wild {
                   [] -> fail GHC.Prim.void#
                   : ds1 ds2
                   -> case ds1 of wild1 {
                        DEFAULT -> fail GHC.Prim.void#
                        Types.Func f
                        -> case ds2 of wild2 {
                             [] -> fail GHC.Prim.void#
                             : ds3 ds4
                             -> case ds3 of wild3 {
                                  DEFAULT -> fail GHC.Prim.void#
                                  Types.List ls
                                  -> case ds4 of wild4 {
                                       []
                                       -> Types.PreList
                                            (GHC.Base.map
                                               @ Types.Wrd
                                               @ [Types.Wrd]
                                               (\ (w :: Types.Wrd) ->
                                                GHC.Types.:
                                                  @ Types.Wrd
                                                  wild1
                                                  (GHC.Types.:
                                                     @ Types.Wrd
                                                     w
                                                     (GHC.Types.[] @ Types.Wrd)))
                                               ls)
                                       : ipv ipv1 -> fail GHC.Prim.void# } } } } }) -}
6d1260b15c31039e31bb308506c332dc
  _map1 :: (GHC.Types.Int, Types.Exp -> Types.Wrd)
  {- Strictness: m, Unfolding: ((Ops._map3, Ops._map0)) -}
5a980710633d0031752e33525ab306c7
  _map2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("map: Illegal input value: "#) -}
26cbd2d6ef0999513a82757469e015cc
  _map3 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 2#) -}
a0871b5cad5308036789e4c30dcd1975
  _map_t :: Types.Exp -> Types.Wrd
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ (ds :: [Types.Wrd]) ->
                 let {
                   fail :: GHC.Prim.Void# -> Types.Wrd
                     <join 1> {- Arity: 1, Strictness: <L,A> -}
                   = \ (ds1 :: GHC.Prim.Void#)[OneShot] ->
                     Types.Err
                       (GHC.CString.unpackAppendCString#
                          Ops._map_t2
                          (case ds of wild {
                             [] -> Ops.toList1
                             : x xs
                             -> GHC.Types.:
                                  @ GHC.Types.Char
                                  GHC.Show.showList__3
                                  (GHC.Base.++
                                     @ GHC.Types.Char
                                     (Types.$fShowBind_$cshow x)
                                     (case Ops.$wshowl xs of ww { (#,#) ww1 ww2 ->
                                      GHC.Types.: @ GHC.Types.Char ww1 ww2 })) }))
                 } in
                 case ds of wild {
                   [] -> fail GHC.Prim.void#
                   : ds1 ds2
                   -> case ds1 of wild1 {
                        DEFAULT -> fail GHC.Prim.void#
                        Types.TypeCheck ds3
                        -> case ds3 of wild2 {
                             DEFAULT -> fail GHC.Prim.void#
                             Types.T_Func ds4
                             -> case ds2 of wild3 {
                                  [] -> fail GHC.Prim.void#
                                  : ds5 ds6
                                  -> case ds5 of wild4 {
                                       DEFAULT -> fail GHC.Prim.void#
                                       Types.TypeCheck ds7
                                       -> case ds7 of wild5 {
                                            DEFAULT -> fail GHC.Prim.void#
                                            Types.T_List t
                                            -> case ds6 of wild6 {
                                                 [] -> Ops._map_t1
                                                 : ipv ipv1 -> fail GHC.Prim.void# } } } } } } }) -}
809d5489cfcff84283133afeeec9d63b
  _map_t1 :: Types.Wrd
  {- HasNoCafRefs, Strictness: m18,
     Unfolding: (Types.TypeCheck Types.T_PreList) -}
5666b8c9336195b9a1a82d74f67442c0
  _map_t2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("seq: Illegal input type: "#) -}
d8e49cff69e9b5c75d696ab64d16d0ee
  _mul :: Types.Op
  {- Strictness: m1, Unfolding: (Types.BinOp Ops._mul0) -}
e21899957879cc860f3a9e01ebf09b14
  _mul0 :: Types.Wrd -> Types.Wrd -> Types.Wrd
  {- Arity: 2, Strictness: <S,U><L,U>,
     Unfolding: (\ (ds :: Types.Wrd) (ds1 :: Types.Wrd) ->
                 let {
                   fail :: GHC.Prim.Void# -> Types.Wrd
                     <join 1> {- Arity: 1, Strictness: <L,A> -}
                   = \ (ds2 :: GHC.Prim.Void#)[OneShot] ->
                     Types.Err
                       (GHC.CString.unpackAppendCString#
                          Ops._mul1
                          (GHC.Base.++
                             @ GHC.Types.Char
                             (Types.$fShowBind_$cshow ds)
                             (GHC.CString.unpackAppendCString#
                                Ops._add1
                                (Types.$fShowBind_$cshow ds1))))
                 } in
                 case ds of wild {
                   DEFAULT -> fail GHC.Prim.void#
                   Types.Double x
                   -> case ds1 of wild1 {
                        DEFAULT -> fail GHC.Prim.void#
                        Types.Double y -> Types.Double (GHC.Float.timesDouble x y)
                        Types.Int y
                        -> Types.Double
                             (case x of wild2 { GHC.Types.D# x1 ->
                              case y of wild3 { GHC.Types.I# i ->
                              GHC.Types.D# (GHC.Prim.*## x1 (GHC.Prim.int2Double# i)) } }) }
                   Types.Int x
                   -> case ds1 of wild1 {
                        DEFAULT -> fail GHC.Prim.void#
                        Types.Double y
                        -> Types.Double
                             (case x of wild2 { GHC.Types.I# i ->
                              case y of wild3 { GHC.Types.D# y1 ->
                              GHC.Types.D# (GHC.Prim.*## (GHC.Prim.int2Double# i) y1) } })
                        Types.Int y -> Types.Int (GHC.Num.$fNumInt_$c* x y) } }) -}
872dd2587431d4cda8474aedd8a39577
  _mul1 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("`*`: Illegal input value: x="#) -}
614690b69f01a2495582092fa635b55c
  _mul_t :: Types.Wrd -> Types.Wrd -> Types.Wrd
  {- Arity: 2, Strictness: <S,U><L,U>,
     Unfolding: (\ (ds :: Types.Wrd) (ds1 :: Types.Wrd) ->
                 let {
                   fail :: GHC.Prim.Void# -> Types.Wrd
                     <join 1> {- Arity: 1, Strictness: <L,A> -}
                   = \ (ds2 :: GHC.Prim.Void#)[OneShot] ->
                     Types.Err
                       (GHC.CString.unpackAppendCString#
                          Ops._mul_t1
                          (GHC.Base.++
                             @ GHC.Types.Char
                             (Types.$fShowBind_$cshow ds)
                             (GHC.CString.unpackAppendCString#
                                Ops._add_t6
                                (Types.$fShowBind_$cshow ds1))))
                 } in
                 case ds of wild {
                   DEFAULT -> fail GHC.Prim.void#
                   Types.TypeCheck ds2
                   -> case ds2 of wild1 {
                        DEFAULT -> fail GHC.Prim.void#
                        Types.T_Int
                        -> case ds1 of wild2 {
                             DEFAULT -> fail GHC.Prim.void#
                             Types.TypeCheck ds3
                             -> case ds3 of wild3 {
                                  DEFAULT -> fail GHC.Prim.void#
                                  Types.T_Int -> Ops._add_t5
                                  Types.T_Double -> Ops._add_t4 } }
                        Types.T_Double
                        -> case ds1 of wild2 {
                             DEFAULT -> fail GHC.Prim.void#
                             Types.TypeCheck ds3
                             -> case ds3 of wild3 {
                                  DEFAULT -> fail GHC.Prim.void#
                                  Types.T_Int -> Ops._add_t4
                                  Types.T_Double -> Ops._add_t4 } } } }) -}
3b28df4fd6f5288e63fc840b80fb328a
  _mul_t1 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("`*`: Illegal input type: t_x="#) -}
3cf3b7e7c739d0dfcbc36aab2e3f672e
  _neq :: Types.Op
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (Types.BinOp Ops._neq1) -}
4ecaf62b18e7940ad1197cb34dece61a
  _neq1 :: Types.Wrd -> Types.Wrd -> Types.Wrd
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U><L,1*U>m8,
     Unfolding: InlineRule (2, True, False)
                (\ (a :: Types.Wrd) (b :: Types.Wrd) ->
                 Types.Bool
                   (case Types.$fEqBind_$c==2 a b of wild {
                      GHC.Types.False -> GHC.Types.True
                      GHC.Types.True -> GHC.Types.False })) -}
c98c4cd1f91387bca8a8d3550a01ee78
  _neq_t :: Types.Wrd -> Types.Wrd -> Types.Wrd
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (ds :: Types.Wrd) (ds1 :: Types.Wrd) ->
                 case ds of wild {
                   DEFAULT -> Ops._neq_t2
                   Types.TypeCheck t1
                   -> case ds1 of wild1 {
                        DEFAULT -> Ops._neq_t2
                        Types.TypeCheck t2
                        -> case Types.$fEqBind_$c==1 t1 t2 of wild2 {
                             GHC.Types.False
                             -> Types.Err
                                  (GHC.CString.unpackAppendCString#
                                     Ops._neq_t1
                                     (GHC.Base.++
                                        @ GHC.Types.Char
                                        (Types.$fShowBind_$cshowsPrec1
                                           Types.$fShowBind2
                                           t1
                                           (GHC.Types.[] @ GHC.Types.Char))
                                        (GHC.CString.unpackAppendCString#
                                           Ops._and_t2
                                           (Types.$fShowBind_$cshowsPrec1
                                              Types.$fShowBind2
                                              t2
                                              (GHC.Types.[] @ GHC.Types.Char)))))
                             GHC.Types.True -> Ops._and_t1 } } }) -}
25f61afe81a6cef5b012c00fa422eab8
  _neq_t1 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("`!=`: Wrd mismatch of both sides: LHS="#) -}
4393e764452d50003c80348137b93eec
  _neq_t2 :: Types.Wrd
  {- Strictness: b -}
4994a3036ef01e113f203258eec61f08
  _not :: Types.Op
  {- Strictness: m2, Unfolding: (Types.UnOp Ops._not1) -}
e657d3d5cf9cde2daf82954b596aa71d
  _not1 :: Types.Wrd -> Types.Wrd
  {- Arity: 1, Strictness: <S,1*U>m8,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Types.Wrd) ->
                 case ds of wild {
                   DEFAULT -> Ops._not2
                   Types.Bool b
                   -> Types.Bool
                        (case b of wild1 {
                           GHC.Types.False -> GHC.Types.True
                           GHC.Types.True -> GHC.Types.False }) }) -}
3cc9f4fdfc36e872873e3edfb969dd36
  _not2 :: Types.Wrd
  {- Strictness: b -}
48c8f38dd8f63263b9d8f1a8a3c0ecb8
  _not_t :: Types.Wrd -> Types.Wrd
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: Types.Wrd) ->
                 case ds of wild {
                   DEFAULT -> Ops._not_t2
                   Types.TypeCheck ds1
                   -> case ds1 of wild1 {
                        DEFAULT
                        -> Types.Err
                             (GHC.CString.unpackAppendCString#
                                Ops._not_t1
                                (Types.$fShowBind_$cshowsPrec1
                                   Types.$fShowBind2
                                   wild1
                                   (GHC.Types.[] @ GHC.Types.Char)))
                        Types.T_Bool -> Ops._and_t1 } }) -}
fa61e4f175816c91155851d86c7dc9a6
  _not_t1 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("`!`: Illegal input type: "#) -}
684fd74ead68ea307d44c3cbee16ed93
  _not_t2 :: Types.Wrd
  {- Strictness: b -}
d86f2e063acb94ce4b44e62beb3cdd6e
  _opls :: [Types.StrOp]
  {- Strictness: m2,
     Unfolding: (GHC.Types.: @ Types.StrOp Ops._opls93 Ops._opls1) -}
780181d7f3c24e0f5778250d8310479f
  _opls1 :: [Types.StrOp]
  {- Strictness: m2,
     Unfolding: (GHC.Types.: @ Types.StrOp Ops._opls90 Ops._opls2) -}
e90f2ccb6e1b026aed67e54e56d3104f
  _opls10 :: [Types.StrOp]
  {- Strictness: m2,
     Unfolding: (GHC.Types.: @ Types.StrOp Ops._opls63 Ops._opls11) -}
a3545ceda17e0437e39e37f86899e66c
  _opls11 :: [Types.StrOp]
  {- Strictness: m2,
     Unfolding: (GHC.Types.: @ Types.StrOp Ops._opls60 Ops._opls12) -}
d4bb73ee00e055a417800a068fc36f61
  _opls12 :: [Types.StrOp]
  {- Strictness: m2,
     Unfolding: (GHC.Types.: @ Types.StrOp Ops._opls57 Ops._opls13) -}
009e6483cded296e2b6e85b7b9b1fa16
  _opls13 :: [Types.StrOp]
  {- Strictness: m2,
     Unfolding: (GHC.Types.: @ Types.StrOp Ops._opls54 Ops._opls14) -}
485335f7fcca375fff4dcb66123900f0
  _opls14 :: [Types.StrOp]
  {- Strictness: m2,
     Unfolding: (GHC.Types.: @ Types.StrOp Ops._opls51 Ops._opls15) -}
6dd21a4ad8c2db5195e5661a71327e9d
  _opls15 :: [Types.StrOp]
  {- Strictness: m2,
     Unfolding: (GHC.Types.: @ Types.StrOp Ops._opls48 Ops._opls16) -}
ea0a47cba071d62a2904352fa59d0f47
  _opls16 :: [Types.StrOp]
  {- Strictness: m2,
     Unfolding: (GHC.Types.: @ Types.StrOp Ops._opls45 Ops._opls17) -}
fb16ba160e09f9060050e2d102134a7a
  _opls17 :: [Types.StrOp]
  {- Strictness: m2,
     Unfolding: (GHC.Types.: @ Types.StrOp Ops._opls42 Ops._opls18) -}
a848abc9a8bbc61bc86ea5d88e1082b4
  _opls18 :: [Types.StrOp]
  {- Strictness: m2,
     Unfolding: (GHC.Types.: @ Types.StrOp Ops._opls39 Ops._opls19) -}
c7515c5a994435fac614e065f542af14
  _opls19 :: [Types.StrOp]
  {- Strictness: m2,
     Unfolding: (GHC.Types.: @ Types.StrOp Ops._opls36 Ops._opls20) -}
4decd8779d57fa54fd9715bfd06baa75
  _opls2 :: [Types.StrOp]
  {- Strictness: m2,
     Unfolding: (GHC.Types.: @ Types.StrOp Ops._opls87 Ops._opls3) -}
a2e746668756bd29e8da267276cc2c37
  _opls20 :: [Types.StrOp]
  {- Strictness: m2,
     Unfolding: (GHC.Types.: @ Types.StrOp Ops._opls33 Ops._opls21) -}
2ff07ac7e3bd5248081d1b49d0235a16
  _opls21 :: [Types.StrOp]
  {- Strictness: m2,
     Unfolding: (GHC.Types.: @ Types.StrOp Ops._opls30 Ops._opls22) -}
7aa956e0f916c2a21cbac6704dd5dd0e
  _opls22 :: [Types.StrOp]
  {- Strictness: m2,
     Unfolding: (GHC.Types.: @ Types.StrOp Ops._opls27 Ops._opls23) -}
2451ba16cbe6ac9127a36092c2f6248d
  _opls23 :: [Types.StrOp]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Types.StrOp
                   Ops._opls24
                   (GHC.Types.[] @ Types.StrOp)) -}
4848409e89209d0edae90da3e3a6072b
  _opls24 :: ([GHC.Types.Char], Types.Op)
  {- Strictness: m, Unfolding: ((Ops._opls25, Ops._snd)) -}
b88b8fc9929c1c4af4643d3dd5a72755
  _opls25 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Ops._opls26) -}
f6d6d1045b849e71c2400e298cafe159
  _opls26 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("snd"#) -}
00e88737378008e44ef85713621374b6
  _opls27 :: ([GHC.Types.Char], Types.Op)
  {- Strictness: m, Unfolding: ((Ops._opls28, Ops._fst)) -}
c730c3ad857427250719d9810b3868a0
  _opls28 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Ops._opls29) -}
9a39b858520e54a0ae3292d1cb887f3e
  _opls29 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("fst"#) -}
a4b0ee59bbc2a2539df6a8a695ecc592
  _opls3 :: [Types.StrOp]
  {- Strictness: m2,
     Unfolding: (GHC.Types.: @ Types.StrOp Ops._opls84 Ops._opls4) -}
95e7458d20cc85549fb2f658d3d68461
  _opls30 :: ([GHC.Types.Char], Types.Op)
  {- Strictness: m, Unfolding: ((Ops._opls31, Ops._map)) -}
d097d06a0173844d8f0ed5f15c16af21
  _opls31 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Ops._opls32) -}
20547c1bfb1f11a855800ad592b7d804
  _opls32 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("map"#) -}
d1348dde9ae41187ab37cb9f8eafcdfb
  _opls33 :: ([GHC.Types.Char], Types.Op)
  {- Strictness: m, Unfolding: ((Ops._opls34, Ops._seq)) -}
bef029383f7f054f5dc4d887c23b5308
  _opls34 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Ops._opls35) -}
d0cb0bbb153c2f40d84da7691ad78481
  _opls35 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("seq"#) -}
e63380f0fc0c2f37b2956ea26991f813
  _opls36 :: ([GHC.Types.Char], Types.Op)
  {- Strictness: m, Unfolding: ((Ops._opls37, Ops._take)) -}
bc484a1f13b4457563addcce392fef3a
  _opls37 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Ops._opls38) -}
b00287ca2ad9203459ff29407fe8f4ef
  _opls38 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("take"#) -}
b49f8af01622ff09956b50229cfe6255
  _opls39 :: ([GHC.Types.Char], Types.Op)
  {- Strictness: m, Unfolding: ((Ops._opls40, Ops._isEmpty)) -}
c61f4a12298ab295a4a305638aaefe12
  _opls4 :: [Types.StrOp]
  {- Strictness: m2,
     Unfolding: (GHC.Types.: @ Types.StrOp Ops._opls81 Ops._opls5) -}
6b9dd39b72e6bcba97227a8a571c1675
  _opls40 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Ops._opls41) -}
c362ddada30e4c38c2095049ccb5eded
  _opls41 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("isEmpty"#) -}
8d75f6f61daa0395ee043bfbb261409d
  _opls42 :: ([GHC.Types.Char], Types.Op)
  {- Strictness: m, Unfolding: ((Ops._opls43, Ops._pop)) -}
ab391930ad4b47703e2a372fc33cceeb
  _opls43 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Ops._opls44) -}
adf273349e2eb5c88a12c0f2ca68f6aa
  _opls44 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("pop"#) -}
a795c6a0152eb38714c1f4f4dad06eba
  _opls45 :: ([GHC.Types.Char], Types.Op)
  {- Strictness: m, Unfolding: ((Ops._opls46, Ops._tail)) -}
b46f996224ca64f162de47a2ee3d210b
  _opls46 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Ops._opls47) -}
604b80a69de52eb9631a126ea9bdcbf4
  _opls47 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("tail"#) -}
62f6aa5ba7f1b9cb1915395c4c7d9913
  _opls48 :: ([GHC.Types.Char], Types.Op)
  {- Strictness: m, Unfolding: ((Ops._opls49, Ops._head)) -}
e92fbe548db57e876b4052c9d7c43968
  _opls49 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Ops._opls50) -}
4fce0cd0baf093f439e8b2e594ab9a69
  _opls5 :: [Types.StrOp]
  {- Strictness: m2,
     Unfolding: (GHC.Types.: @ Types.StrOp Ops._opls78 Ops._opls6) -}
f6486a2b694ad4c9c9201bafdc96f49c
  _opls50 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("head"#) -}
0565b899648b6e6bae85fbb6900d580e
  _opls51 :: ([GHC.Types.Char], Types.Op)
  {- Strictness: m, Unfolding: ((Ops._opls52, Ops._succ)) -}
8d538b21620dc8d7ed9271ab6e25155d
  _opls52 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Ops._opls53) -}
55e5ab72180d5c460fdb3239248f9581
  _opls53 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("succ"#) -}
1f1fe1b410f8a67fdf98fd522abda9bc
  _opls54 :: ([GHC.Types.Char], Types.Op)
  {- Strictness: m, Unfolding: ((Ops._opls55, Ops._div)) -}
13f7afebc69a107591209c8572bfb7b3
  _opls55 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Ops._opls56) -}
1e449ce76a81b2bae75a4391fcbe782d
  _opls56 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("/"#) -}
dcc750b2da499828865eb7689d50156b
  _opls57 :: ([GHC.Types.Char], Types.Op)
  {- Strictness: m, Unfolding: ((Ops._opls58, Ops._mul)) -}
86762afb55361060c5c8ee07dc85dc54
  _opls58 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Ops._opls59) -}
830575ddf031d0e4175a79a4d5eb20ad
  _opls59 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("*"#) -}
8b37dfe8405392f485b994cc6fa53550
  _opls6 :: [Types.StrOp]
  {- Strictness: m2,
     Unfolding: (GHC.Types.: @ Types.StrOp Ops._opls75 Ops._opls7) -}
9f36566bd2a3ee80f4656e1ce4e3d5d4
  _opls60 :: ([GHC.Types.Char], Types.Op)
  {- Strictness: m, Unfolding: ((Ops._opls61, Ops._sub)) -}
f26e8fc64340a22e9383ef37347e3a49
  _opls61 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Ops._opls62) -}
6d4847201cfca8adde0a2afe221f6481
  _opls62 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("-"#) -}
3e00ad05831a38bcc72481a335d3250d
  _opls63 :: ([GHC.Types.Char], Types.Op)
  {- Strictness: m, Unfolding: ((Ops._opls64, Ops._add)) -}
ee8849ac7f8733f33453bc48b964ce55
  _opls64 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Ops._opls65) -}
7f465072c7f91da8ce161791cb4eb660
  _opls65 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("+"#) -}
827cf11d437987e80e81674539a12506
  _opls66 :: ([GHC.Types.Char], Types.Op)
  {- Strictness: m, Unfolding: ((Ops._opls67, Ops._leq)) -}
9a5f6895167821d505a7235542ec98b9
  _opls67 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Ops._opls68) -}
b28c0efc2a392a70f53855a5279ec78c
  _opls68 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("<="#) -}
1e72e0846308521d465049c1f5015914
  _opls69 :: ([GHC.Types.Char], Types.Op)
  {- Strictness: m, Unfolding: ((Ops._opls70, Ops._lt)) -}
eeef0c02977de545e5f570d745189ed9
  _opls7 :: [Types.StrOp]
  {- Strictness: m2,
     Unfolding: (GHC.Types.: @ Types.StrOp Ops._opls72 Ops._opls8) -}
d2e9a3240c2f589c49d7826f3a901c4d
  _opls70 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Ops._opls71) -}
117cfd264e23e52794383ec6e0ca1191
  _opls71 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("<"#) -}
3727bc4a8bd1180578b58c882db56c6f
  _opls72 :: ([GHC.Types.Char], Types.Op)
  {- Strictness: m, Unfolding: ((Ops._opls73, Ops._geq)) -}
6509007735eeab324393305a2001de50
  _opls73 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Ops._opls74) -}
3cdadd35db43e0afb722099783af8686
  _opls74 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: (">="#) -}
84440c9981a0fbb0f1f222b9497c6b55
  _opls75 :: ([GHC.Types.Char], Types.Op)
  {- Strictness: m, Unfolding: ((Ops._opls76, Ops._gt)) -}
7274999d9f5eb12b72540e0e5ed864fe
  _opls76 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Ops._opls77) -}
0a32d4011c6818f0a574c8eec8671995
  _opls77 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: (">"#) -}
02231fb387db08471d8826dcad83cc22
  _opls78 :: ([GHC.Types.Char], Types.Op)
  {- Strictness: m, Unfolding: ((Ops._opls79, Ops._neq)) -}
673e2fb7a637aff44195c0b9f16b97ea
  _opls79 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Ops._opls80) -}
4527d5e45413342689182258a50d4c67
  _opls8 :: [Types.StrOp]
  {- Strictness: m2,
     Unfolding: (GHC.Types.: @ Types.StrOp Ops._opls69 Ops._opls9) -}
a97b446e5af557ebc9b461585fc38a03
  _opls80 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("!="#) -}
7a3b3961694eebf292b5769393f44828
  _opls81 :: ([GHC.Types.Char], Types.Op)
  {- Strictness: m, Unfolding: ((Ops._opls82, Ops._eq)) -}
e87650bf00bc7522fbe9a8f17e2dd889
  _opls82 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Ops._opls83) -}
c0ea8113dd5b68bac078f3c6dd253382
  _opls83 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("=="#) -}
aac75561b288e90abed0dc597f1e4a92
  _opls84 :: ([GHC.Types.Char], Types.Op)
  {- Strictness: m, Unfolding: ((Ops._opls85, Ops._not)) -}
1f95dd299eed2d69f11491f6af520b56
  _opls85 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Ops._opls86) -}
eef00eeaee9e7fdbc323d2e4a8f6dce3
  _opls86 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("!"#) -}
2607724c8835890bbcb8e99879494152
  _opls87 :: ([GHC.Types.Char], Types.Op)
  {- Strictness: m, Unfolding: ((Ops._opls88, Ops._and)) -}
3e64020a7ff41fcbc87f39fbeddb2763
  _opls88 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Ops._opls89) -}
d36ef3c7d62a80d628ddd8f05d8465e5
  _opls89 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("&&"#) -}
8f004a3d4e77cbeccbd47c1a866dde36
  _opls9 :: [Types.StrOp]
  {- Strictness: m2,
     Unfolding: (GHC.Types.: @ Types.StrOp Ops._opls66 Ops._opls10) -}
3384440fd9e9184007d115c458bedf81
  _opls90 :: ([GHC.Types.Char], Types.Op)
  {- Strictness: m, Unfolding: ((Ops._opls91, Ops._or)) -}
6dfc362a54503c3d25dbab516cf70894
  _opls91 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Ops._opls92) -}
a94a348462aba4bb2b94ceb983f7215e
  _opls92 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("||"#) -}
d08933d124cbfcbe557f39bb47e2d5d3
  _opls93 :: ([GHC.Types.Char], Types.Op)
  {- Strictness: m, Unfolding: ((Ops._opls94, Ops._print)) -}
62c08972a06d5331db7e28e4470e08fe
  _opls94 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Ops._opls95) -}
0ff339576c251c9fb6e4e5f764ab22c2
  _opls95 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("print"#) -}
6bf4d5616317ad4dbb246754cab7efc9
  _opls_dec :: [Types.StrOp]
  {- Unfolding: (GHC.List.reverse1
                   @ Types.StrOp
                   Ops._opls
                   (GHC.Types.[] @ Types.StrOp)) -}
0d1a3b757b8d222c41f3218f99f20738
  _or :: Types.Op
  {- Strictness: m1, Unfolding: (Types.BinOp Ops._or1) -}
c1e249ed21ccd94709c65047d13cc58a
  _or1 :: Types.Wrd -> Types.Wrd -> Types.Wrd
  {- Arity: 2, Strictness: <S,1*U><S,1*U>m8, Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Types.Wrd) (w1 :: Types.Wrd) ->
                 case w of wild {
                   DEFAULT
                   -> Control.Exception.Base.patError
                        @ 'GHC.Types.LiftedRep
                        @ Types.Wrd
                        Ops._or2
                   Types.Bool a
                   -> case w1 of wild1 {
                        DEFAULT
                        -> Control.Exception.Base.patError
                             @ 'GHC.Types.LiftedRep
                             @ Types.Wrd
                             Ops._or2
                        Types.Bool b
                        -> Types.Bool
                             (case a of wild2 {
                                GHC.Types.False -> b GHC.Types.True -> GHC.Types.True }) } }) -}
19c8cec9d0f561af4b45d78201f1463b
  _or2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("src/Ops.hs:253:14-50|lambda"#) -}
6908699d8e0ea5bc40f18fbf9a0c7a00
  _or_t :: Types.Wrd -> Types.Wrd -> Types.Wrd
  {- Arity: 2, Strictness: <S,1*U><S,U>,
     Unfolding: (\ (ds :: Types.Wrd) (ds1 :: Types.Wrd) ->
                 case ds of wild {
                   DEFAULT -> Ops._or_t2
                   Types.TypeCheck ds2
                   -> let {
                        fail :: GHC.Prim.Void# -> Types.Wrd
                          <join 1> {- Arity: 1, Strictness: <L,A> -}
                        = \ (ds3 :: GHC.Prim.Void#)[OneShot] ->
                          case ds1 of wild1 {
                            DEFAULT -> Ops._or_t2
                            Types.TypeCheck t2
                            -> Types.Err
                                 (GHC.CString.unpackAppendCString#
                                    Ops._or_t1
                                    (GHC.Base.++
                                       @ GHC.Types.Char
                                       (Types.$fShowBind_$cshowsPrec1
                                          Types.$fShowBind2
                                          ds2
                                          (GHC.Types.[] @ GHC.Types.Char))
                                       (GHC.CString.unpackAppendCString#
                                          Ops._and_t2
                                          (Types.$fShowBind_$cshowsPrec1
                                             Types.$fShowBind2
                                             t2
                                             (GHC.Types.[] @ GHC.Types.Char))))) }
                      } in
                      case ds2 of wild1 {
                        DEFAULT -> fail GHC.Prim.void#
                        Types.T_Bool
                        -> case ds1 of wild2 {
                             DEFAULT -> fail GHC.Prim.void#
                             Types.TypeCheck ds3
                             -> case ds3 of wild3 {
                                  DEFAULT -> fail GHC.Prim.void#
                                  Types.T_Bool -> Ops._and_t1 } } } }) -}
856996f8fdef8285cf1f5129fafbb4ef
  _or_t1 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("`||`: Illegal input type: LHS="#) -}
129fd2cfb6aed391ef726af5b5f29609
  _or_t2 :: Types.Wrd
  {- Strictness: b -}
f74146b6986d2f24e32af08a17a0cb8d
  _pop :: Types.Op
  {- Strictness: m2, Unfolding: (Types.UnOp Ops._pop0) -}
78ff3de2a955828d3810b9b234c734f1
  _pop0 :: Types.Wrd -> Types.Wrd
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Types.Wrd) ->
                 case ds of wild {
                   DEFAULT -> Ops._pop4
                   Types.List ds1
                   -> case ds1 of wild1 {
                        [] -> Ops._pop1
                        : x xs
                        -> Types.Tuple
                             (GHC.Types.:
                                @ Types.Wrd
                                x
                                (GHC.Types.:
                                   @ Types.Wrd
                                   (Types.List xs)
                                   (GHC.Types.[] @ Types.Wrd))) } }) -}
096143cf2e129c195e2e7fdbbf75dc42
  _pop1 :: Types.Wrd
  {- Strictness: m12, Unfolding: (Types.Err Ops._pop2) -}
67820d80a490bcd1292746a61771d56a
  _pop2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Ops._pop3) -}
2b468eb485d5183768e6da337648fc34
  _pop3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("pop: Empty list."#) -}
feea901cd6060803d1ef40ae2bfdebba
  _pop4 :: Types.Wrd
  {- Strictness: b -}
8eb46b827bbdd9d4d6a5619009eb6e67
  _pop_t :: Types.Wrd -> Types.Wrd
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: Types.Wrd) ->
                 case ds of wild {
                   DEFAULT -> Ops._pop_t2
                   Types.TypeCheck ds1
                   -> case ds1 of wild1 {
                        DEFAULT
                        -> Types.Err
                             (GHC.CString.unpackAppendCString#
                                Ops._pop_t1
                                (Types.$fShowBind_$cshowsPrec1
                                   Types.$fShowBind2
                                   wild1
                                   (GHC.Types.[] @ GHC.Types.Char)))
                        Types.T_List t
                        -> Types.TypeCheck
                             (Types.T_Tuple
                                (GHC.Types.:
                                   @ Types.Type
                                   t
                                   (GHC.Types.:
                                      @ Types.Type
                                      wild1
                                      (GHC.Types.[] @ Types.Type)))) } }) -}
4ee8181b34bb8af5a603e9b7cd5b63eb
  _pop_t1 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("pop: Illegal input type: "#) -}
d2ed9ea0c6ce9ecb8a02e125ba74a112
  _pop_t2 :: Types.Wrd
  {- Strictness: b -}
59896829b5aa2764f6347abfd56a7914
  _print :: Types.Op
  {- Strictness: m2, Unfolding: (Types.UnOp Ops._print0) -}
a7d8db166e8264be3035052bbc8b2396
  _print0 :: Types.Wrd -> Types.Wrd
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Types.Wrd) ->
                 case ds of wild {
                   DEFAULT -> Types.Print (Types.$fShowBind_$cshow wild)
                   Types.Err e -> Types.Err e }) -}
9bbf503ce6725b8b5d15b8b3769b4b27
  _print_t :: Types.Wrd -> Types.Wrd
  {- Arity: 1, Strictness: <S,1*U>m18,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Types.Wrd) ->
                 case ds of wild {
                   DEFAULT -> Ops._print_t3
                   Types.TypeCheck ds1
                   -> case ds1 of wild1 {
                        DEFAULT -> Ops._print_t2 Types.T_Error -> Ops._print_t1 } }) -}
821397a45bfc366d2f10e609e96c28ae
  _print_t1 :: Types.Wrd
  {- HasNoCafRefs, Strictness: m18,
     Unfolding: (Types.TypeCheck Types.T_Error) -}
f2cd44c874b6894090af7b249afc2caa
  _print_t2 :: Types.Wrd
  {- HasNoCafRefs, Strictness: m18,
     Unfolding: (Types.TypeCheck Types.T_Print) -}
be7342a422bb36ddcde8217442e86e14
  _print_t3 :: Types.Wrd
  {- Strictness: b -}
97867468b3c1a38235eac960f554ccb4
  _seq :: Types.Op
  {- Strictness: m3, Unfolding: (Types.FuncOp Ops._seq1) -}
d5323da05aad0e9c645aaf003eed97b7
  _seq0 :: Types.Exp -> Types.Wrd
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ (ds :: [Types.Wrd]) ->
                 let {
                   fail :: GHC.Prim.Void# -> Types.Wrd
                     <join 1> {- Arity: 1, Strictness: <L,A> -}
                   = \ (ds1 :: GHC.Prim.Void#)[OneShot] ->
                     Types.Err
                       (GHC.CString.unpackAppendCString#
                          Ops._seq2
                          (case ds of wild {
                             [] -> Ops.toList1
                             : x xs
                             -> GHC.Types.:
                                  @ GHC.Types.Char
                                  GHC.Show.showList__3
                                  (GHC.Base.++
                                     @ GHC.Types.Char
                                     (Types.$fShowBind_$cshow x)
                                     (case Ops.$wshowl xs of ww { (#,#) ww1 ww2 ->
                                      GHC.Types.: @ GHC.Types.Char ww1 ww2 })) }))
                 } in
                 case ds of wild {
                   [] -> fail GHC.Prim.void#
                   : ds1 ds2
                   -> case ds1 of wild1 {
                        DEFAULT -> fail GHC.Prim.void#
                        Types.Int n
                        -> case ds2 of wild2 {
                             [] -> fail GHC.Prim.void#
                             : ds3 ds4
                             -> case ds3 of wild3 {
                                  DEFAULT -> fail GHC.Prim.void#
                                  Types.Int m
                                  -> case ds4 of wild4 {
                                       []
                                       -> Types.List
                                            (case n of wild5 { GHC.Types.I# x ->
                                             case m of wild6 { GHC.Types.I# y ->
                                             case GHC.Prim.># x y of lwild {
                                               DEFAULT
                                               -> letrec {
                                                    go :: GHC.Prim.Int# -> [Types.Wrd]
                                                      {- Arity: 1, Strictness: <L,U> -}
                                                    = \ (x1 :: GHC.Prim.Int#) ->
                                                      GHC.Types.:
                                                        @ Types.Wrd
                                                        (Types.Int (GHC.Types.I# x1))
                                                        (case GHC.Prim.==# x1 y of lwild1 {
                                                           DEFAULT -> go (GHC.Prim.+# x1 1#)
                                                           1# -> GHC.Types.[] @ Types.Wrd })
                                                  } in
                                                  go x
                                               1# -> GHC.Types.[] @ Types.Wrd } } })
                                       : ipv ipv1 -> fail GHC.Prim.void# } } } } }) -}
2c79ecf7867be6e9b0fcd45f73e491ee
  _seq1 :: (GHC.Types.Int, Types.Exp -> Types.Wrd)
  {- Strictness: m, Unfolding: ((Ops._map3, Ops._seq0)) -}
459f705f54d958ea106e5d280b7fdd22
  _seq2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("seq: Illegal input value: "#) -}
6b94901691271cf0d6292fcab4489b1f
  _seq_t :: Types.Exp -> Types.Wrd
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ (ds :: [Types.Wrd]) ->
                 let {
                   fail :: GHC.Prim.Void# -> Types.Wrd
                     <join 1> {- Arity: 1, Strictness: <L,A> -}
                   = \ (ds1 :: GHC.Prim.Void#)[OneShot] ->
                     Types.Err
                       (GHC.CString.unpackAppendCString#
                          Ops._map_t2
                          (case ds of wild {
                             [] -> Ops.toList1
                             : x xs
                             -> GHC.Types.:
                                  @ GHC.Types.Char
                                  GHC.Show.showList__3
                                  (GHC.Base.++
                                     @ GHC.Types.Char
                                     (Types.$fShowBind_$cshow x)
                                     (case Ops.$wshowl xs of ww { (#,#) ww1 ww2 ->
                                      GHC.Types.: @ GHC.Types.Char ww1 ww2 })) }))
                 } in
                 case ds of wild {
                   [] -> fail GHC.Prim.void#
                   : ds1 ds2
                   -> case ds1 of wild1 {
                        DEFAULT -> fail GHC.Prim.void#
                        Types.TypeCheck ds3
                        -> case ds3 of wild2 {
                             DEFAULT -> fail GHC.Prim.void#
                             Types.T_Int
                             -> case ds2 of wild3 {
                                  [] -> fail GHC.Prim.void#
                                  : ds4 ds5
                                  -> case ds4 of wild4 {
                                       DEFAULT -> fail GHC.Prim.void#
                                       Types.TypeCheck ds6
                                       -> case ds6 of wild5 {
                                            DEFAULT -> fail GHC.Prim.void#
                                            Types.T_Int
                                            -> case ds5 of wild6 {
                                                 [] -> Ops._seq_t1
                                                 : ipv ipv1 -> fail GHC.Prim.void# } } } } } } }) -}
328691fd0abf14ea1fb62a663314fe0f
  _seq_t1 :: Types.Wrd
  {- HasNoCafRefs, Strictness: m18,
     Unfolding: (Types.TypeCheck Ops._seq_t2) -}
6150290243070a8d0425633c79a1420a
  _seq_t2 :: Types.Type
  {- HasNoCafRefs, Strictness: m10,
     Unfolding: (Types.T_List Types.T_Int) -}
40cb72d194751c81486f0a39e15f16e5
  _snd :: Types.Op
  {- Strictness: m2, Unfolding: (Types.UnOp Ops._snd1) -}
ab7f655f11aa009428f4a39228b1c987
  _snd1 :: Types.Wrd -> Types.Wrd
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: Types.Wrd) ->
                 case ds of wild {
                   DEFAULT -> Ops._snd2
                   Types.Tuple ds1
                   -> case ds1 of wild1 {
                        [] -> Ops._snd2
                        : ds2 ds3
                        -> case ds3 of wild2 { [] -> Ops._snd2 : w2 ds4 -> w2 } } }) -}
f97f638e46ae457d8336a1a206b050ad
  _snd2 :: Types.Wrd
  {- Strictness: b -}
34a45d9c0f3f01b88317fec937d37019
  _snd_t :: Types.Wrd -> Types.Wrd
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: Types.Wrd) ->
                 case ds of wild {
                   DEFAULT
                   -> Types.Err
                        (GHC.CString.unpackAppendCString#
                           Ops._snd_t1
                           (Types.$fShowBind_$cshow wild))
                   Types.TypeCheck ds1
                   -> case ds1 of wild1 {
                        DEFAULT
                        -> Types.Err
                             (GHC.CString.unpackAppendCString#
                                Ops._snd_t1
                                (Types.$fShowBind_$cshow wild))
                        Types.T_Tuple ds2
                        -> case ds2 of wild2 {
                             []
                             -> Types.Err
                                  (GHC.CString.unpackAppendCString#
                                     Ops._snd_t1
                                     (Types.$fShowBind_$cshow wild))
                             : ds3 ds4
                             -> case ds4 of wild3 {
                                  []
                                  -> Types.Err
                                       (GHC.CString.unpackAppendCString#
                                          Ops._snd_t1
                                          (Types.$fShowBind_$cshow wild))
                                  : t ds5 -> Types.TypeCheck t } } } }) -}
fb5fb730789a7a098c792d2650fc4236
  _snd_t1 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("snd: Illegal input type: "#) -}
85224df9a24cbe900299f817409be17f
  _sub :: Types.Op
  {- Strictness: m1, Unfolding: (Types.BinOp Ops._sub0) -}
982b08c7e8e6bf17acda7d615bcd62d1
  _sub0 :: Types.Wrd -> Types.Wrd -> Types.Wrd
  {- Arity: 2, Strictness: <S,U><L,U>,
     Unfolding: (\ (ds :: Types.Wrd) (ds1 :: Types.Wrd) ->
                 let {
                   fail :: GHC.Prim.Void# -> Types.Wrd
                     <join 1> {- Arity: 1, Strictness: <L,A> -}
                   = \ (ds2 :: GHC.Prim.Void#)[OneShot] ->
                     Types.Err
                       (GHC.CString.unpackAppendCString#
                          Ops._sub1
                          (GHC.Base.++
                             @ GHC.Types.Char
                             (Types.$fShowBind_$cshow ds)
                             (GHC.CString.unpackAppendCString#
                                Ops._add1
                                (Types.$fShowBind_$cshow ds1))))
                 } in
                 case ds of wild {
                   DEFAULT -> fail GHC.Prim.void#
                   Types.Double x
                   -> case ds1 of wild1 {
                        DEFAULT -> fail GHC.Prim.void#
                        Types.Double y -> Types.Double (GHC.Float.minusDouble x y)
                        Types.Int y
                        -> Types.Double
                             (case x of wild2 { GHC.Types.D# x1 ->
                              case y of wild3 { GHC.Types.I# i ->
                              GHC.Types.D# (GHC.Prim.-## x1 (GHC.Prim.int2Double# i)) } }) }
                   Types.Int x
                   -> case ds1 of wild1 {
                        DEFAULT -> fail GHC.Prim.void#
                        Types.Double y
                        -> Types.Double
                             (case x of wild2 { GHC.Types.I# i ->
                              case y of wild3 { GHC.Types.D# y1 ->
                              GHC.Types.D# (GHC.Prim.-## (GHC.Prim.int2Double# i) y1) } })
                        Types.Int y -> Types.Int (GHC.Num.$fNumInt_$c- x y) } }) -}
35c261a5b9aaa69c8ef7ad1d509bd398
  _sub1 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("`-`: Illegal input value: x="#) -}
7647ab27e39e51539d6212c2f8f8309b
  _sub_t :: Types.Wrd -> Types.Wrd -> Types.Wrd
  {- Arity: 2, Strictness: <S,U><L,U>,
     Unfolding: (\ (ds :: Types.Wrd) (ds1 :: Types.Wrd) ->
                 let {
                   fail :: GHC.Prim.Void# -> Types.Wrd
                     <join 1> {- Arity: 1, Strictness: <L,A> -}
                   = \ (ds2 :: GHC.Prim.Void#)[OneShot] ->
                     Types.Err
                       (GHC.CString.unpackAppendCString#
                          Ops._sub_t1
                          (GHC.Base.++
                             @ GHC.Types.Char
                             (Types.$fShowBind_$cshow ds)
                             (GHC.CString.unpackAppendCString#
                                Ops._add_t6
                                (Types.$fShowBind_$cshow ds1))))
                 } in
                 case ds of wild {
                   DEFAULT -> fail GHC.Prim.void#
                   Types.TypeCheck ds2
                   -> case ds2 of wild1 {
                        DEFAULT -> fail GHC.Prim.void#
                        Types.T_Int
                        -> case ds1 of wild2 {
                             DEFAULT -> fail GHC.Prim.void#
                             Types.TypeCheck ds3
                             -> case ds3 of wild3 {
                                  DEFAULT -> fail GHC.Prim.void#
                                  Types.T_Int -> Ops._add_t5
                                  Types.T_Double -> Ops._add_t4 } }
                        Types.T_Double
                        -> case ds1 of wild2 {
                             DEFAULT -> fail GHC.Prim.void#
                             Types.TypeCheck ds3
                             -> case ds3 of wild3 {
                                  DEFAULT -> fail GHC.Prim.void#
                                  Types.T_Int -> Ops._add_t4
                                  Types.T_Double -> Ops._add_t4 } } } }) -}
a1f446f17c4d6891251efc4b2fb25dcf
  _sub_t1 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("`-`: Illegal input type: t_x="#) -}
8c7019d6bdc7048340b496fb392e0895
  _succ :: Types.Op
  {- Strictness: m2, Unfolding: (Types.UnOp Ops._succ0) -}
263b03d0bc9e513cdff4e949b54ca757
  _succ0 :: Types.Wrd -> Types.Wrd
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: Types.Wrd) ->
                 case ds of wild {
                   DEFAULT
                   -> Types.Err
                        (GHC.CString.unpackAppendCString#
                           Ops._succ1
                           (Types.$fShowBind_$cshow wild))
                   Types.Double x
                   -> Types.Double
                        (case x of wild1 { GHC.Types.D# x1 ->
                         GHC.Types.D# (GHC.Prim.+## x1 1.0##) })
                   Types.Int x
                   -> Types.Int
                        (case x of wild1 { GHC.Types.I# x1 ->
                         GHC.Types.I# (GHC.Prim.+# x1 1#) }) }) -}
1e1bec2b7d8324d8c8a13fc675c5884a
  _succ1 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("succ: Illegal input value: "#) -}
3772e42a53fcd1b02a264fd1229bde06
  _succ_t :: Types.Wrd -> Types.Wrd
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: Types.Wrd) ->
                 case ds of wild {
                   DEFAULT
                   -> Types.Err
                        (GHC.CString.unpackAppendCString#
                           Ops._succ_t1
                           (Types.$fShowBind_$cshow wild))
                   Types.TypeCheck ds1
                   -> case ds1 of wild1 {
                        DEFAULT
                        -> Types.Err
                             (GHC.CString.unpackAppendCString#
                                Ops._succ_t1
                                (Types.$fShowBind_$cshow wild))
                        Types.T_Int -> Ops._add_t5
                        Types.T_Double -> Ops._add_t4 } }) -}
6b00d16e376d0e6f0254d253382e9977
  _succ_t1 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("succ: Illegal input type: "#) -}
8feadc8c7a9e1d33d049597a1f41b9b2
  _tail :: Types.Op
  {- Strictness: m2, Unfolding: (Types.UnOp Ops._tail0) -}
39c6a8190ccefad69165a6608bb1aca6
  _tail0 :: Types.Wrd -> Types.Wrd
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Types.Wrd) ->
                 case ds of wild {
                   DEFAULT -> Ops._tail4
                   Types.List ds1
                   -> case ds1 of wild1 {
                        [] -> Ops._tail1 : ds2 xs -> Types.List xs } }) -}
4682bc10d98e3a8ea22743c7c8f166c3
  _tail1 :: Types.Wrd
  {- Strictness: m12, Unfolding: (Types.Err Ops._tail2) -}
5b6bde3d420f44567d3b89d1b48068a7
  _tail2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Ops._tail3) -}
7707e6923ff15a353d267fc53e690104
  _tail3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("tail: Empty list."#) -}
a7358c2ca66cb45992b3647f134d697d
  _tail4 :: Types.Wrd
  {- Strictness: b -}
2782328a1be6f268329020823fc8a814
  _tail_t :: Types.Wrd -> Types.Wrd
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: Types.Wrd) ->
                 case ds of wild {
                   DEFAULT -> Ops._tail_t2
                   Types.TypeCheck ds1
                   -> case ds1 of wild1 {
                        DEFAULT
                        -> Types.Err
                             (GHC.CString.unpackAppendCString#
                                Ops._tail_t1
                                (Types.$fShowBind_$cshowsPrec1
                                   Types.$fShowBind2
                                   wild1
                                   (GHC.Types.[] @ GHC.Types.Char)))
                        Types.T_List t -> wild } }) -}
b57e45550d23ed2e01b4e297d7c50947
  _tail_t1 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("tail: Illegal input type: "#) -}
497873be8490efbee1a3738ca937abec
  _tail_t2 :: Types.Wrd
  {- Strictness: b -}
5e0def83df74d395e68ba2dbb4e0b119
  _take :: Types.Op
  {- Strictness: m3, Unfolding: (Types.FuncOp Ops._take1) -}
22a1d8a1498b2747bd38758b48a89e06
  _take0 :: Types.Exp -> Types.Wrd
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ (ds :: [Types.Wrd]) ->
                 let {
                   fail :: GHC.Prim.Void# -> Types.Wrd
                     <join 1> {- Arity: 1, Strictness: <L,A> -}
                   = \ (ds1 :: GHC.Prim.Void#)[OneShot] ->
                     Types.Err
                       (GHC.CString.unpackAppendCString#
                          Ops._take2
                          (case ds of wild {
                             [] -> Ops.toList1
                             : x xs
                             -> GHC.Types.:
                                  @ GHC.Types.Char
                                  GHC.Show.showList__3
                                  (GHC.Base.++
                                     @ GHC.Types.Char
                                     (Types.$fShowBind_$cshow x)
                                     (case Ops.$wshowl xs of ww { (#,#) ww1 ww2 ->
                                      GHC.Types.: @ GHC.Types.Char ww1 ww2 })) }))
                 } in
                 case ds of wild {
                   [] -> fail GHC.Prim.void#
                   : ds1 ds2
                   -> case ds1 of wild1 {
                        DEFAULT -> fail GHC.Prim.void#
                        Types.Int n
                        -> case ds2 of wild2 {
                             [] -> fail GHC.Prim.void#
                             : ds3 ds4
                             -> case ds3 of wild3 {
                                  DEFAULT -> fail GHC.Prim.void#
                                  Types.List ls
                                  -> case ds4 of wild4 {
                                       []
                                       -> Types.List
                                            (case n of wild5 { GHC.Types.I# y ->
                                             case GHC.Prim.<# 0# y of lwild {
                                               DEFAULT -> GHC.Types.[] @ Types.Wrd
                                               1# -> GHC.List.$wunsafeTake @ Types.Wrd y ls } })
                                       : ipv ipv1 -> fail GHC.Prim.void# } } } } }) -}
8db8a13df3688cb3b60e9c6944ec8849
  _take1 :: (GHC.Types.Int, Types.Exp -> Types.Wrd)
  {- Strictness: m, Unfolding: ((Ops._map3, Ops._take0)) -}
dc225380dbafec91e9b60dbf1b066df7
  _take2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("take: Illegal input value: "#) -}
4a1a4b1a09252f5ad3f4f9f2faeb3078
  _take_t :: Types.Exp -> Types.Wrd
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ (ds :: [Types.Wrd]) ->
                 let {
                   fail :: GHC.Prim.Void# -> Types.Wrd
                     <join 1> {- Arity: 1, Strictness: <L,A> -}
                   = \ (ds1 :: GHC.Prim.Void#)[OneShot] ->
                     Types.Err
                       (GHC.CString.unpackAppendCString#
                          Ops._take_t1
                          (case ds of wild {
                             [] -> Ops.toList1
                             : x xs
                             -> GHC.Types.:
                                  @ GHC.Types.Char
                                  GHC.Show.showList__3
                                  (GHC.Base.++
                                     @ GHC.Types.Char
                                     (Types.$fShowBind_$cshow x)
                                     (case Ops.$wshowl xs of ww { (#,#) ww1 ww2 ->
                                      GHC.Types.: @ GHC.Types.Char ww1 ww2 })) }))
                 } in
                 case ds of wild {
                   [] -> fail GHC.Prim.void#
                   : ds1 ds2
                   -> case ds1 of wild1 {
                        DEFAULT -> fail GHC.Prim.void#
                        Types.TypeCheck ds3
                        -> case ds3 of wild2 {
                             DEFAULT -> fail GHC.Prim.void#
                             Types.T_Int
                             -> case ds2 of wild3 {
                                  [] -> fail GHC.Prim.void#
                                  : ds4 ds5
                                  -> case ds4 of wild4 {
                                       DEFAULT -> fail GHC.Prim.void#
                                       Types.TypeCheck ds6
                                       -> case ds6 of wild5 {
                                            DEFAULT -> fail GHC.Prim.void#
                                            Types.T_List t
                                            -> case ds5 of wild6 {
                                                 [] -> wild4
                                                 : ipv ipv1 -> fail GHC.Prim.void# } } } } } } }) -}
9412bd3a2c7ab6d7e81729cb7bf9fb84
  _take_t1 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("take: Illegal input type: "#) -}
8d7df2a6b5d3b9bca57a9d4a834dd5f9
  _typeFunction :: GHC.Base.String -> Types.Op
  {- Arity: 1, Strictness: <S,U> -}
f53f4449bef266b3d07ce3afe393d69f
  isConsistentType :: Types.Exp -> GHC.Types.Bool
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (expr :: Types.Exp) ->
                 case Ops._isConsistentType expr of wild {
                   GHC.Maybe.Nothing -> GHC.Types.False
                   GHC.Maybe.Just a1 -> GHC.Types.True }) -}
3387bddbaface069531d5485507a58dc
  toList :: Types.Exp -> Types.Wrd
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ (expr :: Types.Exp) ->
                 case Ops._isConsistentType expr of wild {
                   GHC.Maybe.Nothing
                   -> Types.Err
                        (GHC.CString.unpackAppendCString#
                           Ops.toList2
                           (case expr of wild1 {
                              [] -> Ops.toList1
                              : x xs
                              -> GHC.Types.:
                                   @ GHC.Types.Char
                                   GHC.Show.showList__3
                                   (GHC.Base.++
                                      @ GHC.Types.Char
                                      (Types.$fShowBind_$cshow x)
                                      (case Ops.$wshowl xs of ww { (#,#) ww1 ww2 ->
                                       GHC.Types.: @ GHC.Types.Char ww1 ww2 })) }))
                   GHC.Maybe.Just a1 -> Types.List expr }) -}
1577133c85b45b42e3461d9132adfe1e
  toList1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackAppendCString#
                   GHC.Show.showList__4
                   (GHC.Types.[] @ GHC.Types.Char)) -}
68cdf96fce1d1672afe67fde5d863d2f
  toList2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("List: Inconsistent type: "#) -}
trusted: none
require own pkg trusted: False
module header:
  Nothing
declaration docs:
arg docs:


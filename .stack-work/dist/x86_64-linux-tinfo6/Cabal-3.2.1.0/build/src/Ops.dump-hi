
==================== FINAL INTERFACE ====================
2021-04-09 04:56:43.7462806 UTC

interface Topos-0.1.0.0-L2hSunVxFDyol1qAzNo2F:Ops 8104
  interface hash: ef8a11b9a42d54efababcfa712030c2a
  ABI hash: 9ccd6b0b2d6b998e873165db1714d518
  export-list hash: 24531ef125d46d1c52ba79243a43b497
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 358a18e1043fc7ac1b015a88503b1325
  opt_hash: cb09a535710eb16767a299f2ded44a31
  hpc_hash: 93b885adfe0da089cdf634904fd59f71
  plugin_hash: ad164012d6b1e14942349d58b1132007
  sig of: Nothing
  used TH splices: False
  where
exports:
  Ops._add
  Ops._add0
  Ops._add_t
  Ops._and
  Ops._and_t
  Ops._div
  Ops._div0
  Ops._div_t
  Ops._eq
  Ops._eq_t
  Ops._fst
  Ops._fst_t
  Ops._geq
  Ops._geq0
  Ops._geq_t
  Ops._getType
  Ops._gt
  Ops._gt0
  Ops._gt_t
  Ops._head
  Ops._head0
  Ops._head_t
  Ops._isConsistentType
  Ops._isEmpty
  Ops._isEmpty_t
  Ops._leq
  Ops._leq0
  Ops._leq_t
  Ops._lt
  Ops._lt0
  Ops._lt_t
  Ops._map
  Ops._map0
  Ops._map_t
  Ops._mul
  Ops._mul0
  Ops._mul_t
  Ops._neq
  Ops._neq_t
  Ops._not
  Ops._not_t
  Ops._opls
  Ops._opls_dec
  Ops._or
  Ops._or_t
  Ops._pop
  Ops._pop0
  Ops._pop_t
  Ops._print
  Ops._print0
  Ops._print_t
  Ops._seq
  Ops._seq0
  Ops._seq_t
  Ops._snd
  Ops._snd_t
  Ops._sub
  Ops._sub0
  Ops._sub_t
  Ops._succ
  Ops._succ0
  Ops._succ_t
  Ops._tail
  Ops._tail0
  Ops._tail_t
  Ops._take
  Ops._take0
  Ops._take_t
  Ops._typeFunction
  Ops.isConsistentType
  Ops.toList
module dependencies: Parser Types
package dependencies: base-4.14.1.0 ghc-prim-0.6.1
                      integer-gmp-1.0.3.0
orphans: base-4.14.1.0:GHC.Float base-4.14.1.0:GHC.Base
family instance modules: base-4.14.1.0:Control.Applicative
                         base-4.14.1.0:Control.Arrow base-4.14.1.0:Data.Functor.Const
                         base-4.14.1.0:Data.Functor.Identity base-4.14.1.0:Data.Monoid
                         base-4.14.1.0:Data.Semigroup.Internal base-4.14.1.0:GHC.Generics
                         base-4.14.1.0:GHC.IO.Exception
import  -/  Parser 3443f1228a5fa43ab36605baa220d75c
  exports: 4e79c2f1fd013aabc39c8f81cd5374c7
import  -/  Types 2870f235e2eecb0b3d25891749dd9b60
  exports: fb3343c70ce167cabb463f2e586dc9ec
  BinOp 248347d51f0d70dee7324f48b9d0a2d1
  Bool 1241c9fc4fc65d256e8c45a8fcd8d7ba
  Double e9e581551e257a870b35d7e222321699
  Err 5729e6192c4942b542d650e149e72f10
  Exp 41e7a32a3a97b64b95a9c2dd25716e8f
  Fun 42a0d5cd29c2177dcdfaca7cd63323dc
  Func 5d1e31720c6814351c1d5fe881a7a5eb
  FuncOp 8397c94a2f2349a2dd9e300a2647eb27
  Function 9a9eb8e4986ec4d109057707af53cf06
  Int 006171945d67657ef6faae9f16159d2e
  List f0bad1f4683a6ff5d4c475bfda9c9085
  Op 41e7a32a3a97b64b95a9c2dd25716e8f
  Operator 6909136eade762426066db644700f71f
  PreList a5b96693bc60e76099302e7495352709
  Print 825c49422af2ec86182c776d0f7f27d2
  Str 5f7be358727990ce68ad5fc089118acd
  StrOp 41e7a32a3a97b64b95a9c2dd25716e8f
  T_Bool b86db244cb09a3e2fe2aedd61bfbee3d
  T_Double 737f6fd67b2db24d3ba875411b000d1a
  T_EmptyList e01c7753fbb038635d5ed713eb9817eb
  T_Error 48873ecd2091bfe3454b88dba812f4c9
  T_Func cd50891eac1225bdba2c21c3e89ab64b
  T_Function af0bd724946c4e4e99d0a5e688bd8bec
  T_Int 8e2d7b1da0251ed5fe76d6e97cedfbca
  T_List ba15cafcb7b312e20336464ba2df5fd6
  T_Operator 4e8715ebb2c8a3afa27ac366a90ea4dd
  T_PreList c1c2e0be950f1f71892ac83babc5ae70
  T_Print dd66a92b4ff8847e7c08a783b6048b63
  T_String c064da13f2e2dde0871e82011fef3383
  T_Tuple b991f1bb08adca19e3581f5caaa8ae73
  T_Type 739eeac08d3659c9bb2735b433dfb87f
  T_Unknown 55a7e4e28907eaeeec59991a84410abf
  Tobe 3e1c049fbf40275e2d316fdeb88ae7b7
  Tuple 787aea3d9ecc843af9c34b94030802d6
  Type 2cf69a7355f245a5f0d937b4915d0db8
  Type 41e7a32a3a97b64b95a9c2dd25716e8f
  TypeCheck 743327823be34d4f772a0b2575b49c47
  UnOp 4de264f457e8ae24d30e2ee9293e99a7
  Wrd 41e7a32a3a97b64b95a9c2dd25716e8f
  args 41e7a32a3a97b64b95a9c2dd25716e8f
  args_t 41e7a32a3a97b64b95a9c2dd25716e8f
  ret 41e7a32a3a97b64b95a9c2dd25716e8f
  ret_t 41e7a32a3a97b64b95a9c2dd25716e8f
  return_t 41e7a32a3a97b64b95a9c2dd25716e8f
import  -/  base-4.14.1.0:Data.List aa48efeea2e877aaa8c12a1a2e589508
import  -/  base-4.14.1.0:Debug.Trace 311b1d0b6fcef7b89debc64460553e8a
import  -/  base-4.14.1.0:GHC.Base ede51775731a544ddfcb02b5a427fd38
import  -/  base-4.14.1.0:GHC.List 7a32e59b6a27bd558cb52809f6fb6df5
import  -/  base-4.14.1.0:GHC.Num 5f3708b0d1d7a8d15017be85d4a06a34
import  -/  base-4.14.1.0:GHC.Real 4d6025ac56d7c23e0804ecdff4f69d75
import  -/  base-4.14.1.0:GHC.Show 57e93b26a19b08606d2ae3a6ff8065f2
import  -/  base-4.14.1.0:Prelude 5c84dfddbb8583fc340ecd15bead164a
import  -/  ghc-prim-0.6.1:GHC.Classes e50fb3f1cbf74ce4d3874442e4300a09
0077ca7edccd6222f88376e346118960
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module Ops.$trModule3 Ops.$trModule1) -}
c0e5d35f6a7bc4656ee570ea88581d20
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Ops.$trModule2) -}
f9b25b5dbdc46f2d265939d718e84bed
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Ops"#) -}
dfcd064acd8070b26ffa8c69c30fddf9
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Ops.$trModule4) -}
ca9bc36dca399398b222432313c4b910
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("Topos-0.1.0.0-L2hSunVxFDyol1qAzNo2F"#) -}
6a222656f57f52efaac9824435a17553
  $wshowl :: [Types.Wrd] -> (# GHC.Types.Char, [GHC.Types.Char] #)
  {- Arity: 1, Strictness: <S,1*U>, Inline: [2] -}
aed145bdd147b3aa48670d02fb84703d
  _add :: Types.Op
  {- Strictness: m1, Unfolding: (Types.BinOp Ops._add0) -}
8847e9ae90b861773782d43145682fa6
  _add0 :: Types.Wrd -> Types.Wrd -> Types.Wrd
  {- Arity: 2, Strictness: <S,U><L,U>,
     Unfolding: (\ (ds :: Types.Wrd) (ds1 :: Types.Wrd) ->
                 let {
                   fail :: GHC.Prim.Void# -> Types.Wrd
                     <join 1> {- Arity: 1, Strictness: <L,A> -}
                   = \ (ds2 :: GHC.Prim.Void#)[OneShot] ->
                     Types.Err
                       (GHC.CString.unpackAppendCString#
                          Ops._add2
                          (GHC.Base.++
                             @ GHC.Types.Char
                             (Types.$fShowBind_$cshow ds)
                             (GHC.CString.unpackAppendCString#
                                Ops._add1
                                (Types.$fShowBind_$cshow ds1))))
                 } in
                 case ds of wild {
                   DEFAULT -> fail GHC.Prim.void#
                   Types.Str s1
                   -> case ds1 of wild1 {
                        DEFAULT -> fail GHC.Prim.void#
                        Types.Str s2 -> Types.Str (GHC.Base.++ @ GHC.Types.Char s1 s2) }
                   Types.Double x
                   -> case ds1 of wild1 {
                        DEFAULT -> fail GHC.Prim.void#
                        Types.Double y -> Types.Double (GHC.Float.plusDouble x y)
                        Types.Int y
                        -> Types.Double
                             (case x of wild2 { GHC.Types.D# x1 ->
                              case y of wild3 { GHC.Types.I# i ->
                              GHC.Types.D# (GHC.Prim.+## x1 (GHC.Prim.int2Double# i)) } }) }
                   Types.Int x
                   -> case ds1 of wild1 {
                        DEFAULT -> fail GHC.Prim.void#
                        Types.Double y
                        -> Types.Double
                             (case x of wild2 { GHC.Types.I# i ->
                              case y of wild3 { GHC.Types.D# y1 ->
                              GHC.Types.D# (GHC.Prim.+## (GHC.Prim.int2Double# i) y1) } })
                        Types.Int y -> Types.Int (GHC.Num.$fNumInt_$c+ x y) }
                   Types.List l1
                   -> case ds1 of wild1 {
                        DEFAULT -> fail GHC.Prim.void#
                        Types.List l2 -> Ops.toList (GHC.Base.++ @ Types.Wrd l1 l2) } }) -}
9a2955ab09703cd32219213c1c5551c7
  _add1 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: (", y="#) -}
a8bc2cb4b2ded22b4496a1fbed2cab76
  _add2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("`+`: Illegal input value: x="#) -}
2e92d9d21e7200c92bab91854baf80d0
  _add_t :: Types.Wrd -> Types.Wrd -> Types.Wrd
  {- Arity: 2, Strictness: <S,U><L,U>,
     Unfolding: (\ (ds :: Types.Wrd) (ds1 :: Types.Wrd) ->
                 let {
                   fail :: GHC.Prim.Void# -> Types.Wrd
                     <join 1> {- Arity: 1, Strictness: <L,A> -}
                   = \ (ds2 :: GHC.Prim.Void#)[OneShot] ->
                     Types.Err
                       (GHC.CString.unpackAppendCString#
                          Ops._add_t7
                          (GHC.Base.++
                             @ GHC.Types.Char
                             (Types.$fShowBind_$cshow ds)
                             (GHC.CString.unpackAppendCString#
                                Ops._add_t6
                                (Types.$fShowBind_$cshow ds1))))
                 } in
                 case ds of wild {
                   DEFAULT -> fail GHC.Prim.void#
                   Types.TypeCheck ds2
                   -> case ds2 of wild1 {
                        DEFAULT -> fail GHC.Prim.void#
                        Types.T_Int
                        -> case ds1 of wild2 {
                             DEFAULT -> fail GHC.Prim.void#
                             Types.TypeCheck ds3
                             -> case ds3 of wild3 {
                                  DEFAULT -> fail GHC.Prim.void#
                                  Types.T_Int -> Ops._add_t5
                                  Types.T_Double -> Ops._add_t4 } }
                        Types.T_Double
                        -> case ds1 of wild2 {
                             DEFAULT -> fail GHC.Prim.void#
                             Types.TypeCheck ds3
                             -> case ds3 of wild3 {
                                  DEFAULT -> fail GHC.Prim.void#
                                  Types.T_Int -> Ops._add_t4
                                  Types.T_Double -> Ops._add_t4 } }
                        Types.T_String
                        -> case ds1 of wild2 {
                             DEFAULT -> fail GHC.Prim.void#
                             Types.TypeCheck ds3
                             -> case ds3 of wild3 {
                                  DEFAULT -> fail GHC.Prim.void# Types.T_String -> Ops._add_t3 } }
                        Types.T_List t1
                        -> case ds1 of wild2 {
                             DEFAULT -> fail GHC.Prim.void#
                             Types.TypeCheck ds3
                             -> case ds3 of wild3 {
                                  DEFAULT -> fail GHC.Prim.void#
                                  Types.T_List t2
                                  -> case Types.$fEqBind_$c==1 t1 t2 of wild4 {
                                       GHC.Types.False
                                       -> Types.Err
                                            (GHC.CString.unpackAppendCString#
                                               Ops._add_t2
                                               (GHC.Base.++
                                                  @ GHC.Types.Char
                                                  (Types.$fShowBind_$cshowsPrec1
                                                     Types.$fShowBind2
                                                     t1
                                                     (GHC.Types.[] @ GHC.Types.Char))
                                                  (GHC.CString.unpackAppendCString#
                                                     Ops._add_t1
                                                     (Types.$fShowBind_$cshowsPrec1
                                                        Types.$fShowBind2
                                                        t2
                                                        (GHC.Types.[] @ GHC.Types.Char)))))
                                       GHC.Types.True -> wild } } } } }) -}
5c8d703e7770c4e8447f48c788ccdb0d
  _add_t1 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: (", t2="#) -}
d3a83146be059780d910ef8ebb52a172
  _add_t2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("`+`: Wrd mismatch of lists: t1="#) -}
1ff1d2522a596192337da198470f08d1
  _add_t3 :: Types.Wrd
  {- HasNoCafRefs, Strictness: m18,
     Unfolding: (Types.TypeCheck Types.T_String) -}
e31089f768d46058027bfb746718801b
  _add_t4 :: Types.Wrd
  {- HasNoCafRefs, Strictness: m18,
     Unfolding: (Types.TypeCheck Types.T_Double) -}
51384bce1096dbab3f5df8587ef090bc
  _add_t5 :: Types.Wrd
  {- HasNoCafRefs, Strictness: m18,
     Unfolding: (Types.TypeCheck Types.T_Int) -}
239af5d931f67d83328a03e6fe09ee73
  _add_t6 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: (", t_y="#) -}
6854d4481a0f7da1f8adb1f67c37d344
  _add_t7 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("`+`: Illegal input type: t_x="#) -}
7393a7111f1d62567db01add28631630
  _and :: Types.Op
  {- Strictness: m1, Unfolding: (Types.BinOp Ops._and1) -}
761f14c91e5005f23186c311f3faadc4
  _and1 :: Types.Wrd -> Types.Wrd -> Types.Wrd
  {- Arity: 2, Strictness: <S,1*U><S,1*U>m8, Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Types.Wrd) (w1 :: Types.Wrd) ->
                 case w of wild {
                   DEFAULT
                   -> Control.Exception.Base.patError
                        @ 'GHC.Types.LiftedRep
                        @ Types.Wrd
                        Ops._and2
                   Types.Bool a
                   -> case w1 of wild1 {
                        DEFAULT
                        -> Control.Exception.Base.patError
                             @ 'GHC.Types.LiftedRep
                             @ Types.Wrd
                             Ops._and2
                        Types.Bool b
                        -> Types.Bool
                             (case a of wild2 {
                                GHC.Types.False -> GHC.Types.False GHC.Types.True -> b }) } }) -}
1f7134b1bcd7b2d76cf3ff28f5e470eb
  _and2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("src/Ops.hs:246:15-51|lambda"#) -}
feb8d3e1dc28bbac0a91580b702d7e51
  _and_t :: Types.Wrd -> Types.Wrd -> Types.Wrd
  {- Arity: 2, Strictness: <S,1*U><S,U>,
     Unfolding: (\ (ds :: Types.Wrd) (ds1 :: Types.Wrd) ->
                 case ds of wild {
                   DEFAULT -> Ops._and_t4
                   Types.TypeCheck ds2
                   -> let {
                        fail :: GHC.Prim.Void# -> Types.Wrd
                          <join 1> {- Arity: 1, Strictness: <L,A> -}
                        = \ (ds3 :: GHC.Prim.Void#)[OneShot] ->
                          case ds1 of wild1 {
                            DEFAULT -> Ops._and_t4
                            Types.TypeCheck t2
                            -> Types.Err
                                 (GHC.CString.unpackAppendCString#
                                    Ops._and_t3
                                    (GHC.Base.++
                                       @ GHC.Types.Char
                                       (Types.$fShowBind_$cshowsPrec1
                                          Types.$fShowBind2
                                          ds2
                                          (GHC.Types.[] @ GHC.Types.Char))
                                       (GHC.CString.unpackAppendCString#
                                          Ops._and_t2
                                          (Types.$fShowBind_$cshowsPrec1
                                             Types.$fShowBind2
                                             t2
                                             (GHC.Types.[] @ GHC.Types.Char))))) }
                      } in
                      case ds2 of wild1 {
                        DEFAULT -> fail GHC.Prim.void#
                        Types.T_Bool
                        -> case ds1 of wild2 {
                             DEFAULT -> fail GHC.Prim.void#
                             Types.TypeCheck ds3
                             -> case ds3 of wild3 {
                                  DEFAULT -> fail GHC.Prim.void#
                                  Types.T_Bool -> Ops._and_t1 } } } }) -}
9abee605ef32f18c7645f7d41f1055c4
  _and_t1 :: Types.Wrd
  {- HasNoCafRefs, Strictness: m18,
     Unfolding: (Types.TypeCheck Types.T_Bool) -}
c14ad5c14b5d2e5fb364d19e075b9eee
  _and_t2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: (", RHS="#) -}
21a5a768a8a30fa169189ca503f4e131
  _and_t3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("`&&`: Illegal input type: LHS="#) -}
353bb4a43bbde43a2562081ad3324b7d
  _and_t4 :: Types.Wrd
  {- Strictness: b -}
215fc1033c75c9712a869c6feed0ad8c
  _div :: Types.Op
  {- Strictness: m1, Unfolding: (Types.BinOp Ops._div0) -}
c7f24128ce96a06c8e28007e599be754
  _div0 :: Types.Wrd -> Types.Wrd -> Types.Wrd
  {- Arity: 2, Strictness: <L,U><S,U>,
     Unfolding: (\ (ds :: Types.Wrd) (ds1 :: Types.Wrd) ->
                 let {
                   fail :: GHC.Prim.Void# -> Types.Wrd
                     <join 1> {- Arity: 1, Strictness: <L,A> -}
                   = \ (ds2 :: GHC.Prim.Void#)[OneShot] ->
                     let {
                       fail1 :: GHC.Prim.Void# -> Types.Wrd
                         <join 1> {- Arity: 1, Strictness: <L,A> -}
                       = \ (ds3 :: GHC.Prim.Void#)[OneShot] ->
                         Types.Err
                           (GHC.CString.unpackAppendCString#
                              Ops._div4
                              (GHC.Base.++
                                 @ GHC.Types.Char
                                 (Types.$fShowBind_$cshow ds)
                                 (GHC.CString.unpackAppendCString#
                                    Ops._add1
                                    (Types.$fShowBind_$cshow ds1))))
                     } in
                     case ds of wild {
                       DEFAULT -> fail1 GHC.Prim.void#
                       Types.Double x
                       -> case ds1 of wild1 {
                            DEFAULT -> fail1 GHC.Prim.void#
                            Types.Double y -> Types.Double (GHC.Float.divideDouble x y)
                            Types.Int y
                            -> Types.Double
                                 (case x of wild2 { GHC.Types.D# x1 ->
                                  case y of wild3 { GHC.Types.I# i ->
                                  case GHC.Prim./##
                                         x1
                                         (GHC.Prim.int2Double# i) of wild4 { DEFAULT ->
                                  GHC.Types.D# wild4 } } }) }
                       Types.Int x
                       -> case ds1 of wild1 {
                            DEFAULT -> fail1 GHC.Prim.void#
                            Types.Double y
                            -> Types.Double
                                 (case x of wild2 { GHC.Types.I# i ->
                                  case y of wild3 { GHC.Types.D# y1 ->
                                  case GHC.Prim./##
                                         (GHC.Prim.int2Double# i)
                                         y1 of wild4 { DEFAULT ->
                                  GHC.Types.D# wild4 } } })
                            Types.Int y
                            -> Types.Double
                                 (case x of wild2 { GHC.Types.I# i ->
                                  case y of wild3 { GHC.Types.I# i1 ->
                                  case GHC.Prim./##
                                         (GHC.Prim.int2Double# i)
                                         (GHC.Prim.int2Double# i1) of wild4 { DEFAULT ->
                                  GHC.Types.D# wild4 } } }) } }
                 } in
                 case ds1 of wild {
                   DEFAULT -> fail GHC.Prim.void#
                   Types.Double ds2
                   -> case ds2 of wild1 { GHC.Types.D# x ->
                      case GHC.Prim.==## x 0.0## of lwild {
                        DEFAULT -> fail GHC.Prim.void# 1# -> Ops._div1 } }
                   Types.Int ds2
                   -> case ds2 of wild1 { GHC.Types.I# ds3 ->
                      case ds3 of ds4 {
                        DEFAULT -> fail GHC.Prim.void# 0# -> Ops._div1 } } }) -}
c7a0deb313bb0c643627b2a368287071
  _div1 :: Types.Wrd
  {- Strictness: m12, Unfolding: (Types.Err Ops._div2) -}
8fca883992df908dfd44fa917f4b0d94
  _div2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Ops._div3) -}
dc79cca681dd9fde60bfc3224e841ebb
  _div3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Zero division error."#) -}
24854537f568b7ddd76b5c1c5f5d12d9
  _div4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("`/`: Illegal input value: x="#) -}
3c3682977b6d4c1153123fdd2d13c9f6
  _div_t :: Types.Wrd -> Types.Wrd -> Types.Wrd
  {- Arity: 2, Strictness: <S,U><L,U>,
     Unfolding: (\ (ds :: Types.Wrd) (ds1 :: Types.Wrd) ->
                 let {
                   fail :: GHC.Prim.Void# -> Types.Wrd
                     <join 1> {- Arity: 1, Strictness: <L,A> -}
                   = \ (ds2 :: GHC.Prim.Void#)[OneShot] ->
                     Types.Err
                       (GHC.CString.unpackAppendCString#
                          Ops._div_t1
                          (GHC.Base.++
                             @ GHC.Types.Char
                             (Types.$fShowBind_$cshow ds)
                             (GHC.CString.unpackAppendCString#
                                Ops._add_t6
                                (Types.$fShowBind_$cshow ds1))))
                 } in
                 case ds of wild {
                   DEFAULT -> fail GHC.Prim.void#
                   Types.TypeCheck ds2
                   -> case ds2 of wild1 {
                        DEFAULT -> fail GHC.Prim.void#
                        Types.T_Int
                        -> case ds1 of wild2 {
                             DEFAULT -> fail GHC.Prim.void#
                             Types.TypeCheck ds3
                             -> case ds3 of wild3 {
                                  DEFAULT -> fail GHC.Prim.void#
                                  Types.T_Int -> Ops._add_t4
                                  Types.T_Double -> Ops._add_t4 } }
                        Types.T_Double
                        -> case ds1 of wild2 {
                             DEFAULT -> fail GHC.Prim.void#
                             Types.TypeCheck ds3
                             -> case ds3 of wild3 {
                                  DEFAULT -> fail GHC.Prim.void#
                                  Types.T_Int -> Ops._add_t4
                                  Types.T_Double -> Ops._add_t4 } } } }) -}
4ccdf900e6414f9d5439cf6f1f1322a6
  _div_t1 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("`/`: Illegal input type: t_x="#) -}
98897850d11ece9baca132720c333054
  _eq :: Types.Op
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (Types.BinOp Ops._eq1) -}
02b6d287caa8d3347aead8cc64219277
  _eq1 :: Types.Wrd -> Types.Wrd -> Types.Wrd
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U><L,1*U>m8,
     Unfolding: InlineRule (2, True, False)
                (\ (a :: Types.Wrd) (b :: Types.Wrd) ->
                 Types.Bool (Types.$fEqBind_$c==2 a b)) -}
08bf420e34e5a00176a7c8b9ecc59fbd
  _eq_t :: Types.Wrd -> Types.Wrd -> Types.Wrd
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (ds :: Types.Wrd) (ds1 :: Types.Wrd) ->
                 case ds of wild {
                   DEFAULT -> Ops._eq_t2
                   Types.TypeCheck t1
                   -> case ds1 of wild1 {
                        DEFAULT -> Ops._eq_t2
                        Types.TypeCheck t2
                        -> case Types.$fEqBind_$c==1 t1 t2 of wild2 {
                             GHC.Types.False
                             -> Types.Err
                                  (GHC.CString.unpackAppendCString#
                                     Ops._eq_t1
                                     (GHC.Base.++
                                        @ GHC.Types.Char
                                        (Types.$fShowBind_$cshowsPrec1
                                           Types.$fShowBind2
                                           t1
                                           (GHC.Types.[] @ GHC.Types.Char))
                                        (GHC.CString.unpackAppendCString#
                                           Ops._and_t2
                                           (Types.$fShowBind_$cshowsPrec1
                                              Types.$fShowBind2
                                              t2
                                              (GHC.Types.[] @ GHC.Types.Char)))))
                             GHC.Types.True -> Ops._and_t1 } } }) -}
0b4c5bafe1abd3d6896f903edaf7e6e6
  _eq_t1 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("`=`: Wrd mismatch of both sides: LHS="#) -}
93d138834db02a17e8d5d1fe6d958275
  _eq_t2 :: Types.Wrd
  {- Strictness: b -}
b15abe61eb08beab401cca352a4a8bbd
  _fst :: Types.Op
  {- Strictness: m2, Unfolding: (Types.UnOp Ops._fst1) -}
81587449fb5ca4097ab3245bd3444a02
  _fst1 :: Types.Wrd -> Types.Wrd
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Types.Wrd) ->
                 case ds of wild {
                   DEFAULT
                   -> Control.Exception.Base.patError
                        @ 'GHC.Types.LiftedRep
                        @ Types.Wrd
                        Ops._fst2
                   Types.Tuple ds1
                   -> case ds1 of wild1 {
                        []
                        -> Control.Exception.Base.patError
                             @ 'GHC.Types.LiftedRep
                             @ Types.Wrd
                             Ops._fst2
                        : w1 ds2 -> w1 } }) -}
891d4cbd35d062601eaf7ec0eb646755
  _fst2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("src/Ops.hs:340:14-37|lambda"#) -}
8e0c15eac112574f20d150266d484758
  _fst_t :: Types.Wrd -> Types.Wrd
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: Types.Wrd) ->
                 case ds of wild {
                   DEFAULT
                   -> Types.Err
                        (GHC.CString.unpackAppendCString#
                           Ops._fst_t1
                           (Types.$fShowBind_$cshow wild))
                   Types.TypeCheck ds1
                   -> case ds1 of wild1 {
                        DEFAULT
                        -> Types.Err
                             (GHC.CString.unpackAppendCString#
                                Ops._fst_t1
                                (Types.$fShowBind_$cshow wild))
                        Types.T_Tuple ds2
                        -> case ds2 of wild2 {
                             []
                             -> Types.Err
                                  (GHC.CString.unpackAppendCString#
                                     Ops._fst_t1
                                     (Types.$fShowBind_$cshow wild))
                             : t ds3 -> Types.TypeCheck t } } }) -}
b6bc0ed9cd47a6358c2ac6aace023af5
  _fst_t1 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("fst: Illegal input type: "#) -}
bfbd72c3e86b01cdd3890f0a4c94d069
  _geq :: Types.Op
  {- Strictness: m1, Unfolding: (Types.BinOp Ops._geq0) -}
c15f97bb7cdf654872dc219c23b5c912
  _geq0 :: Types.Wrd -> Types.Wrd -> Types.Wrd
  {- Arity: 2, Strictness: <S,1*U><S,1*U>m8, Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Types.Wrd) (w1 :: Types.Wrd) ->
                 case w of wild {
                   DEFAULT -> Ops._geq1
                   Types.Double x
                   -> case w1 of wild1 {
                        DEFAULT -> Ops._geq1
                        Types.Double y
                        -> Types.Bool
                             (case x of wild2 { GHC.Types.D# x1 ->
                              case y of wild3 { GHC.Types.D# y1 ->
                              GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.>=## x1 y1) } })
                        Types.Int y
                        -> Types.Bool
                             (case x of wild2 { GHC.Types.D# x1 ->
                              case y of wild3 { GHC.Types.I# i ->
                              GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.>=## x1 (GHC.Prim.int2Double# i)) } }) }
                   Types.Int x
                   -> case w1 of wild1 {
                        DEFAULT -> Ops._geq1
                        Types.Double y
                        -> Types.Bool
                             (case x of wild2 { GHC.Types.I# i ->
                              case y of wild3 { GHC.Types.D# y1 ->
                              GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.>=## (GHC.Prim.int2Double# i) y1) } })
                        Types.Int y -> Types.Bool (GHC.Classes.geInt x y) } }) -}
a7bcb8891f573e49b5a0e06bc847ee12
  _geq1 :: Types.Wrd
  {- Strictness: b -}
ebcbe58eefbb172657035c5cdb93032c
  _geq_t :: Types.Wrd -> Types.Wrd -> Types.Wrd
  {- Arity: 2, Strictness: <S,1*U><S,U>,
     Unfolding: (\ (ds :: Types.Wrd) (ds1 :: Types.Wrd) ->
                 case ds of wild {
                   DEFAULT -> Ops._geq_t2
                   Types.TypeCheck ds2
                   -> let {
                        fail :: GHC.Prim.Void# -> Types.Wrd
                          <join 1> {- Arity: 1, Strictness: <L,A> -}
                        = \ (ds3 :: GHC.Prim.Void#)[OneShot] ->
                          case ds1 of wild1 {
                            DEFAULT -> Ops._geq_t2
                            Types.TypeCheck t2
                            -> Types.Err
                                 (GHC.CString.unpackAppendCString#
                                    Ops._geq_t1
                                    (GHC.Base.++
                                       @ GHC.Types.Char
                                       (Types.$fShowBind_$cshowsPrec1
                                          Types.$fShowBind2
                                          ds2
                                          (GHC.Types.[] @ GHC.Types.Char))
                                       (GHC.CString.unpackAppendCString#
                                          Ops._and_t2
                                          (Types.$fShowBind_$cshowsPrec1
                                             Types.$fShowBind2
                                             t2
                                             (GHC.Types.[] @ GHC.Types.Char))))) }
                      } in
                      case ds2 of wild1 {
                        DEFAULT -> fail GHC.Prim.void#
                        Types.T_Int
                        -> case ds1 of wild2 {
                             DEFAULT -> fail GHC.Prim.void#
                             Types.TypeCheck ds3
                             -> case ds3 of wild3 {
                                  DEFAULT -> fail GHC.Prim.void#
                                  Types.T_Int -> Ops._and_t1
                                  Types.T_Double -> Ops._and_t1 } }
                        Types.T_Double
                        -> case ds1 of wild2 {
                             DEFAULT -> fail GHC.Prim.void#
                             Types.TypeCheck ds3
                             -> case ds3 of wild3 {
                                  DEFAULT -> fail GHC.Prim.void#
                                  Types.T_Int -> Ops._and_t1
                                  Types.T_Double -> Ops._and_t1 } } } }) -}
bd2539ed84360f360a08990f0a8f318d
  _geq_t1 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("`>=`: Illegal input type: LHS="#) -}
12ad9bd199617daac3ff7c9a1f64271a
  _geq_t2 :: Types.Wrd
  {- Strictness: b -}
61ce3e584263fb0db0af18116e87db36
  _getType :: Types.Wrd -> Types.Type
  {- Arity: 1, Strictness: <S,1*U> -}
10c1e554db32cd582e32b2e0fe5474a3
  _gt :: Types.Op
  {- Strictness: m1, Unfolding: (Types.BinOp Ops._gt0) -}
cd2848feb8174d09af958751749a9e7f
  _gt0 :: Types.Wrd -> Types.Wrd -> Types.Wrd
  {- Arity: 2, Strictness: <S,1*U><S,1*U>m8, Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Types.Wrd) (w1 :: Types.Wrd) ->
                 case w of wild {
                   DEFAULT -> Ops._gt1
                   Types.Double x
                   -> case w1 of wild1 {
                        DEFAULT -> Ops._gt1
                        Types.Double y
                        -> Types.Bool
                             (case x of wild2 { GHC.Types.D# x1 ->
                              case y of wild3 { GHC.Types.D# y1 ->
                              GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.>## x1 y1) } })
                        Types.Int y
                        -> Types.Bool
                             (case x of wild2 { GHC.Types.D# x1 ->
                              case y of wild3 { GHC.Types.I# i ->
                              GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.>## x1 (GHC.Prim.int2Double# i)) } }) }
                   Types.Int x
                   -> case w1 of wild1 {
                        DEFAULT -> Ops._gt1
                        Types.Double y
                        -> Types.Bool
                             (case x of wild2 { GHC.Types.I# i ->
                              case y of wild3 { GHC.Types.D# y1 ->
                              GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.>## (GHC.Prim.int2Double# i) y1) } })
                        Types.Int y -> Types.Bool (GHC.Classes.gtInt x y) } }) -}
def8fb29a8458a147dc65ea0a5cf9fdb
  _gt1 :: Types.Wrd
  {- Strictness: b -}
a32901c07b78e5eb028bb5874981efbb
  _gt_t :: Types.Wrd -> Types.Wrd -> Types.Wrd
  {- Arity: 2, Strictness: <S,1*U><S,U>,
     Unfolding: (\ (ds :: Types.Wrd) (ds1 :: Types.Wrd) ->
                 case ds of wild {
                   DEFAULT -> Ops._gt_t2
                   Types.TypeCheck ds2
                   -> let {
                        fail :: GHC.Prim.Void# -> Types.Wrd
                          <join 1> {- Arity: 1, Strictness: <L,A> -}
                        = \ (ds3 :: GHC.Prim.Void#)[OneShot] ->
                          case ds1 of wild1 {
                            DEFAULT -> Ops._gt_t2
                            Types.TypeCheck t2
                            -> Types.Err
                                 (GHC.CString.unpackAppendCString#
                                    Ops._gt_t1
                                    (GHC.Base.++
                                       @ GHC.Types.Char
                                       (Types.$fShowBind_$cshowsPrec1
                                          Types.$fShowBind2
                                          ds2
                                          (GHC.Types.[] @ GHC.Types.Char))
                                       (GHC.CString.unpackAppendCString#
                                          Ops._and_t2
                                          (Types.$fShowBind_$cshowsPrec1
                                             Types.$fShowBind2
                                             t2
                                             (GHC.Types.[] @ GHC.Types.Char))))) }
                      } in
                      case ds2 of wild1 {
                        DEFAULT -> fail GHC.Prim.void#
                        Types.T_Int
                        -> case ds1 of wild2 {
                             DEFAULT -> fail GHC.Prim.void#
                             Types.TypeCheck ds3
                             -> case ds3 of wild3 {
                                  DEFAULT -> fail GHC.Prim.void#
                                  Types.T_Int -> Ops._and_t1
                                  Types.T_Double -> Ops._and_t1 } }
                        Types.T_Double
                        -> case ds1 of wild2 {
                             DEFAULT -> fail GHC.Prim.void#
                             Types.TypeCheck ds3
                             -> case ds3 of wild3 {
                                  DEFAULT -> fail GHC.Prim.void#
                                  Types.T_Int -> Ops._and_t1
                                  Types.T_Double -> Ops._and_t1 } } } }) -}
59092bd74d2d278cba5cfbd0fa9b8e41
  _gt_t1 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("`>`: Illegal input type: LHS="#) -}
a64288728a96aab1a2539f66f472945b
  _gt_t2 :: Types.Wrd
  {- Strictness: b -}
f233998f3319ab14edd46dbf2c786e2d
  _head :: Types.Op
  {- Strictness: m2, Unfolding: (Types.UnOp Ops._head0) -}
6ffb729093c9b4409bce7d14bdb1afe0
  _head0 :: Types.Wrd -> Types.Wrd
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Types.Wrd) ->
                 case ds of wild {
                   DEFAULT -> Ops._head4
                   Types.List ds1
                   -> case ds1 of wild1 { [] -> Ops._head1 : x ds2 -> x } }) -}
543150125bb8e35a15f1e68b296f4fb8
  _head1 :: Types.Wrd
  {- Strictness: m12, Unfolding: (Types.Err Ops._head2) -}
10595b0063f9a03ed93ee60883e08627
  _head2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Ops._head3) -}
3872cd20e640f04e630362819e26fdd3
  _head3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("head: Empty list."#) -}
74047e8d1ea8019d93adb927c2de1942
  _head4 :: Types.Wrd
  {- Strictness: b -}
f6600d36d63907fe704d60e2bbcc68c6
  _head_t :: Types.Wrd -> Types.Wrd
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: Types.Wrd) ->
                 case ds of wild {
                   DEFAULT -> Ops._head_t2
                   Types.TypeCheck ds1
                   -> case ds1 of wild1 {
                        DEFAULT
                        -> Types.Err
                             (GHC.CString.unpackAppendCString#
                                Ops._head_t1
                                (Types.$fShowBind_$cshowsPrec1
                                   Types.$fShowBind2
                                   wild1
                                   (GHC.Types.[] @ GHC.Types.Char)))
                        Types.T_List t -> Types.TypeCheck t } }) -}
341a78104a1baa5a630af1beff815252
  _head_t1 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("head: Illegal input type: "#) -}
96a4f82a79f29e1a1d0a7533dd40340c
  _head_t2 :: Types.Wrd
  {- Strictness: b -}
d9804ac97bdf090501ea00d6b282fce9
  _isConsistentType :: Types.Exp -> GHC.Maybe.Maybe Types.Type
  {- Arity: 1, Strictness: <S,1*U> -}
cef60dfe0de8bf011e8990eb19497bf3
  _isEmpty :: Types.Op
  {- Strictness: m2, Unfolding: (Types.UnOp Ops._isEmpty1) -}
7c2bd0f7a8b861d14bd53fecabbf247c
  _isEmpty1 :: Types.Wrd -> Types.Wrd
  {- Arity: 1, Strictness: <S,1*U>m8,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Types.Wrd) ->
                 case ds of wild {
                   DEFAULT -> Ops._isEmpty2
                   Types.List ls
                   -> Types.Bool
                        (GHC.Classes.$fEq[]_$c==
                           @ Types.Wrd
                           Types.$fEqWrd
                           ls
                           (GHC.Types.[] @ Types.Wrd)) }) -}
27e075af8713c7d1015794b6d9b674b1
  _isEmpty2 :: Types.Wrd
  {- Strictness: b -}
431965d892e2b6a4f09b46963acb9535
  _isEmpty_t :: Types.Wrd -> Types.Wrd
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: Types.Wrd) ->
                 case ds of wild {
                   DEFAULT -> Ops._isEmpty_t2
                   Types.TypeCheck ds1
                   -> case ds1 of wild1 {
                        DEFAULT
                        -> Types.Err
                             (GHC.CString.unpackAppendCString#
                                Ops._isEmpty_t1
                                (Types.$fShowBind_$cshowsPrec1
                                   Types.$fShowBind2
                                   wild1
                                   (GHC.Types.[] @ GHC.Types.Char)))
                        Types.T_List ds2 -> Ops._and_t1 } }) -}
7ee732c9199798439f16df2880508448
  _isEmpty_t1 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("isEmpty: Illegal input type: "#) -}
52a3e13e54ffc52d7274ef5c2a0c958c
  _isEmpty_t2 :: Types.Wrd
  {- Strictness: b -}
ec4a64dacfd74c2e25c459a263bf103b
  _leq :: Types.Op
  {- Strictness: m1, Unfolding: (Types.BinOp Ops._leq0) -}
96580e36e3a3194d2178c5c1399518b7
  _leq0 :: Types.Wrd -> Types.Wrd -> Types.Wrd
  {- Arity: 2, Strictness: <S,1*U><S,1*U>m8, Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Types.Wrd) (w1 :: Types.Wrd) ->
                 case w of wild {
                   DEFAULT -> Ops._leq1
                   Types.Double x
                   -> case w1 of wild1 {
                        DEFAULT -> Ops._leq1
                        Types.Double y
                        -> Types.Bool
                             (case x of wild2 { GHC.Types.D# x1 ->
                              case y of wild3 { GHC.Types.D# y1 ->
                              GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<=## x1 y1) } })
                        Types.Int y
                        -> Types.Bool
                             (case x of wild2 { GHC.Types.D# x1 ->
                              case y of wild3 { GHC.Types.I# i ->
                              GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.<=## x1 (GHC.Prim.int2Double# i)) } }) }
                   Types.Int x
                   -> case w1 of wild1 {
                        DEFAULT -> Ops._leq1
                        Types.Double y
                        -> Types.Bool
                             (case x of wild2 { GHC.Types.I# i ->
                              case y of wild3 { GHC.Types.D# y1 ->
                              GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.<=## (GHC.Prim.int2Double# i) y1) } })
                        Types.Int y -> Types.Bool (GHC.Classes.leInt x y) } }) -}
79df9541b17b07c6d5d51b4ed0f3450e
  _leq1 :: Types.Wrd
  {- Strictness: b -}
ec683e3ce413056a1a07c115d3e93566
  _leq_t :: Types.Wrd -> Types.Wrd -> Types.Wrd
  {- Arity: 2, Strictness: <S,1*U><S,U>,
     Unfolding: (\ (ds :: Types.Wrd) (ds1 :: Types.Wrd) ->
                 case ds of wild {
                   DEFAULT -> Ops._leq_t1
                   Types.TypeCheck ds2
                   -> let {
                        fail :: GHC.Prim.Void# -> Types.Wrd
                          <join 1> {- Arity: 1, Strictness: <L,A> -}
                        = \ (ds3 :: GHC.Prim.Void#)[OneShot] ->
                          case ds1 of wild1 {
                            DEFAULT -> Ops._leq_t1
                            Types.TypeCheck t2
                            -> Types.Err
                                 (GHC.CString.unpackAppendCString#
                                    Ops._geq_t1
                                    (GHC.Base.++
                                       @ GHC.Types.Char
                                       (Types.$fShowBind_$cshowsPrec1
                                          Types.$fShowBind2
                                          ds2
                                          (GHC.Types.[] @ GHC.Types.Char))
                                       (GHC.CString.unpackAppendCString#
                                          Ops._and_t2
                                          (Types.$fShowBind_$cshowsPrec1
                                             Types.$fShowBind2
                                             t2
                                             (GHC.Types.[] @ GHC.Types.Char))))) }
                      } in
                      case ds2 of wild1 {
                        DEFAULT -> fail GHC.Prim.void#
                        Types.T_Int
                        -> case ds1 of wild2 {
                             DEFAULT -> fail GHC.Prim.void#
                             Types.TypeCheck ds3
                             -> case ds3 of wild3 {
                                  DEFAULT -> fail GHC.Prim.void#
                                  Types.T_Int -> Ops._and_t1
                                  Types.T_Double -> Ops._and_t1 } }
                        Types.T_Double
                        -> case ds1 of wild2 {
                             DEFAULT -> fail GHC.Prim.void#
                             Types.TypeCheck ds3
                             -> case ds3 of wild3 {
                                  DEFAULT -> fail GHC.Prim.void#
                                  Types.T_Int -> Ops._and_t1
                                  Types.T_Double -> Ops._and_t1 } } } }) -}
bfde3e222592188fb46b74c1e2e21522
  _leq_t1 :: Types.Wrd
  {- Strictness: b -}
b71937b3e209d9ec203facf934f56aa4
  _lt :: Types.Op
  {- Strictness: m1, Unfolding: (Types.BinOp Ops._lt0) -}
95be6f09728ca03cc43b08ddf7e62d01
  _lt0 :: Types.Wrd -> Types.Wrd -> Types.Wrd
  {- Arity: 2, Strictness: <S,1*U><S,1*U>m8, Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Types.Wrd) (w1 :: Types.Wrd) ->
                 case w of wild {
                   DEFAULT -> Ops._lt1
                   Types.Double x
                   -> case w1 of wild1 {
                        DEFAULT -> Ops._lt1
                        Types.Double y
                        -> Types.Bool
                             (case x of wild2 { GHC.Types.D# x1 ->
                              case y of wild3 { GHC.Types.D# y1 ->
                              GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<## x1 y1) } })
                        Types.Int y
                        -> Types.Bool
                             (case x of wild2 { GHC.Types.D# x1 ->
                              case y of wild3 { GHC.Types.I# i ->
                              GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.<## x1 (GHC.Prim.int2Double# i)) } }) }
                   Types.Int x
                   -> case w1 of wild1 {
                        DEFAULT -> Ops._lt1
                        Types.Double y
                        -> Types.Bool
                             (case x of wild2 { GHC.Types.I# i ->
                              case y of wild3 { GHC.Types.D# y1 ->
                              GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.<## (GHC.Prim.int2Double# i) y1) } })
                        Types.Int y -> Types.Bool (GHC.Classes.ltInt x y) } }) -}
1bb107a6397e7a6f0ff5bca225cc2d0a
  _lt1 :: Types.Wrd
  {- Strictness: b -}
30dae757c9b8f9ce3df8a767799a55b2
  _lt_t :: Types.Wrd -> Types.Wrd -> Types.Wrd
  {- Arity: 2, Strictness: <S,1*U><S,U>,
     Unfolding: (\ (ds :: Types.Wrd) (ds1 :: Types.Wrd) ->
                 case ds of wild {
                   DEFAULT -> Ops._lt_t2
                   Types.TypeCheck ds2
                   -> let {
                        fail :: GHC.Prim.Void# -> Types.Wrd
                          <join 1> {- Arity: 1, Strictness: <L,A> -}
                        = \ (ds3 :: GHC.Prim.Void#)[OneShot] ->
                          case ds1 of wild1 {
                            DEFAULT -> Ops._lt_t2
                            Types.TypeCheck t2
                            -> Types.Err
                                 (GHC.CString.unpackAppendCString#
                                    Ops._lt_t1
                                    (GHC.Base.++
                                       @ GHC.Types.Char
                                       (Types.$fShowBind_$cshowsPrec1
                                          Types.$fShowBind2
                                          ds2
                                          (GHC.Types.[] @ GHC.Types.Char))
                                       (GHC.CString.unpackAppendCString#
                                          Ops._and_t2
                                          (Types.$fShowBind_$cshowsPrec1
                                             Types.$fShowBind2
                                             t2
                                             (GHC.Types.[] @ GHC.Types.Char))))) }
                      } in
                      case ds2 of wild1 {
                        DEFAULT -> fail GHC.Prim.void#
                        Types.T_Int
                        -> case ds1 of wild2 {
                             DEFAULT -> fail GHC.Prim.void#
                             Types.TypeCheck ds3
                             -> case ds3 of wild3 {
                                  DEFAULT -> fail GHC.Prim.void#
                                  Types.T_Int -> Ops._and_t1
                                  Types.T_Double -> Ops._and_t1 } }
                        Types.T_Double
                        -> case ds1 of wild2 {
                             DEFAULT -> fail GHC.Prim.void#
                             Types.TypeCheck ds3
                             -> case ds3 of wild3 {
                                  DEFAULT -> fail GHC.Prim.void#
                                  Types.T_Int -> Ops._and_t1
                                  Types.T_Double -> Ops._and_t1 } } } }) -}
ad669454c0d29617cb7160243300953c
  _lt_t1 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("`<`: Illegal input type: LHS="#) -}
cf39bbdd99966e42cb93443d967ea025
  _lt_t2 :: Types.Wrd
  {- Strictness: b -}
5e61e4c8c5e4279be0fdd31f9f6c4649
  _map :: Types.Op
  {- Strictness: m3, Unfolding: (Types.FuncOp Ops._map1) -}
41bf598ee21cf0654b76bf275279c65f
  _map0 :: Types.Exp -> Types.Wrd
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ (ds :: [Types.Wrd]) ->
                 let {
                   fail :: GHC.Prim.Void# -> Types.Wrd
                     <join 1> {- Arity: 1, Strictness: <L,A> -}
                   = \ (ds1 :: GHC.Prim.Void#)[OneShot] ->
                     Types.Err
                       (GHC.CString.unpackAppendCString#
                          Ops._map2
                          (case ds of wild {
                             [] -> Ops.toList1
                             : x xs
                             -> GHC.Types.:
                                  @ GHC.Types.Char
                                  GHC.Show.showList__3
                                  (GHC.Base.++
                                     @ GHC.Types.Char
                                     (Types.$fShowBind_$cshow x)
                                     (case Ops.$wshowl xs of ww { (#,#) ww1 ww2 ->
                                      GHC.Types.: @ GHC.Types.Char ww1 ww2 })) }))
                 } in
                 case ds of wild {
                   [] -> fail GHC.Prim.void#
                   : ds1 ds2
                   -> case ds1 of wild1 {
                        DEFAULT -> fail GHC.Prim.void#
                        Types.Func f
                        -> case ds2 of wild2 {
                             [] -> fail GHC.Prim.void#
                             : ds3 ds4
                             -> case ds3 of wild3 {
                                  DEFAULT -> fail GHC.Prim.void#
                                  Types.List ls
                                  -> case ds4 of wild4 {
                                       []
                                       -> Types.PreList
                                            (GHC.Base.map
                                               @ Types.Wrd
                                               @ [Types.Wrd]
                                               (\ (w :: Types.Wrd) ->
                                                GHC.Types.:
                                                  @ Types.Wrd
                                                  wild1
                                                  (GHC.Types.:
                                                     @ Types.Wrd
                                                     w
                                                     (GHC.Types.[] @ Types.Wrd)))
                                               ls)
                                       : ipv ipv1 -> fail GHC.Prim.void# } } } } }) -}
38514ef66db8038c6afa23e1d444abf2
  _map1 :: (GHC.Types.Int, Types.Exp -> Types.Wrd)
  {- Strictness: m, Unfolding: ((Ops._map3, Ops._map0)) -}
5a980710633d0031752e33525ab306c7
  _map2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("map: Illegal input value: "#) -}
26cbd2d6ef0999513a82757469e015cc
  _map3 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 2#) -}
b72c2548240667c5067939ef45ec7369
  _map_t :: Types.Exp -> Types.Wrd
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ (ds :: [Types.Wrd]) ->
                 let {
                   fail :: GHC.Prim.Void# -> Types.Wrd
                     <join 1> {- Arity: 1, Strictness: <L,A> -}
                   = \ (ds1 :: GHC.Prim.Void#)[OneShot] ->
                     Types.Err
                       (GHC.CString.unpackAppendCString#
                          Ops._map_t2
                          (case ds of wild {
                             [] -> Ops.toList1
                             : x xs
                             -> GHC.Types.:
                                  @ GHC.Types.Char
                                  GHC.Show.showList__3
                                  (GHC.Base.++
                                     @ GHC.Types.Char
                                     (Types.$fShowBind_$cshow x)
                                     (case Ops.$wshowl xs of ww { (#,#) ww1 ww2 ->
                                      GHC.Types.: @ GHC.Types.Char ww1 ww2 })) }))
                 } in
                 case ds of wild {
                   [] -> fail GHC.Prim.void#
                   : ds1 ds2
                   -> case ds1 of wild1 {
                        DEFAULT -> fail GHC.Prim.void#
                        Types.TypeCheck ds3
                        -> case ds3 of wild2 {
                             DEFAULT -> fail GHC.Prim.void#
                             Types.T_Func ds4
                             -> case ds2 of wild3 {
                                  [] -> fail GHC.Prim.void#
                                  : ds5 ds6
                                  -> case ds5 of wild4 {
                                       DEFAULT -> fail GHC.Prim.void#
                                       Types.TypeCheck ds7
                                       -> case ds7 of wild5 {
                                            DEFAULT -> fail GHC.Prim.void#
                                            Types.T_List t
                                            -> case ds6 of wild6 {
                                                 [] -> Ops._map_t1
                                                 : ipv ipv1 -> fail GHC.Prim.void# } } } } } } }) -}
8a5f87431d1f11d7bf62df526ba8a76a
  _map_t1 :: Types.Wrd
  {- HasNoCafRefs, Strictness: m18,
     Unfolding: (Types.TypeCheck Types.T_PreList) -}
5666b8c9336195b9a1a82d74f67442c0
  _map_t2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("seq: Illegal input type: "#) -}
a051d9f308344f05a608d3aeddadf2b9
  _mul :: Types.Op
  {- Strictness: m1, Unfolding: (Types.BinOp Ops._mul0) -}
46a2cbf47aa9c055cdb44a3798ddcc6a
  _mul0 :: Types.Wrd -> Types.Wrd -> Types.Wrd
  {- Arity: 2, Strictness: <S,U><L,U>,
     Unfolding: (\ (ds :: Types.Wrd) (ds1 :: Types.Wrd) ->
                 let {
                   fail :: GHC.Prim.Void# -> Types.Wrd
                     <join 1> {- Arity: 1, Strictness: <L,A> -}
                   = \ (ds2 :: GHC.Prim.Void#)[OneShot] ->
                     Types.Err
                       (GHC.CString.unpackAppendCString#
                          Ops._mul1
                          (GHC.Base.++
                             @ GHC.Types.Char
                             (Types.$fShowBind_$cshow ds)
                             (GHC.CString.unpackAppendCString#
                                Ops._add1
                                (Types.$fShowBind_$cshow ds1))))
                 } in
                 case ds of wild {
                   DEFAULT -> fail GHC.Prim.void#
                   Types.Double x
                   -> case ds1 of wild1 {
                        DEFAULT -> fail GHC.Prim.void#
                        Types.Double y -> Types.Double (GHC.Float.timesDouble x y)
                        Types.Int y
                        -> Types.Double
                             (case x of wild2 { GHC.Types.D# x1 ->
                              case y of wild3 { GHC.Types.I# i ->
                              GHC.Types.D# (GHC.Prim.*## x1 (GHC.Prim.int2Double# i)) } }) }
                   Types.Int x
                   -> case ds1 of wild1 {
                        DEFAULT -> fail GHC.Prim.void#
                        Types.Double y
                        -> Types.Double
                             (case x of wild2 { GHC.Types.I# i ->
                              case y of wild3 { GHC.Types.D# y1 ->
                              GHC.Types.D# (GHC.Prim.*## (GHC.Prim.int2Double# i) y1) } })
                        Types.Int y -> Types.Int (GHC.Num.$fNumInt_$c* x y) } }) -}
872dd2587431d4cda8474aedd8a39577
  _mul1 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("`*`: Illegal input value: x="#) -}
ff8705e11c17fc62e66b809c0b3a1db0
  _mul_t :: Types.Wrd -> Types.Wrd -> Types.Wrd
  {- Arity: 2, Strictness: <S,U><L,U>,
     Unfolding: (\ (ds :: Types.Wrd) (ds1 :: Types.Wrd) ->
                 let {
                   fail :: GHC.Prim.Void# -> Types.Wrd
                     <join 1> {- Arity: 1, Strictness: <L,A> -}
                   = \ (ds2 :: GHC.Prim.Void#)[OneShot] ->
                     Types.Err
                       (GHC.CString.unpackAppendCString#
                          Ops._mul_t1
                          (GHC.Base.++
                             @ GHC.Types.Char
                             (Types.$fShowBind_$cshow ds)
                             (GHC.CString.unpackAppendCString#
                                Ops._add_t6
                                (Types.$fShowBind_$cshow ds1))))
                 } in
                 case ds of wild {
                   DEFAULT -> fail GHC.Prim.void#
                   Types.TypeCheck ds2
                   -> case ds2 of wild1 {
                        DEFAULT -> fail GHC.Prim.void#
                        Types.T_Int
                        -> case ds1 of wild2 {
                             DEFAULT -> fail GHC.Prim.void#
                             Types.TypeCheck ds3
                             -> case ds3 of wild3 {
                                  DEFAULT -> fail GHC.Prim.void#
                                  Types.T_Int -> Ops._add_t5
                                  Types.T_Double -> Ops._add_t4 } }
                        Types.T_Double
                        -> case ds1 of wild2 {
                             DEFAULT -> fail GHC.Prim.void#
                             Types.TypeCheck ds3
                             -> case ds3 of wild3 {
                                  DEFAULT -> fail GHC.Prim.void#
                                  Types.T_Int -> Ops._add_t4
                                  Types.T_Double -> Ops._add_t4 } } } }) -}
3b28df4fd6f5288e63fc840b80fb328a
  _mul_t1 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("`*`: Illegal input type: t_x="#) -}
d79823e22df75a44684136c59c88058c
  _neq :: Types.Op
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (Types.BinOp Ops._neq1) -}
3edca622fdecbfe802460f4f3bde2480
  _neq1 :: Types.Wrd -> Types.Wrd -> Types.Wrd
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U><L,1*U>m8,
     Unfolding: InlineRule (2, True, False)
                (\ (a :: Types.Wrd) (b :: Types.Wrd) ->
                 Types.Bool
                   (case Types.$fEqBind_$c==2 a b of wild {
                      GHC.Types.False -> GHC.Types.True
                      GHC.Types.True -> GHC.Types.False })) -}
e486db333126873a6b1d30b0e78e94e3
  _neq_t :: Types.Wrd -> Types.Wrd -> Types.Wrd
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (ds :: Types.Wrd) (ds1 :: Types.Wrd) ->
                 case ds of wild {
                   DEFAULT -> Ops._neq_t2
                   Types.TypeCheck t1
                   -> case ds1 of wild1 {
                        DEFAULT -> Ops._neq_t2
                        Types.TypeCheck t2
                        -> case Types.$fEqBind_$c==1 t1 t2 of wild2 {
                             GHC.Types.False
                             -> Types.Err
                                  (GHC.CString.unpackAppendCString#
                                     Ops._neq_t1
                                     (GHC.Base.++
                                        @ GHC.Types.Char
                                        (Types.$fShowBind_$cshowsPrec1
                                           Types.$fShowBind2
                                           t1
                                           (GHC.Types.[] @ GHC.Types.Char))
                                        (GHC.CString.unpackAppendCString#
                                           Ops._and_t2
                                           (Types.$fShowBind_$cshowsPrec1
                                              Types.$fShowBind2
                                              t2
                                              (GHC.Types.[] @ GHC.Types.Char)))))
                             GHC.Types.True -> Ops._and_t1 } } }) -}
25f61afe81a6cef5b012c00fa422eab8
  _neq_t1 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("`!=`: Wrd mismatch of both sides: LHS="#) -}
90b7cd80c0bc7e4f9eb8ef00ebbef7ed
  _neq_t2 :: Types.Wrd
  {- Strictness: b -}
a65510cb8f47ae923832075fd1a89342
  _not :: Types.Op
  {- Strictness: m2, Unfolding: (Types.UnOp Ops._not1) -}
2e32f8b1bef196b54e178f31838f20a8
  _not1 :: Types.Wrd -> Types.Wrd
  {- Arity: 1, Strictness: <S,1*U>m8,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Types.Wrd) ->
                 case ds of wild {
                   DEFAULT -> Ops._not2
                   Types.Bool b
                   -> Types.Bool
                        (case b of wild1 {
                           GHC.Types.False -> GHC.Types.True
                           GHC.Types.True -> GHC.Types.False }) }) -}
0aeec3e4c926e0927fdd8b1e5332a6f3
  _not2 :: Types.Wrd
  {- Strictness: b -}
d5ef90f6c2e9cc24b4d26b4d99048ee9
  _not_t :: Types.Wrd -> Types.Wrd
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: Types.Wrd) ->
                 case ds of wild {
                   DEFAULT -> Ops._not_t2
                   Types.TypeCheck ds1
                   -> case ds1 of wild1 {
                        DEFAULT
                        -> Types.Err
                             (GHC.CString.unpackAppendCString#
                                Ops._not_t1
                                (Types.$fShowBind_$cshowsPrec1
                                   Types.$fShowBind2
                                   wild1
                                   (GHC.Types.[] @ GHC.Types.Char)))
                        Types.T_Bool -> Ops._and_t1 } }) -}
fa61e4f175816c91155851d86c7dc9a6
  _not_t1 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("`!`: Illegal input type: "#) -}
b7a68909212e0e8ff386eae137cde6b6
  _not_t2 :: Types.Wrd
  {- Strictness: b -}
e818ece1458be5a239b38177a8de4882
  _opls :: [Types.StrOp]
  {- Strictness: m2,
     Unfolding: (GHC.Types.: @ Types.StrOp Ops._opls93 Ops._opls1) -}
d53cb77b9c5a5467b8e4b87d5c5a0175
  _opls1 :: [Types.StrOp]
  {- Strictness: m2,
     Unfolding: (GHC.Types.: @ Types.StrOp Ops._opls90 Ops._opls2) -}
bacc4c811bbcf9dc2e9eb957b778ca7c
  _opls10 :: [Types.StrOp]
  {- Strictness: m2,
     Unfolding: (GHC.Types.: @ Types.StrOp Ops._opls63 Ops._opls11) -}
bdf6d0b9258e19ee8c7282d3221729fb
  _opls11 :: [Types.StrOp]
  {- Strictness: m2,
     Unfolding: (GHC.Types.: @ Types.StrOp Ops._opls60 Ops._opls12) -}
d8bf223fbf13b5f204ccb46a9ede15ff
  _opls12 :: [Types.StrOp]
  {- Strictness: m2,
     Unfolding: (GHC.Types.: @ Types.StrOp Ops._opls57 Ops._opls13) -}
afb5781d064c4931bc0f17c2385a8324
  _opls13 :: [Types.StrOp]
  {- Strictness: m2,
     Unfolding: (GHC.Types.: @ Types.StrOp Ops._opls54 Ops._opls14) -}
5f4c92b5c0e79c414e7ceabec3f9d8b9
  _opls14 :: [Types.StrOp]
  {- Strictness: m2,
     Unfolding: (GHC.Types.: @ Types.StrOp Ops._opls51 Ops._opls15) -}
c500f46fe69e5ea89f99b6f99f491a24
  _opls15 :: [Types.StrOp]
  {- Strictness: m2,
     Unfolding: (GHC.Types.: @ Types.StrOp Ops._opls48 Ops._opls16) -}
d26ae9ccf42ebc75d713d821fe00dbcf
  _opls16 :: [Types.StrOp]
  {- Strictness: m2,
     Unfolding: (GHC.Types.: @ Types.StrOp Ops._opls45 Ops._opls17) -}
0f38d104f73de9e6a782ea7ba57c5685
  _opls17 :: [Types.StrOp]
  {- Strictness: m2,
     Unfolding: (GHC.Types.: @ Types.StrOp Ops._opls42 Ops._opls18) -}
97e7424e8319b4900bb4f276232f88e8
  _opls18 :: [Types.StrOp]
  {- Strictness: m2,
     Unfolding: (GHC.Types.: @ Types.StrOp Ops._opls39 Ops._opls19) -}
9b713514c6bb6194a5fe60218529b755
  _opls19 :: [Types.StrOp]
  {- Strictness: m2,
     Unfolding: (GHC.Types.: @ Types.StrOp Ops._opls36 Ops._opls20) -}
e0b7c837aba0b9a35b8aecd9557d5295
  _opls2 :: [Types.StrOp]
  {- Strictness: m2,
     Unfolding: (GHC.Types.: @ Types.StrOp Ops._opls87 Ops._opls3) -}
9457b86f1ae4c08754956e13624dbe1a
  _opls20 :: [Types.StrOp]
  {- Strictness: m2,
     Unfolding: (GHC.Types.: @ Types.StrOp Ops._opls33 Ops._opls21) -}
f2ce498fe17c81201e51220289c62ea3
  _opls21 :: [Types.StrOp]
  {- Strictness: m2,
     Unfolding: (GHC.Types.: @ Types.StrOp Ops._opls30 Ops._opls22) -}
9d06a8b6d33a1b1ad82a1ba6b348c0ce
  _opls22 :: [Types.StrOp]
  {- Strictness: m2,
     Unfolding: (GHC.Types.: @ Types.StrOp Ops._opls27 Ops._opls23) -}
1c2b1f1f87704ab211eee93f62ec2260
  _opls23 :: [Types.StrOp]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Types.StrOp
                   Ops._opls24
                   (GHC.Types.[] @ Types.StrOp)) -}
41f88bfcda951febd56de5e6c690f1e6
  _opls24 :: ([GHC.Types.Char], Types.Op)
  {- Strictness: m, Unfolding: ((Ops._opls25, Ops._snd)) -}
b88b8fc9929c1c4af4643d3dd5a72755
  _opls25 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Ops._opls26) -}
f6d6d1045b849e71c2400e298cafe159
  _opls26 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("snd"#) -}
40eb1b594347f031f6730e727c769ac8
  _opls27 :: ([GHC.Types.Char], Types.Op)
  {- Strictness: m, Unfolding: ((Ops._opls28, Ops._fst)) -}
c730c3ad857427250719d9810b3868a0
  _opls28 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Ops._opls29) -}
9a39b858520e54a0ae3292d1cb887f3e
  _opls29 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("fst"#) -}
dc8350876585a8758bc992682f91711e
  _opls3 :: [Types.StrOp]
  {- Strictness: m2,
     Unfolding: (GHC.Types.: @ Types.StrOp Ops._opls84 Ops._opls4) -}
53419e64df36ad0d3e79dac58f859528
  _opls30 :: ([GHC.Types.Char], Types.Op)
  {- Strictness: m, Unfolding: ((Ops._opls31, Ops._map)) -}
d097d06a0173844d8f0ed5f15c16af21
  _opls31 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Ops._opls32) -}
20547c1bfb1f11a855800ad592b7d804
  _opls32 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("map"#) -}
56969dfdf87eb4902a5abbc4186328db
  _opls33 :: ([GHC.Types.Char], Types.Op)
  {- Strictness: m, Unfolding: ((Ops._opls34, Ops._seq)) -}
bef029383f7f054f5dc4d887c23b5308
  _opls34 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Ops._opls35) -}
d0cb0bbb153c2f40d84da7691ad78481
  _opls35 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("seq"#) -}
46fb8e45faad3600d1980fe53d8ad995
  _opls36 :: ([GHC.Types.Char], Types.Op)
  {- Strictness: m, Unfolding: ((Ops._opls37, Ops._take)) -}
bc484a1f13b4457563addcce392fef3a
  _opls37 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Ops._opls38) -}
b00287ca2ad9203459ff29407fe8f4ef
  _opls38 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("take"#) -}
19f16a089e67ef0ba53a997a6642c74e
  _opls39 :: ([GHC.Types.Char], Types.Op)
  {- Strictness: m, Unfolding: ((Ops._opls40, Ops._isEmpty)) -}
bee11b24f2c3f98649acfa952ae52026
  _opls4 :: [Types.StrOp]
  {- Strictness: m2,
     Unfolding: (GHC.Types.: @ Types.StrOp Ops._opls81 Ops._opls5) -}
6b9dd39b72e6bcba97227a8a571c1675
  _opls40 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Ops._opls41) -}
c362ddada30e4c38c2095049ccb5eded
  _opls41 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("isEmpty"#) -}
e38da5e26c6532dc28811691710443b7
  _opls42 :: ([GHC.Types.Char], Types.Op)
  {- Strictness: m, Unfolding: ((Ops._opls43, Ops._pop)) -}
ab391930ad4b47703e2a372fc33cceeb
  _opls43 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Ops._opls44) -}
adf273349e2eb5c88a12c0f2ca68f6aa
  _opls44 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("pop"#) -}
70d54caef98754eb24fac496d240364e
  _opls45 :: ([GHC.Types.Char], Types.Op)
  {- Strictness: m, Unfolding: ((Ops._opls46, Ops._tail)) -}
b46f996224ca64f162de47a2ee3d210b
  _opls46 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Ops._opls47) -}
604b80a69de52eb9631a126ea9bdcbf4
  _opls47 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("tail"#) -}
73ab7803bc2336cba1430520ae56c443
  _opls48 :: ([GHC.Types.Char], Types.Op)
  {- Strictness: m, Unfolding: ((Ops._opls49, Ops._head)) -}
e92fbe548db57e876b4052c9d7c43968
  _opls49 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Ops._opls50) -}
fb1396b6b2f4efd71b4b7829f2ab94be
  _opls5 :: [Types.StrOp]
  {- Strictness: m2,
     Unfolding: (GHC.Types.: @ Types.StrOp Ops._opls78 Ops._opls6) -}
f6486a2b694ad4c9c9201bafdc96f49c
  _opls50 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("head"#) -}
469d7661abff5031cde723be335e3816
  _opls51 :: ([GHC.Types.Char], Types.Op)
  {- Strictness: m, Unfolding: ((Ops._opls52, Ops._succ)) -}
8d538b21620dc8d7ed9271ab6e25155d
  _opls52 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Ops._opls53) -}
55e5ab72180d5c460fdb3239248f9581
  _opls53 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("succ"#) -}
9669e301d23707199d6091b4bf209faa
  _opls54 :: ([GHC.Types.Char], Types.Op)
  {- Strictness: m, Unfolding: ((Ops._opls55, Ops._div)) -}
13f7afebc69a107591209c8572bfb7b3
  _opls55 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Ops._opls56) -}
1e449ce76a81b2bae75a4391fcbe782d
  _opls56 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("/"#) -}
9a915a52d60729a527dcf8a71fbe190d
  _opls57 :: ([GHC.Types.Char], Types.Op)
  {- Strictness: m, Unfolding: ((Ops._opls58, Ops._mul)) -}
86762afb55361060c5c8ee07dc85dc54
  _opls58 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Ops._opls59) -}
830575ddf031d0e4175a79a4d5eb20ad
  _opls59 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("*"#) -}
757ff89e6e8e6e1a043253ec72edff6f
  _opls6 :: [Types.StrOp]
  {- Strictness: m2,
     Unfolding: (GHC.Types.: @ Types.StrOp Ops._opls75 Ops._opls7) -}
284b603a8149c9d038588bf05e5b6411
  _opls60 :: ([GHC.Types.Char], Types.Op)
  {- Strictness: m, Unfolding: ((Ops._opls61, Ops._sub)) -}
f26e8fc64340a22e9383ef37347e3a49
  _opls61 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Ops._opls62) -}
6d4847201cfca8adde0a2afe221f6481
  _opls62 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("-"#) -}
a3ec4e240c199d7ad3b6adc654184629
  _opls63 :: ([GHC.Types.Char], Types.Op)
  {- Strictness: m, Unfolding: ((Ops._opls64, Ops._add)) -}
ee8849ac7f8733f33453bc48b964ce55
  _opls64 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Ops._opls65) -}
7f465072c7f91da8ce161791cb4eb660
  _opls65 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("+"#) -}
8abc1a8b335854110b914c132741e5a1
  _opls66 :: ([GHC.Types.Char], Types.Op)
  {- Strictness: m, Unfolding: ((Ops._opls67, Ops._leq)) -}
9a5f6895167821d505a7235542ec98b9
  _opls67 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Ops._opls68) -}
b28c0efc2a392a70f53855a5279ec78c
  _opls68 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("<="#) -}
167016044b52466ab4ba4482777c0b2f
  _opls69 :: ([GHC.Types.Char], Types.Op)
  {- Strictness: m, Unfolding: ((Ops._opls70, Ops._lt)) -}
fddf042a76a9eff7ae84f29aebe0ab3b
  _opls7 :: [Types.StrOp]
  {- Strictness: m2,
     Unfolding: (GHC.Types.: @ Types.StrOp Ops._opls72 Ops._opls8) -}
d2e9a3240c2f589c49d7826f3a901c4d
  _opls70 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Ops._opls71) -}
117cfd264e23e52794383ec6e0ca1191
  _opls71 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("<"#) -}
be68e58cb896a197dd467809eb32a537
  _opls72 :: ([GHC.Types.Char], Types.Op)
  {- Strictness: m, Unfolding: ((Ops._opls73, Ops._geq)) -}
6509007735eeab324393305a2001de50
  _opls73 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Ops._opls74) -}
3cdadd35db43e0afb722099783af8686
  _opls74 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: (">="#) -}
20c9e6cdf1c1b1b4bbb63612ea95ce61
  _opls75 :: ([GHC.Types.Char], Types.Op)
  {- Strictness: m, Unfolding: ((Ops._opls76, Ops._gt)) -}
7274999d9f5eb12b72540e0e5ed864fe
  _opls76 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Ops._opls77) -}
0a32d4011c6818f0a574c8eec8671995
  _opls77 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: (">"#) -}
48fb0b19bd2f20b0627a2d7ec4bbd5bc
  _opls78 :: ([GHC.Types.Char], Types.Op)
  {- Strictness: m, Unfolding: ((Ops._opls79, Ops._neq)) -}
673e2fb7a637aff44195c0b9f16b97ea
  _opls79 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Ops._opls80) -}
3c5db7635f74a0811cd886d61d8b2562
  _opls8 :: [Types.StrOp]
  {- Strictness: m2,
     Unfolding: (GHC.Types.: @ Types.StrOp Ops._opls69 Ops._opls9) -}
a97b446e5af557ebc9b461585fc38a03
  _opls80 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("!="#) -}
90c85b32c16d0c79d3b54dce884d15f2
  _opls81 :: ([GHC.Types.Char], Types.Op)
  {- Strictness: m, Unfolding: ((Ops._opls82, Ops._eq)) -}
e87650bf00bc7522fbe9a8f17e2dd889
  _opls82 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Ops._opls83) -}
c0ea8113dd5b68bac078f3c6dd253382
  _opls83 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("=="#) -}
099d14418f665c8ad50baf129368a374
  _opls84 :: ([GHC.Types.Char], Types.Op)
  {- Strictness: m, Unfolding: ((Ops._opls85, Ops._not)) -}
1f95dd299eed2d69f11491f6af520b56
  _opls85 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Ops._opls86) -}
eef00eeaee9e7fdbc323d2e4a8f6dce3
  _opls86 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("!"#) -}
77b146b60346a73093e2e728680f41c2
  _opls87 :: ([GHC.Types.Char], Types.Op)
  {- Strictness: m, Unfolding: ((Ops._opls88, Ops._and)) -}
3e64020a7ff41fcbc87f39fbeddb2763
  _opls88 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Ops._opls89) -}
d36ef3c7d62a80d628ddd8f05d8465e5
  _opls89 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("&&"#) -}
ffda46f12a50b4ca8ba11037daf63022
  _opls9 :: [Types.StrOp]
  {- Strictness: m2,
     Unfolding: (GHC.Types.: @ Types.StrOp Ops._opls66 Ops._opls10) -}
780c9b0fde9c7d386f5e95bdef0c9bf6
  _opls90 :: ([GHC.Types.Char], Types.Op)
  {- Strictness: m, Unfolding: ((Ops._opls91, Ops._or)) -}
6dfc362a54503c3d25dbab516cf70894
  _opls91 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Ops._opls92) -}
a94a348462aba4bb2b94ceb983f7215e
  _opls92 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("||"#) -}
7da2ae2867f6c2aaea805694bd443154
  _opls93 :: ([GHC.Types.Char], Types.Op)
  {- Strictness: m, Unfolding: ((Ops._opls94, Ops._print)) -}
62c08972a06d5331db7e28e4470e08fe
  _opls94 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Ops._opls95) -}
0ff339576c251c9fb6e4e5f764ab22c2
  _opls95 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("print"#) -}
4fdae104e3cb477fac4af3f60e9882f1
  _opls_dec :: [Types.StrOp]
  {- Unfolding: (GHC.List.reverse1
                   @ Types.StrOp
                   Ops._opls
                   (GHC.Types.[] @ Types.StrOp)) -}
2dad54012d1d4183e30cbb4f648be85d
  _or :: Types.Op
  {- Strictness: m1, Unfolding: (Types.BinOp Ops._or1) -}
f68cc639da88272c668bdc890fa04674
  _or1 :: Types.Wrd -> Types.Wrd -> Types.Wrd
  {- Arity: 2, Strictness: <S,1*U><S,1*U>m8, Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Types.Wrd) (w1 :: Types.Wrd) ->
                 case w of wild {
                   DEFAULT
                   -> Control.Exception.Base.patError
                        @ 'GHC.Types.LiftedRep
                        @ Types.Wrd
                        Ops._or2
                   Types.Bool a
                   -> case w1 of wild1 {
                        DEFAULT
                        -> Control.Exception.Base.patError
                             @ 'GHC.Types.LiftedRep
                             @ Types.Wrd
                             Ops._or2
                        Types.Bool b
                        -> Types.Bool
                             (case a of wild2 {
                                GHC.Types.False -> b GHC.Types.True -> GHC.Types.True }) } }) -}
19c8cec9d0f561af4b45d78201f1463b
  _or2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("src/Ops.hs:253:14-50|lambda"#) -}
d6236793377f6f670b31cc0073f004d8
  _or_t :: Types.Wrd -> Types.Wrd -> Types.Wrd
  {- Arity: 2, Strictness: <S,1*U><S,U>,
     Unfolding: (\ (ds :: Types.Wrd) (ds1 :: Types.Wrd) ->
                 case ds of wild {
                   DEFAULT -> Ops._or_t2
                   Types.TypeCheck ds2
                   -> let {
                        fail :: GHC.Prim.Void# -> Types.Wrd
                          <join 1> {- Arity: 1, Strictness: <L,A> -}
                        = \ (ds3 :: GHC.Prim.Void#)[OneShot] ->
                          case ds1 of wild1 {
                            DEFAULT -> Ops._or_t2
                            Types.TypeCheck t2
                            -> Types.Err
                                 (GHC.CString.unpackAppendCString#
                                    Ops._or_t1
                                    (GHC.Base.++
                                       @ GHC.Types.Char
                                       (Types.$fShowBind_$cshowsPrec1
                                          Types.$fShowBind2
                                          ds2
                                          (GHC.Types.[] @ GHC.Types.Char))
                                       (GHC.CString.unpackAppendCString#
                                          Ops._and_t2
                                          (Types.$fShowBind_$cshowsPrec1
                                             Types.$fShowBind2
                                             t2
                                             (GHC.Types.[] @ GHC.Types.Char))))) }
                      } in
                      case ds2 of wild1 {
                        DEFAULT -> fail GHC.Prim.void#
                        Types.T_Bool
                        -> case ds1 of wild2 {
                             DEFAULT -> fail GHC.Prim.void#
                             Types.TypeCheck ds3
                             -> case ds3 of wild3 {
                                  DEFAULT -> fail GHC.Prim.void#
                                  Types.T_Bool -> Ops._and_t1 } } } }) -}
856996f8fdef8285cf1f5129fafbb4ef
  _or_t1 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("`||`: Illegal input type: LHS="#) -}
87ef047113c19c2ca6e6a07f130bfafb
  _or_t2 :: Types.Wrd
  {- Strictness: b -}
df57e6f9a3f1b44a88f121806f113b49
  _pop :: Types.Op
  {- Strictness: m2, Unfolding: (Types.UnOp Ops._pop0) -}
a43863421cb195ba4a81ac2b795976d0
  _pop0 :: Types.Wrd -> Types.Wrd
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Types.Wrd) ->
                 case ds of wild {
                   DEFAULT -> Ops._pop4
                   Types.List ds1
                   -> case ds1 of wild1 {
                        [] -> Ops._pop1
                        : x xs
                        -> Types.Tuple
                             (GHC.Types.:
                                @ Types.Wrd
                                x
                                (GHC.Types.:
                                   @ Types.Wrd
                                   (Types.List xs)
                                   (GHC.Types.[] @ Types.Wrd))) } }) -}
709d369fb1758868880d1fb071ed0f52
  _pop1 :: Types.Wrd
  {- Strictness: m12, Unfolding: (Types.Err Ops._pop2) -}
67820d80a490bcd1292746a61771d56a
  _pop2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Ops._pop3) -}
2b468eb485d5183768e6da337648fc34
  _pop3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("pop: Empty list."#) -}
c107aca5cd4933cc2198d0720dd0a71a
  _pop4 :: Types.Wrd
  {- Strictness: b -}
7b28d897efcd51c53f0f5aac16ba00e7
  _pop_t :: Types.Wrd -> Types.Wrd
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: Types.Wrd) ->
                 case ds of wild {
                   DEFAULT -> Ops._pop_t2
                   Types.TypeCheck ds1
                   -> case ds1 of wild1 {
                        DEFAULT
                        -> Types.Err
                             (GHC.CString.unpackAppendCString#
                                Ops._pop_t1
                                (Types.$fShowBind_$cshowsPrec1
                                   Types.$fShowBind2
                                   wild1
                                   (GHC.Types.[] @ GHC.Types.Char)))
                        Types.T_List t
                        -> Types.TypeCheck
                             (Types.T_Tuple
                                (GHC.Types.:
                                   @ Types.Type
                                   t
                                   (GHC.Types.:
                                      @ Types.Type
                                      wild1
                                      (GHC.Types.[] @ Types.Type)))) } }) -}
4ee8181b34bb8af5a603e9b7cd5b63eb
  _pop_t1 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("pop: Illegal input type: "#) -}
c0229d1d856a735304e427f6db3d6ac4
  _pop_t2 :: Types.Wrd
  {- Strictness: b -}
eda6ef382233d8eaf5158800a77e8265
  _print :: Types.Op
  {- Strictness: m2, Unfolding: (Types.UnOp Ops._print0) -}
1a8cb3abd12085fea6a1ce5fd292bb5d
  _print0 :: Types.Wrd -> Types.Wrd
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Types.Wrd) ->
                 case ds of wild {
                   DEFAULT -> Types.Print (Types.$fShowBind_$cshow wild)
                   Types.Err e -> Types.Err e }) -}
a73db97c132a9eb6be1f40eb071cef24
  _print_t :: Types.Wrd -> Types.Wrd
  {- Arity: 1, Strictness: <S,1*U>m18,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Types.Wrd) ->
                 case ds of wild {
                   DEFAULT -> Ops._print_t3
                   Types.TypeCheck ds1
                   -> case ds1 of wild1 {
                        DEFAULT -> Ops._print_t2 Types.T_Error -> Ops._print_t1 } }) -}
778912fc82bbe1c0c8a9c2119ee0376e
  _print_t1 :: Types.Wrd
  {- HasNoCafRefs, Strictness: m18,
     Unfolding: (Types.TypeCheck Types.T_Error) -}
a8c95293fd2007032728adf806d1c737
  _print_t2 :: Types.Wrd
  {- HasNoCafRefs, Strictness: m18,
     Unfolding: (Types.TypeCheck Types.T_Print) -}
c0d8809ebbb7aa0dbcef4cef8fee8565
  _print_t3 :: Types.Wrd
  {- Strictness: b -}
d2fa608ce95f0fd0f24a64ac0e7ba98e
  _seq :: Types.Op
  {- Strictness: m3, Unfolding: (Types.FuncOp Ops._seq1) -}
5c58475960d4f7c34fb7b9105246807a
  _seq0 :: Types.Exp -> Types.Wrd
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ (ds :: [Types.Wrd]) ->
                 let {
                   fail :: GHC.Prim.Void# -> Types.Wrd
                     <join 1> {- Arity: 1, Strictness: <L,A> -}
                   = \ (ds1 :: GHC.Prim.Void#)[OneShot] ->
                     Types.Err
                       (GHC.CString.unpackAppendCString#
                          Ops._seq2
                          (case ds of wild {
                             [] -> Ops.toList1
                             : x xs
                             -> GHC.Types.:
                                  @ GHC.Types.Char
                                  GHC.Show.showList__3
                                  (GHC.Base.++
                                     @ GHC.Types.Char
                                     (Types.$fShowBind_$cshow x)
                                     (case Ops.$wshowl xs of ww { (#,#) ww1 ww2 ->
                                      GHC.Types.: @ GHC.Types.Char ww1 ww2 })) }))
                 } in
                 case ds of wild {
                   [] -> fail GHC.Prim.void#
                   : ds1 ds2
                   -> case ds1 of wild1 {
                        DEFAULT -> fail GHC.Prim.void#
                        Types.Int n
                        -> case ds2 of wild2 {
                             [] -> fail GHC.Prim.void#
                             : ds3 ds4
                             -> case ds3 of wild3 {
                                  DEFAULT -> fail GHC.Prim.void#
                                  Types.Int m
                                  -> case ds4 of wild4 {
                                       []
                                       -> Types.List
                                            (case n of wild5 { GHC.Types.I# x ->
                                             case m of wild6 { GHC.Types.I# y ->
                                             case GHC.Prim.># x y of lwild {
                                               DEFAULT
                                               -> letrec {
                                                    go :: GHC.Prim.Int# -> [Types.Wrd]
                                                      {- Arity: 1, Strictness: <L,U> -}
                                                    = \ (x1 :: GHC.Prim.Int#) ->
                                                      GHC.Types.:
                                                        @ Types.Wrd
                                                        (Types.Int (GHC.Types.I# x1))
                                                        (case GHC.Prim.==# x1 y of lwild1 {
                                                           DEFAULT -> go (GHC.Prim.+# x1 1#)
                                                           1# -> GHC.Types.[] @ Types.Wrd })
                                                  } in
                                                  go x
                                               1# -> GHC.Types.[] @ Types.Wrd } } })
                                       : ipv ipv1 -> fail GHC.Prim.void# } } } } }) -}
9f59b30d948edab820ae7bd0a9ec5b8b
  _seq1 :: (GHC.Types.Int, Types.Exp -> Types.Wrd)
  {- Strictness: m, Unfolding: ((Ops._map3, Ops._seq0)) -}
459f705f54d958ea106e5d280b7fdd22
  _seq2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("seq: Illegal input value: "#) -}
84ceff338091f1ba14cbd22e1a5e11eb
  _seq_t :: Types.Exp -> Types.Wrd
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ (ds :: [Types.Wrd]) ->
                 let {
                   fail :: GHC.Prim.Void# -> Types.Wrd
                     <join 1> {- Arity: 1, Strictness: <L,A> -}
                   = \ (ds1 :: GHC.Prim.Void#)[OneShot] ->
                     Types.Err
                       (GHC.CString.unpackAppendCString#
                          Ops._map_t2
                          (case ds of wild {
                             [] -> Ops.toList1
                             : x xs
                             -> GHC.Types.:
                                  @ GHC.Types.Char
                                  GHC.Show.showList__3
                                  (GHC.Base.++
                                     @ GHC.Types.Char
                                     (Types.$fShowBind_$cshow x)
                                     (case Ops.$wshowl xs of ww { (#,#) ww1 ww2 ->
                                      GHC.Types.: @ GHC.Types.Char ww1 ww2 })) }))
                 } in
                 case ds of wild {
                   [] -> fail GHC.Prim.void#
                   : ds1 ds2
                   -> case ds1 of wild1 {
                        DEFAULT -> fail GHC.Prim.void#
                        Types.TypeCheck ds3
                        -> case ds3 of wild2 {
                             DEFAULT -> fail GHC.Prim.void#
                             Types.T_Int
                             -> case ds2 of wild3 {
                                  [] -> fail GHC.Prim.void#
                                  : ds4 ds5
                                  -> case ds4 of wild4 {
                                       DEFAULT -> fail GHC.Prim.void#
                                       Types.TypeCheck ds6
                                       -> case ds6 of wild5 {
                                            DEFAULT -> fail GHC.Prim.void#
                                            Types.T_Int
                                            -> case ds5 of wild6 {
                                                 [] -> Ops._seq_t1
                                                 : ipv ipv1 -> fail GHC.Prim.void# } } } } } } }) -}
0fb3b14c4dc88304c907828cb1a7c31d
  _seq_t1 :: Types.Wrd
  {- HasNoCafRefs, Strictness: m18,
     Unfolding: (Types.TypeCheck Ops._seq_t2) -}
2b9118bcbc7b9e1043fccc128d4f8ecd
  _seq_t2 :: Types.Type
  {- HasNoCafRefs, Strictness: m10,
     Unfolding: (Types.T_List Types.T_Int) -}
e84ef485f36f52ab4e216a87a2ba462e
  _snd :: Types.Op
  {- Strictness: m2, Unfolding: (Types.UnOp Ops._snd1) -}
1dd344d8ef4b23cfd57f69c0be093838
  _snd1 :: Types.Wrd -> Types.Wrd
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: Types.Wrd) ->
                 case ds of wild {
                   DEFAULT -> Ops._snd2
                   Types.Tuple ds1
                   -> case ds1 of wild1 {
                        [] -> Ops._snd2
                        : ds2 ds3
                        -> case ds3 of wild2 { [] -> Ops._snd2 : w2 ds4 -> w2 } } }) -}
5392c2898a2292c44e4705cf2d555b3f
  _snd2 :: Types.Wrd
  {- Strictness: b -}
0848ed9b9036c10b4a0cfe6b8a823a96
  _snd_t :: Types.Wrd -> Types.Wrd
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: Types.Wrd) ->
                 case ds of wild {
                   DEFAULT
                   -> Types.Err
                        (GHC.CString.unpackAppendCString#
                           Ops._snd_t1
                           (Types.$fShowBind_$cshow wild))
                   Types.TypeCheck ds1
                   -> case ds1 of wild1 {
                        DEFAULT
                        -> Types.Err
                             (GHC.CString.unpackAppendCString#
                                Ops._snd_t1
                                (Types.$fShowBind_$cshow wild))
                        Types.T_Tuple ds2
                        -> case ds2 of wild2 {
                             []
                             -> Types.Err
                                  (GHC.CString.unpackAppendCString#
                                     Ops._snd_t1
                                     (Types.$fShowBind_$cshow wild))
                             : ds3 ds4
                             -> case ds4 of wild3 {
                                  []
                                  -> Types.Err
                                       (GHC.CString.unpackAppendCString#
                                          Ops._snd_t1
                                          (Types.$fShowBind_$cshow wild))
                                  : t ds5 -> Types.TypeCheck t } } } }) -}
fb5fb730789a7a098c792d2650fc4236
  _snd_t1 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("snd: Illegal input type: "#) -}
c65baf7f63f0bfe2c7b94d5202a5363c
  _sub :: Types.Op
  {- Strictness: m1, Unfolding: (Types.BinOp Ops._sub0) -}
380126703182f0513c5a6e449c3612e7
  _sub0 :: Types.Wrd -> Types.Wrd -> Types.Wrd
  {- Arity: 2, Strictness: <S,U><L,U>,
     Unfolding: (\ (ds :: Types.Wrd) (ds1 :: Types.Wrd) ->
                 let {
                   fail :: GHC.Prim.Void# -> Types.Wrd
                     <join 1> {- Arity: 1, Strictness: <L,A> -}
                   = \ (ds2 :: GHC.Prim.Void#)[OneShot] ->
                     Types.Err
                       (GHC.CString.unpackAppendCString#
                          Ops._sub1
                          (GHC.Base.++
                             @ GHC.Types.Char
                             (Types.$fShowBind_$cshow ds)
                             (GHC.CString.unpackAppendCString#
                                Ops._add1
                                (Types.$fShowBind_$cshow ds1))))
                 } in
                 case ds of wild {
                   DEFAULT -> fail GHC.Prim.void#
                   Types.Double x
                   -> case ds1 of wild1 {
                        DEFAULT -> fail GHC.Prim.void#
                        Types.Double y -> Types.Double (GHC.Float.minusDouble x y)
                        Types.Int y
                        -> Types.Double
                             (case x of wild2 { GHC.Types.D# x1 ->
                              case y of wild3 { GHC.Types.I# i ->
                              GHC.Types.D# (GHC.Prim.-## x1 (GHC.Prim.int2Double# i)) } }) }
                   Types.Int x
                   -> case ds1 of wild1 {
                        DEFAULT -> fail GHC.Prim.void#
                        Types.Double y
                        -> Types.Double
                             (case x of wild2 { GHC.Types.I# i ->
                              case y of wild3 { GHC.Types.D# y1 ->
                              GHC.Types.D# (GHC.Prim.-## (GHC.Prim.int2Double# i) y1) } })
                        Types.Int y -> Types.Int (GHC.Num.$fNumInt_$c- x y) } }) -}
35c261a5b9aaa69c8ef7ad1d509bd398
  _sub1 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("`-`: Illegal input value: x="#) -}
40cd0b20fde53dd78e2991bf886f9e36
  _sub_t :: Types.Wrd -> Types.Wrd -> Types.Wrd
  {- Arity: 2, Strictness: <S,U><L,U>,
     Unfolding: (\ (ds :: Types.Wrd) (ds1 :: Types.Wrd) ->
                 let {
                   fail :: GHC.Prim.Void# -> Types.Wrd
                     <join 1> {- Arity: 1, Strictness: <L,A> -}
                   = \ (ds2 :: GHC.Prim.Void#)[OneShot] ->
                     Types.Err
                       (GHC.CString.unpackAppendCString#
                          Ops._sub_t1
                          (GHC.Base.++
                             @ GHC.Types.Char
                             (Types.$fShowBind_$cshow ds)
                             (GHC.CString.unpackAppendCString#
                                Ops._add_t6
                                (Types.$fShowBind_$cshow ds1))))
                 } in
                 case ds of wild {
                   DEFAULT -> fail GHC.Prim.void#
                   Types.TypeCheck ds2
                   -> case ds2 of wild1 {
                        DEFAULT -> fail GHC.Prim.void#
                        Types.T_Int
                        -> case ds1 of wild2 {
                             DEFAULT -> fail GHC.Prim.void#
                             Types.TypeCheck ds3
                             -> case ds3 of wild3 {
                                  DEFAULT -> fail GHC.Prim.void#
                                  Types.T_Int -> Ops._add_t5
                                  Types.T_Double -> Ops._add_t4 } }
                        Types.T_Double
                        -> case ds1 of wild2 {
                             DEFAULT -> fail GHC.Prim.void#
                             Types.TypeCheck ds3
                             -> case ds3 of wild3 {
                                  DEFAULT -> fail GHC.Prim.void#
                                  Types.T_Int -> Ops._add_t4
                                  Types.T_Double -> Ops._add_t4 } } } }) -}
a1f446f17c4d6891251efc4b2fb25dcf
  _sub_t1 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("`-`: Illegal input type: t_x="#) -}
2477eb98e633f7db715310a63b6538fb
  _succ :: Types.Op
  {- Strictness: m2, Unfolding: (Types.UnOp Ops._succ0) -}
50b724e6e0b2226fe4172250f967bada
  _succ0 :: Types.Wrd -> Types.Wrd
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: Types.Wrd) ->
                 case ds of wild {
                   DEFAULT
                   -> Types.Err
                        (GHC.CString.unpackAppendCString#
                           Ops._succ1
                           (Types.$fShowBind_$cshow wild))
                   Types.Double x
                   -> Types.Double
                        (case x of wild1 { GHC.Types.D# x1 ->
                         GHC.Types.D# (GHC.Prim.+## x1 1.0##) })
                   Types.Int x
                   -> Types.Int
                        (case x of wild1 { GHC.Types.I# x1 ->
                         GHC.Types.I# (GHC.Prim.+# x1 1#) }) }) -}
1e1bec2b7d8324d8c8a13fc675c5884a
  _succ1 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("succ: Illegal input value: "#) -}
71d957eebe0c35be710ba79dec49035f
  _succ_t :: Types.Wrd -> Types.Wrd
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: Types.Wrd) ->
                 case ds of wild {
                   DEFAULT
                   -> Types.Err
                        (GHC.CString.unpackAppendCString#
                           Ops._succ_t1
                           (Types.$fShowBind_$cshow wild))
                   Types.TypeCheck ds1
                   -> case ds1 of wild1 {
                        DEFAULT
                        -> Types.Err
                             (GHC.CString.unpackAppendCString#
                                Ops._succ_t1
                                (Types.$fShowBind_$cshow wild))
                        Types.T_Int -> Ops._add_t5
                        Types.T_Double -> Ops._add_t4 } }) -}
6b00d16e376d0e6f0254d253382e9977
  _succ_t1 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("succ: Illegal input type: "#) -}
4d3f9fd1b4c251916b6f7b5a79282d1b
  _tail :: Types.Op
  {- Strictness: m2, Unfolding: (Types.UnOp Ops._tail0) -}
d752ced8c141b038dfbe64684799fc1e
  _tail0 :: Types.Wrd -> Types.Wrd
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Types.Wrd) ->
                 case ds of wild {
                   DEFAULT -> Ops._tail4
                   Types.List ds1
                   -> case ds1 of wild1 {
                        [] -> Ops._tail1 : ds2 xs -> Types.List xs } }) -}
1aed59bd94427900fdd063e064d1b4f6
  _tail1 :: Types.Wrd
  {- Strictness: m12, Unfolding: (Types.Err Ops._tail2) -}
5b6bde3d420f44567d3b89d1b48068a7
  _tail2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Ops._tail3) -}
7707e6923ff15a353d267fc53e690104
  _tail3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("tail: Empty list."#) -}
10dd5138a58cf4e10e6703d552a239a4
  _tail4 :: Types.Wrd
  {- Strictness: b -}
c11119d19ca66daa40e00e64d99b5edb
  _tail_t :: Types.Wrd -> Types.Wrd
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: Types.Wrd) ->
                 case ds of wild {
                   DEFAULT -> Ops._tail_t2
                   Types.TypeCheck ds1
                   -> case ds1 of wild1 {
                        DEFAULT
                        -> Types.Err
                             (GHC.CString.unpackAppendCString#
                                Ops._tail_t1
                                (Types.$fShowBind_$cshowsPrec1
                                   Types.$fShowBind2
                                   wild1
                                   (GHC.Types.[] @ GHC.Types.Char)))
                        Types.T_List t -> wild } }) -}
b57e45550d23ed2e01b4e297d7c50947
  _tail_t1 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("tail: Illegal input type: "#) -}
857d590cf81fdc5b0c3ff276bb2c3792
  _tail_t2 :: Types.Wrd
  {- Strictness: b -}
3ec75950f44373679e5ab7acbfa10b43
  _take :: Types.Op
  {- Strictness: m3, Unfolding: (Types.FuncOp Ops._take1) -}
c412a6b0ac453ac304587d4da2b8dd3b
  _take0 :: Types.Exp -> Types.Wrd
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ (ds :: [Types.Wrd]) ->
                 let {
                   fail :: GHC.Prim.Void# -> Types.Wrd
                     <join 1> {- Arity: 1, Strictness: <L,A> -}
                   = \ (ds1 :: GHC.Prim.Void#)[OneShot] ->
                     Types.Err
                       (GHC.CString.unpackAppendCString#
                          Ops._take2
                          (case ds of wild {
                             [] -> Ops.toList1
                             : x xs
                             -> GHC.Types.:
                                  @ GHC.Types.Char
                                  GHC.Show.showList__3
                                  (GHC.Base.++
                                     @ GHC.Types.Char
                                     (Types.$fShowBind_$cshow x)
                                     (case Ops.$wshowl xs of ww { (#,#) ww1 ww2 ->
                                      GHC.Types.: @ GHC.Types.Char ww1 ww2 })) }))
                 } in
                 case ds of wild {
                   [] -> fail GHC.Prim.void#
                   : ds1 ds2
                   -> case ds1 of wild1 {
                        DEFAULT -> fail GHC.Prim.void#
                        Types.Int n
                        -> case ds2 of wild2 {
                             [] -> fail GHC.Prim.void#
                             : ds3 ds4
                             -> case ds3 of wild3 {
                                  DEFAULT -> fail GHC.Prim.void#
                                  Types.List ls
                                  -> case ds4 of wild4 {
                                       []
                                       -> Types.List
                                            (case n of wild5 { GHC.Types.I# y ->
                                             case GHC.Prim.<# 0# y of lwild {
                                               DEFAULT -> GHC.Types.[] @ Types.Wrd
                                               1# -> GHC.List.$wunsafeTake @ Types.Wrd y ls } })
                                       : ipv ipv1 -> fail GHC.Prim.void# } } } } }) -}
4ac6979170d3a4f5c827f576cfffd6bf
  _take1 :: (GHC.Types.Int, Types.Exp -> Types.Wrd)
  {- Strictness: m, Unfolding: ((Ops._map3, Ops._take0)) -}
dc225380dbafec91e9b60dbf1b066df7
  _take2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("take: Illegal input value: "#) -}
fe67517ccf12bff65158b08c0ae18a43
  _take_t :: Types.Exp -> Types.Wrd
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ (ds :: [Types.Wrd]) ->
                 let {
                   fail :: GHC.Prim.Void# -> Types.Wrd
                     <join 1> {- Arity: 1, Strictness: <L,A> -}
                   = \ (ds1 :: GHC.Prim.Void#)[OneShot] ->
                     Types.Err
                       (GHC.CString.unpackAppendCString#
                          Ops._take_t1
                          (case ds of wild {
                             [] -> Ops.toList1
                             : x xs
                             -> GHC.Types.:
                                  @ GHC.Types.Char
                                  GHC.Show.showList__3
                                  (GHC.Base.++
                                     @ GHC.Types.Char
                                     (Types.$fShowBind_$cshow x)
                                     (case Ops.$wshowl xs of ww { (#,#) ww1 ww2 ->
                                      GHC.Types.: @ GHC.Types.Char ww1 ww2 })) }))
                 } in
                 case ds of wild {
                   [] -> fail GHC.Prim.void#
                   : ds1 ds2
                   -> case ds1 of wild1 {
                        DEFAULT -> fail GHC.Prim.void#
                        Types.TypeCheck ds3
                        -> case ds3 of wild2 {
                             DEFAULT -> fail GHC.Prim.void#
                             Types.T_Int
                             -> case ds2 of wild3 {
                                  [] -> fail GHC.Prim.void#
                                  : ds4 ds5
                                  -> case ds4 of wild4 {
                                       DEFAULT -> fail GHC.Prim.void#
                                       Types.TypeCheck ds6
                                       -> case ds6 of wild5 {
                                            DEFAULT -> fail GHC.Prim.void#
                                            Types.T_List t
                                            -> case ds5 of wild6 {
                                                 [] -> wild4
                                                 : ipv ipv1 -> fail GHC.Prim.void# } } } } } } }) -}
9412bd3a2c7ab6d7e81729cb7bf9fb84
  _take_t1 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("take: Illegal input type: "#) -}
ee95a08bf525ca090c305cc8c1f3aeb0
  _typeFunction :: GHC.Base.String -> Types.Op
  {- Arity: 1, Strictness: <S,U> -}
3ffb66a67b1e4fd04be337d8a2eceda7
  isConsistentType :: Types.Exp -> GHC.Types.Bool
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (expr :: Types.Exp) ->
                 case Ops._isConsistentType expr of wild {
                   GHC.Maybe.Nothing -> GHC.Types.False
                   GHC.Maybe.Just a1 -> GHC.Types.True }) -}
27a51ba87381b8245ff7c9b364acdd1f
  toList :: Types.Exp -> Types.Wrd
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ (expr :: Types.Exp) ->
                 case Ops._isConsistentType expr of wild {
                   GHC.Maybe.Nothing
                   -> Types.Err
                        (GHC.CString.unpackAppendCString#
                           Ops.toList2
                           (case expr of wild1 {
                              [] -> Ops.toList1
                              : x xs
                              -> GHC.Types.:
                                   @ GHC.Types.Char
                                   GHC.Show.showList__3
                                   (GHC.Base.++
                                      @ GHC.Types.Char
                                      (Types.$fShowBind_$cshow x)
                                      (case Ops.$wshowl xs of ww { (#,#) ww1 ww2 ->
                                       GHC.Types.: @ GHC.Types.Char ww1 ww2 })) }))
                   GHC.Maybe.Just a1 -> Types.List expr }) -}
1577133c85b45b42e3461d9132adfe1e
  toList1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackAppendCString#
                   GHC.Show.showList__4
                   (GHC.Types.[] @ GHC.Types.Char)) -}
68cdf96fce1d1672afe67fde5d863d2f
  toList2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("List: Inconsistent type: "#) -}
trusted: none
require own pkg trusted: False
module header:
  Nothing
declaration docs:
arg docs:


==================== FINAL INTERFACE ====================
2021-04-09 04:56:44.2057584 UTC

interface Topos-0.1.0.0-L2hSunVxFDyol1qAzNo2F:Ops 8104
  interface hash: ef8a11b9a42d54efababcfa712030c2a
  ABI hash: 9ccd6b0b2d6b998e873165db1714d518
  export-list hash: 24531ef125d46d1c52ba79243a43b497
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 358a18e1043fc7ac1b015a88503b1325
  opt_hash: cb09a535710eb16767a299f2ded44a31
  hpc_hash: 93b885adfe0da089cdf634904fd59f71
  plugin_hash: ad164012d6b1e14942349d58b1132007
  sig of: Nothing
  used TH splices: False
  where
exports:
  Ops._add
  Ops._add0
  Ops._add_t
  Ops._and
  Ops._and_t
  Ops._div
  Ops._div0
  Ops._div_t
  Ops._eq
  Ops._eq_t
  Ops._fst
  Ops._fst_t
  Ops._geq
  Ops._geq0
  Ops._geq_t
  Ops._getType
  Ops._gt
  Ops._gt0
  Ops._gt_t
  Ops._head
  Ops._head0
  Ops._head_t
  Ops._isConsistentType
  Ops._isEmpty
  Ops._isEmpty_t
  Ops._leq
  Ops._leq0
  Ops._leq_t
  Ops._lt
  Ops._lt0
  Ops._lt_t
  Ops._map
  Ops._map0
  Ops._map_t
  Ops._mul
  Ops._mul0
  Ops._mul_t
  Ops._neq
  Ops._neq_t
  Ops._not
  Ops._not_t
  Ops._opls
  Ops._opls_dec
  Ops._or
  Ops._or_t
  Ops._pop
  Ops._pop0
  Ops._pop_t
  Ops._print
  Ops._print0
  Ops._print_t
  Ops._seq
  Ops._seq0
  Ops._seq_t
  Ops._snd
  Ops._snd_t
  Ops._sub
  Ops._sub0
  Ops._sub_t
  Ops._succ
  Ops._succ0
  Ops._succ_t
  Ops._tail
  Ops._tail0
  Ops._tail_t
  Ops._take
  Ops._take0
  Ops._take_t
  Ops._typeFunction
  Ops.isConsistentType
  Ops.toList
module dependencies: Parser Types
package dependencies: base-4.14.1.0 ghc-prim-0.6.1
                      integer-gmp-1.0.3.0
orphans: base-4.14.1.0:GHC.Float base-4.14.1.0:GHC.Base
family instance modules: base-4.14.1.0:Control.Applicative
                         base-4.14.1.0:Control.Arrow base-4.14.1.0:Data.Functor.Const
                         base-4.14.1.0:Data.Functor.Identity base-4.14.1.0:Data.Monoid
                         base-4.14.1.0:Data.Semigroup.Internal base-4.14.1.0:GHC.Generics
                         base-4.14.1.0:GHC.IO.Exception
import  -/  Parser 3443f1228a5fa43ab36605baa220d75c
  exports: 4e79c2f1fd013aabc39c8f81cd5374c7
import  -/  Types 2870f235e2eecb0b3d25891749dd9b60
  exports: fb3343c70ce167cabb463f2e586dc9ec
  BinOp 248347d51f0d70dee7324f48b9d0a2d1
  Bool 1241c9fc4fc65d256e8c45a8fcd8d7ba
  Double e9e581551e257a870b35d7e222321699
  Err 5729e6192c4942b542d650e149e72f10
  Exp 41e7a32a3a97b64b95a9c2dd25716e8f
  Fun 42a0d5cd29c2177dcdfaca7cd63323dc
  Func 5d1e31720c6814351c1d5fe881a7a5eb
  FuncOp 8397c94a2f2349a2dd9e300a2647eb27
  Function 9a9eb8e4986ec4d109057707af53cf06
  Int 006171945d67657ef6faae9f16159d2e
  List f0bad1f4683a6ff5d4c475bfda9c9085
  Op 41e7a32a3a97b64b95a9c2dd25716e8f
  Operator 6909136eade762426066db644700f71f
  PreList a5b96693bc60e76099302e7495352709
  Print 825c49422af2ec86182c776d0f7f27d2
  Str 5f7be358727990ce68ad5fc089118acd
  StrOp 41e7a32a3a97b64b95a9c2dd25716e8f
  T_Bool b86db244cb09a3e2fe2aedd61bfbee3d
  T_Double 737f6fd67b2db24d3ba875411b000d1a
  T_EmptyList e01c7753fbb038635d5ed713eb9817eb
  T_Error 48873ecd2091bfe3454b88dba812f4c9
  T_Func cd50891eac1225bdba2c21c3e89ab64b
  T_Function af0bd724946c4e4e99d0a5e688bd8bec
  T_Int 8e2d7b1da0251ed5fe76d6e97cedfbca
  T_List ba15cafcb7b312e20336464ba2df5fd6
  T_Operator 4e8715ebb2c8a3afa27ac366a90ea4dd
  T_PreList c1c2e0be950f1f71892ac83babc5ae70
  T_Print dd66a92b4ff8847e7c08a783b6048b63
  T_String c064da13f2e2dde0871e82011fef3383
  T_Tuple b991f1bb08adca19e3581f5caaa8ae73
  T_Type 739eeac08d3659c9bb2735b433dfb87f
  T_Unknown 55a7e4e28907eaeeec59991a84410abf
  Tobe 3e1c049fbf40275e2d316fdeb88ae7b7
  Tuple 787aea3d9ecc843af9c34b94030802d6
  Type 2cf69a7355f245a5f0d937b4915d0db8
  Type 41e7a32a3a97b64b95a9c2dd25716e8f
  TypeCheck 743327823be34d4f772a0b2575b49c47
  UnOp 4de264f457e8ae24d30e2ee9293e99a7
  Wrd 41e7a32a3a97b64b95a9c2dd25716e8f
  args 41e7a32a3a97b64b95a9c2dd25716e8f
  args_t 41e7a32a3a97b64b95a9c2dd25716e8f
  ret 41e7a32a3a97b64b95a9c2dd25716e8f
  ret_t 41e7a32a3a97b64b95a9c2dd25716e8f
  return_t 41e7a32a3a97b64b95a9c2dd25716e8f
import  -/  base-4.14.1.0:Data.List aa48efeea2e877aaa8c12a1a2e589508
import  -/  base-4.14.1.0:Debug.Trace 311b1d0b6fcef7b89debc64460553e8a
import  -/  base-4.14.1.0:GHC.Base ede51775731a544ddfcb02b5a427fd38
import  -/  base-4.14.1.0:GHC.List 7a32e59b6a27bd558cb52809f6fb6df5
import  -/  base-4.14.1.0:GHC.Num 5f3708b0d1d7a8d15017be85d4a06a34
import  -/  base-4.14.1.0:GHC.Real 4d6025ac56d7c23e0804ecdff4f69d75
import  -/  base-4.14.1.0:GHC.Show 57e93b26a19b08606d2ae3a6ff8065f2
import  -/  base-4.14.1.0:Prelude 5c84dfddbb8583fc340ecd15bead164a
import  -/  ghc-prim-0.6.1:GHC.Classes e50fb3f1cbf74ce4d3874442e4300a09
0077ca7edccd6222f88376e346118960
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module Ops.$trModule3 Ops.$trModule1) -}
c0e5d35f6a7bc4656ee570ea88581d20
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Ops.$trModule2) -}
f9b25b5dbdc46f2d265939d718e84bed
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Ops"#) -}
dfcd064acd8070b26ffa8c69c30fddf9
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Ops.$trModule4) -}
ca9bc36dca399398b222432313c4b910
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("Topos-0.1.0.0-L2hSunVxFDyol1qAzNo2F"#) -}
6a222656f57f52efaac9824435a17553
  $wshowl :: [Types.Wrd] -> (# GHC.Types.Char, [GHC.Types.Char] #)
  {- Arity: 1, Strictness: <S,1*U>, Inline: [2] -}
aed145bdd147b3aa48670d02fb84703d
  _add :: Types.Op
  {- Strictness: m1, Unfolding: (Types.BinOp Ops._add0) -}
8847e9ae90b861773782d43145682fa6
  _add0 :: Types.Wrd -> Types.Wrd -> Types.Wrd
  {- Arity: 2, Strictness: <S,U><L,U>,
     Unfolding: (\ (ds :: Types.Wrd) (ds1 :: Types.Wrd) ->
                 let {
                   fail :: GHC.Prim.Void# -> Types.Wrd
                     <join 1> {- Arity: 1, Strictness: <L,A> -}
                   = \ (ds2 :: GHC.Prim.Void#)[OneShot] ->
                     Types.Err
                       (GHC.CString.unpackAppendCString#
                          Ops._add2
                          (GHC.Base.++
                             @ GHC.Types.Char
                             (Types.$fShowBind_$cshow ds)
                             (GHC.CString.unpackAppendCString#
                                Ops._add1
                                (Types.$fShowBind_$cshow ds1))))
                 } in
                 case ds of wild {
                   DEFAULT -> fail GHC.Prim.void#
                   Types.Str s1
                   -> case ds1 of wild1 {
                        DEFAULT -> fail GHC.Prim.void#
                        Types.Str s2 -> Types.Str (GHC.Base.++ @ GHC.Types.Char s1 s2) }
                   Types.Double x
                   -> case ds1 of wild1 {
                        DEFAULT -> fail GHC.Prim.void#
                        Types.Double y -> Types.Double (GHC.Float.plusDouble x y)
                        Types.Int y
                        -> Types.Double
                             (case x of wild2 { GHC.Types.D# x1 ->
                              case y of wild3 { GHC.Types.I# i ->
                              GHC.Types.D# (GHC.Prim.+## x1 (GHC.Prim.int2Double# i)) } }) }
                   Types.Int x
                   -> case ds1 of wild1 {
                        DEFAULT -> fail GHC.Prim.void#
                        Types.Double y
                        -> Types.Double
                             (case x of wild2 { GHC.Types.I# i ->
                              case y of wild3 { GHC.Types.D# y1 ->
                              GHC.Types.D# (GHC.Prim.+## (GHC.Prim.int2Double# i) y1) } })
                        Types.Int y -> Types.Int (GHC.Num.$fNumInt_$c+ x y) }
                   Types.List l1
                   -> case ds1 of wild1 {
                        DEFAULT -> fail GHC.Prim.void#
                        Types.List l2 -> Ops.toList (GHC.Base.++ @ Types.Wrd l1 l2) } }) -}
9a2955ab09703cd32219213c1c5551c7
  _add1 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: (", y="#) -}
a8bc2cb4b2ded22b4496a1fbed2cab76
  _add2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("`+`: Illegal input value: x="#) -}
2e92d9d21e7200c92bab91854baf80d0
  _add_t :: Types.Wrd -> Types.Wrd -> Types.Wrd
  {- Arity: 2, Strictness: <S,U><L,U>,
     Unfolding: (\ (ds :: Types.Wrd) (ds1 :: Types.Wrd) ->
                 let {
                   fail :: GHC.Prim.Void# -> Types.Wrd
                     <join 1> {- Arity: 1, Strictness: <L,A> -}
                   = \ (ds2 :: GHC.Prim.Void#)[OneShot] ->
                     Types.Err
                       (GHC.CString.unpackAppendCString#
                          Ops._add_t7
                          (GHC.Base.++
                             @ GHC.Types.Char
                             (Types.$fShowBind_$cshow ds)
                             (GHC.CString.unpackAppendCString#
                                Ops._add_t6
                                (Types.$fShowBind_$cshow ds1))))
                 } in
                 case ds of wild {
                   DEFAULT -> fail GHC.Prim.void#
                   Types.TypeCheck ds2
                   -> case ds2 of wild1 {
                        DEFAULT -> fail GHC.Prim.void#
                        Types.T_Int
                        -> case ds1 of wild2 {
                             DEFAULT -> fail GHC.Prim.void#
                             Types.TypeCheck ds3
                             -> case ds3 of wild3 {
                                  DEFAULT -> fail GHC.Prim.void#
                                  Types.T_Int -> Ops._add_t5
                                  Types.T_Double -> Ops._add_t4 } }
                        Types.T_Double
                        -> case ds1 of wild2 {
                             DEFAULT -> fail GHC.Prim.void#
                             Types.TypeCheck ds3
                             -> case ds3 of wild3 {
                                  DEFAULT -> fail GHC.Prim.void#
                                  Types.T_Int -> Ops._add_t4
                                  Types.T_Double -> Ops._add_t4 } }
                        Types.T_String
                        -> case ds1 of wild2 {
                             DEFAULT -> fail GHC.Prim.void#
                             Types.TypeCheck ds3
                             -> case ds3 of wild3 {
                                  DEFAULT -> fail GHC.Prim.void# Types.T_String -> Ops._add_t3 } }
                        Types.T_List t1
                        -> case ds1 of wild2 {
                             DEFAULT -> fail GHC.Prim.void#
                             Types.TypeCheck ds3
                             -> case ds3 of wild3 {
                                  DEFAULT -> fail GHC.Prim.void#
                                  Types.T_List t2
                                  -> case Types.$fEqBind_$c==1 t1 t2 of wild4 {
                                       GHC.Types.False
                                       -> Types.Err
                                            (GHC.CString.unpackAppendCString#
                                               Ops._add_t2
                                               (GHC.Base.++
                                                  @ GHC.Types.Char
                                                  (Types.$fShowBind_$cshowsPrec1
                                                     Types.$fShowBind2
                                                     t1
                                                     (GHC.Types.[] @ GHC.Types.Char))
                                                  (GHC.CString.unpackAppendCString#
                                                     Ops._add_t1
                                                     (Types.$fShowBind_$cshowsPrec1
                                                        Types.$fShowBind2
                                                        t2
                                                        (GHC.Types.[] @ GHC.Types.Char)))))
                                       GHC.Types.True -> wild } } } } }) -}
5c8d703e7770c4e8447f48c788ccdb0d
  _add_t1 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: (", t2="#) -}
d3a83146be059780d910ef8ebb52a172
  _add_t2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("`+`: Wrd mismatch of lists: t1="#) -}
1ff1d2522a596192337da198470f08d1
  _add_t3 :: Types.Wrd
  {- HasNoCafRefs, Strictness: m18,
     Unfolding: (Types.TypeCheck Types.T_String) -}
e31089f768d46058027bfb746718801b
  _add_t4 :: Types.Wrd
  {- HasNoCafRefs, Strictness: m18,
     Unfolding: (Types.TypeCheck Types.T_Double) -}
51384bce1096dbab3f5df8587ef090bc
  _add_t5 :: Types.Wrd
  {- HasNoCafRefs, Strictness: m18,
     Unfolding: (Types.TypeCheck Types.T_Int) -}
239af5d931f67d83328a03e6fe09ee73
  _add_t6 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: (", t_y="#) -}
6854d4481a0f7da1f8adb1f67c37d344
  _add_t7 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("`+`: Illegal input type: t_x="#) -}
7393a7111f1d62567db01add28631630
  _and :: Types.Op
  {- Strictness: m1, Unfolding: (Types.BinOp Ops._and1) -}
761f14c91e5005f23186c311f3faadc4
  _and1 :: Types.Wrd -> Types.Wrd -> Types.Wrd
  {- Arity: 2, Strictness: <S,1*U><S,1*U>m8, Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Types.Wrd) (w1 :: Types.Wrd) ->
                 case w of wild {
                   DEFAULT
                   -> Control.Exception.Base.patError
                        @ 'GHC.Types.LiftedRep
                        @ Types.Wrd
                        Ops._and2
                   Types.Bool a
                   -> case w1 of wild1 {
                        DEFAULT
                        -> Control.Exception.Base.patError
                             @ 'GHC.Types.LiftedRep
                             @ Types.Wrd
                             Ops._and2
                        Types.Bool b
                        -> Types.Bool
                             (case a of wild2 {
                                GHC.Types.False -> GHC.Types.False GHC.Types.True -> b }) } }) -}
1f7134b1bcd7b2d76cf3ff28f5e470eb
  _and2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("src/Ops.hs:246:15-51|lambda"#) -}
feb8d3e1dc28bbac0a91580b702d7e51
  _and_t :: Types.Wrd -> Types.Wrd -> Types.Wrd
  {- Arity: 2, Strictness: <S,1*U><S,U>,
     Unfolding: (\ (ds :: Types.Wrd) (ds1 :: Types.Wrd) ->
                 case ds of wild {
                   DEFAULT -> Ops._and_t4
                   Types.TypeCheck ds2
                   -> let {
                        fail :: GHC.Prim.Void# -> Types.Wrd
                          <join 1> {- Arity: 1, Strictness: <L,A> -}
                        = \ (ds3 :: GHC.Prim.Void#)[OneShot] ->
                          case ds1 of wild1 {
                            DEFAULT -> Ops._and_t4
                            Types.TypeCheck t2
                            -> Types.Err
                                 (GHC.CString.unpackAppendCString#
                                    Ops._and_t3
                                    (GHC.Base.++
                                       @ GHC.Types.Char
                                       (Types.$fShowBind_$cshowsPrec1
                                          Types.$fShowBind2
                                          ds2
                                          (GHC.Types.[] @ GHC.Types.Char))
                                       (GHC.CString.unpackAppendCString#
                                          Ops._and_t2
                                          (Types.$fShowBind_$cshowsPrec1
                                             Types.$fShowBind2
                                             t2
                                             (GHC.Types.[] @ GHC.Types.Char))))) }
                      } in
                      case ds2 of wild1 {
                        DEFAULT -> fail GHC.Prim.void#
                        Types.T_Bool
                        -> case ds1 of wild2 {
                             DEFAULT -> fail GHC.Prim.void#
                             Types.TypeCheck ds3
                             -> case ds3 of wild3 {
                                  DEFAULT -> fail GHC.Prim.void#
                                  Types.T_Bool -> Ops._and_t1 } } } }) -}
9abee605ef32f18c7645f7d41f1055c4
  _and_t1 :: Types.Wrd
  {- HasNoCafRefs, Strictness: m18,
     Unfolding: (Types.TypeCheck Types.T_Bool) -}
c14ad5c14b5d2e5fb364d19e075b9eee
  _and_t2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: (", RHS="#) -}
21a5a768a8a30fa169189ca503f4e131
  _and_t3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("`&&`: Illegal input type: LHS="#) -}
353bb4a43bbde43a2562081ad3324b7d
  _and_t4 :: Types.Wrd
  {- Strictness: b -}
215fc1033c75c9712a869c6feed0ad8c
  _div :: Types.Op
  {- Strictness: m1, Unfolding: (Types.BinOp Ops._div0) -}
c7f24128ce96a06c8e28007e599be754
  _div0 :: Types.Wrd -> Types.Wrd -> Types.Wrd
  {- Arity: 2, Strictness: <L,U><S,U>,
     Unfolding: (\ (ds :: Types.Wrd) (ds1 :: Types.Wrd) ->
                 let {
                   fail :: GHC.Prim.Void# -> Types.Wrd
                     <join 1> {- Arity: 1, Strictness: <L,A> -}
                   = \ (ds2 :: GHC.Prim.Void#)[OneShot] ->
                     let {
                       fail1 :: GHC.Prim.Void# -> Types.Wrd
                         <join 1> {- Arity: 1, Strictness: <L,A> -}
                       = \ (ds3 :: GHC.Prim.Void#)[OneShot] ->
                         Types.Err
                           (GHC.CString.unpackAppendCString#
                              Ops._div4
                              (GHC.Base.++
                                 @ GHC.Types.Char
                                 (Types.$fShowBind_$cshow ds)
                                 (GHC.CString.unpackAppendCString#
                                    Ops._add1
                                    (Types.$fShowBind_$cshow ds1))))
                     } in
                     case ds of wild {
                       DEFAULT -> fail1 GHC.Prim.void#
                       Types.Double x
                       -> case ds1 of wild1 {
                            DEFAULT -> fail1 GHC.Prim.void#
                            Types.Double y -> Types.Double (GHC.Float.divideDouble x y)
                            Types.Int y
                            -> Types.Double
                                 (case x of wild2 { GHC.Types.D# x1 ->
                                  case y of wild3 { GHC.Types.I# i ->
                                  case GHC.Prim./##
                                         x1
                                         (GHC.Prim.int2Double# i) of wild4 { DEFAULT ->
                                  GHC.Types.D# wild4 } } }) }
                       Types.Int x
                       -> case ds1 of wild1 {
                            DEFAULT -> fail1 GHC.Prim.void#
                            Types.Double y
                            -> Types.Double
                                 (case x of wild2 { GHC.Types.I# i ->
                                  case y of wild3 { GHC.Types.D# y1 ->
                                  case GHC.Prim./##
                                         (GHC.Prim.int2Double# i)
                                         y1 of wild4 { DEFAULT ->
                                  GHC.Types.D# wild4 } } })
                            Types.Int y
                            -> Types.Double
                                 (case x of wild2 { GHC.Types.I# i ->
                                  case y of wild3 { GHC.Types.I# i1 ->
                                  case GHC.Prim./##
                                         (GHC.Prim.int2Double# i)
                                         (GHC.Prim.int2Double# i1) of wild4 { DEFAULT ->
                                  GHC.Types.D# wild4 } } }) } }
                 } in
                 case ds1 of wild {
                   DEFAULT -> fail GHC.Prim.void#
                   Types.Double ds2
                   -> case ds2 of wild1 { GHC.Types.D# x ->
                      case GHC.Prim.==## x 0.0## of lwild {
                        DEFAULT -> fail GHC.Prim.void# 1# -> Ops._div1 } }
                   Types.Int ds2
                   -> case ds2 of wild1 { GHC.Types.I# ds3 ->
                      case ds3 of ds4 {
                        DEFAULT -> fail GHC.Prim.void# 0# -> Ops._div1 } } }) -}
c7a0deb313bb0c643627b2a368287071
  _div1 :: Types.Wrd
  {- Strictness: m12, Unfolding: (Types.Err Ops._div2) -}
8fca883992df908dfd44fa917f4b0d94
  _div2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Ops._div3) -}
dc79cca681dd9fde60bfc3224e841ebb
  _div3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Zero division error."#) -}
24854537f568b7ddd76b5c1c5f5d12d9
  _div4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("`/`: Illegal input value: x="#) -}
3c3682977b6d4c1153123fdd2d13c9f6
  _div_t :: Types.Wrd -> Types.Wrd -> Types.Wrd
  {- Arity: 2, Strictness: <S,U><L,U>,
     Unfolding: (\ (ds :: Types.Wrd) (ds1 :: Types.Wrd) ->
                 let {
                   fail :: GHC.Prim.Void# -> Types.Wrd
                     <join 1> {- Arity: 1, Strictness: <L,A> -}
                   = \ (ds2 :: GHC.Prim.Void#)[OneShot] ->
                     Types.Err
                       (GHC.CString.unpackAppendCString#
                          Ops._div_t1
                          (GHC.Base.++
                             @ GHC.Types.Char
                             (Types.$fShowBind_$cshow ds)
                             (GHC.CString.unpackAppendCString#
                                Ops._add_t6
                                (Types.$fShowBind_$cshow ds1))))
                 } in
                 case ds of wild {
                   DEFAULT -> fail GHC.Prim.void#
                   Types.TypeCheck ds2
                   -> case ds2 of wild1 {
                        DEFAULT -> fail GHC.Prim.void#
                        Types.T_Int
                        -> case ds1 of wild2 {
                             DEFAULT -> fail GHC.Prim.void#
                             Types.TypeCheck ds3
                             -> case ds3 of wild3 {
                                  DEFAULT -> fail GHC.Prim.void#
                                  Types.T_Int -> Ops._add_t4
                                  Types.T_Double -> Ops._add_t4 } }
                        Types.T_Double
                        -> case ds1 of wild2 {
                             DEFAULT -> fail GHC.Prim.void#
                             Types.TypeCheck ds3
                             -> case ds3 of wild3 {
                                  DEFAULT -> fail GHC.Prim.void#
                                  Types.T_Int -> Ops._add_t4
                                  Types.T_Double -> Ops._add_t4 } } } }) -}
4ccdf900e6414f9d5439cf6f1f1322a6
  _div_t1 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("`/`: Illegal input type: t_x="#) -}
98897850d11ece9baca132720c333054
  _eq :: Types.Op
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (Types.BinOp Ops._eq1) -}
02b6d287caa8d3347aead8cc64219277
  _eq1 :: Types.Wrd -> Types.Wrd -> Types.Wrd
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U><L,1*U>m8,
     Unfolding: InlineRule (2, True, False)
                (\ (a :: Types.Wrd) (b :: Types.Wrd) ->
                 Types.Bool (Types.$fEqBind_$c==2 a b)) -}
08bf420e34e5a00176a7c8b9ecc59fbd
  _eq_t :: Types.Wrd -> Types.Wrd -> Types.Wrd
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (ds :: Types.Wrd) (ds1 :: Types.Wrd) ->
                 case ds of wild {
                   DEFAULT -> Ops._eq_t2
                   Types.TypeCheck t1
                   -> case ds1 of wild1 {
                        DEFAULT -> Ops._eq_t2
                        Types.TypeCheck t2
                        -> case Types.$fEqBind_$c==1 t1 t2 of wild2 {
                             GHC.Types.False
                             -> Types.Err
                                  (GHC.CString.unpackAppendCString#
                                     Ops._eq_t1
                                     (GHC.Base.++
                                        @ GHC.Types.Char
                                        (Types.$fShowBind_$cshowsPrec1
                                           Types.$fShowBind2
                                           t1
                                           (GHC.Types.[] @ GHC.Types.Char))
                                        (GHC.CString.unpackAppendCString#
                                           Ops._and_t2
                                           (Types.$fShowBind_$cshowsPrec1
                                              Types.$fShowBind2
                                              t2
                                              (GHC.Types.[] @ GHC.Types.Char)))))
                             GHC.Types.True -> Ops._and_t1 } } }) -}
0b4c5bafe1abd3d6896f903edaf7e6e6
  _eq_t1 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("`=`: Wrd mismatch of both sides: LHS="#) -}
93d138834db02a17e8d5d1fe6d958275
  _eq_t2 :: Types.Wrd
  {- Strictness: b -}
b15abe61eb08beab401cca352a4a8bbd
  _fst :: Types.Op
  {- Strictness: m2, Unfolding: (Types.UnOp Ops._fst1) -}
81587449fb5ca4097ab3245bd3444a02
  _fst1 :: Types.Wrd -> Types.Wrd
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Types.Wrd) ->
                 case ds of wild {
                   DEFAULT
                   -> Control.Exception.Base.patError
                        @ 'GHC.Types.LiftedRep
                        @ Types.Wrd
                        Ops._fst2
                   Types.Tuple ds1
                   -> case ds1 of wild1 {
                        []
                        -> Control.Exception.Base.patError
                             @ 'GHC.Types.LiftedRep
                             @ Types.Wrd
                             Ops._fst2
                        : w1 ds2 -> w1 } }) -}
891d4cbd35d062601eaf7ec0eb646755
  _fst2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("src/Ops.hs:340:14-37|lambda"#) -}
8e0c15eac112574f20d150266d484758
  _fst_t :: Types.Wrd -> Types.Wrd
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: Types.Wrd) ->
                 case ds of wild {
                   DEFAULT
                   -> Types.Err
                        (GHC.CString.unpackAppendCString#
                           Ops._fst_t1
                           (Types.$fShowBind_$cshow wild))
                   Types.TypeCheck ds1
                   -> case ds1 of wild1 {
                        DEFAULT
                        -> Types.Err
                             (GHC.CString.unpackAppendCString#
                                Ops._fst_t1
                                (Types.$fShowBind_$cshow wild))
                        Types.T_Tuple ds2
                        -> case ds2 of wild2 {
                             []
                             -> Types.Err
                                  (GHC.CString.unpackAppendCString#
                                     Ops._fst_t1
                                     (Types.$fShowBind_$cshow wild))
                             : t ds3 -> Types.TypeCheck t } } }) -}
b6bc0ed9cd47a6358c2ac6aace023af5
  _fst_t1 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("fst: Illegal input type: "#) -}
bfbd72c3e86b01cdd3890f0a4c94d069
  _geq :: Types.Op
  {- Strictness: m1, Unfolding: (Types.BinOp Ops._geq0) -}
c15f97bb7cdf654872dc219c23b5c912
  _geq0 :: Types.Wrd -> Types.Wrd -> Types.Wrd
  {- Arity: 2, Strictness: <S,1*U><S,1*U>m8, Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Types.Wrd) (w1 :: Types.Wrd) ->
                 case w of wild {
                   DEFAULT -> Ops._geq1
                   Types.Double x
                   -> case w1 of wild1 {
                        DEFAULT -> Ops._geq1
                        Types.Double y
                        -> Types.Bool
                             (case x of wild2 { GHC.Types.D# x1 ->
                              case y of wild3 { GHC.Types.D# y1 ->
                              GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.>=## x1 y1) } })
                        Types.Int y
                        -> Types.Bool
                             (case x of wild2 { GHC.Types.D# x1 ->
                              case y of wild3 { GHC.Types.I# i ->
                              GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.>=## x1 (GHC.Prim.int2Double# i)) } }) }
                   Types.Int x
                   -> case w1 of wild1 {
                        DEFAULT -> Ops._geq1
                        Types.Double y
                        -> Types.Bool
                             (case x of wild2 { GHC.Types.I# i ->
                              case y of wild3 { GHC.Types.D# y1 ->
                              GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.>=## (GHC.Prim.int2Double# i) y1) } })
                        Types.Int y -> Types.Bool (GHC.Classes.geInt x y) } }) -}
a7bcb8891f573e49b5a0e06bc847ee12
  _geq1 :: Types.Wrd
  {- Strictness: b -}
ebcbe58eefbb172657035c5cdb93032c
  _geq_t :: Types.Wrd -> Types.Wrd -> Types.Wrd
  {- Arity: 2, Strictness: <S,1*U><S,U>,
     Unfolding: (\ (ds :: Types.Wrd) (ds1 :: Types.Wrd) ->
                 case ds of wild {
                   DEFAULT -> Ops._geq_t2
                   Types.TypeCheck ds2
                   -> let {
                        fail :: GHC.Prim.Void# -> Types.Wrd
                          <join 1> {- Arity: 1, Strictness: <L,A> -}
                        = \ (ds3 :: GHC.Prim.Void#)[OneShot] ->
                          case ds1 of wild1 {
                            DEFAULT -> Ops._geq_t2
                            Types.TypeCheck t2
                            -> Types.Err
                                 (GHC.CString.unpackAppendCString#
                                    Ops._geq_t1
                                    (GHC.Base.++
                                       @ GHC.Types.Char
                                       (Types.$fShowBind_$cshowsPrec1
                                          Types.$fShowBind2
                                          ds2
                                          (GHC.Types.[] @ GHC.Types.Char))
                                       (GHC.CString.unpackAppendCString#
                                          Ops._and_t2
                                          (Types.$fShowBind_$cshowsPrec1
                                             Types.$fShowBind2
                                             t2
                                             (GHC.Types.[] @ GHC.Types.Char))))) }
                      } in
                      case ds2 of wild1 {
                        DEFAULT -> fail GHC.Prim.void#
                        Types.T_Int
                        -> case ds1 of wild2 {
                             DEFAULT -> fail GHC.Prim.void#
                             Types.TypeCheck ds3
                             -> case ds3 of wild3 {
                                  DEFAULT -> fail GHC.Prim.void#
                                  Types.T_Int -> Ops._and_t1
                                  Types.T_Double -> Ops._and_t1 } }
                        Types.T_Double
                        -> case ds1 of wild2 {
                             DEFAULT -> fail GHC.Prim.void#
                             Types.TypeCheck ds3
                             -> case ds3 of wild3 {
                                  DEFAULT -> fail GHC.Prim.void#
                                  Types.T_Int -> Ops._and_t1
                                  Types.T_Double -> Ops._and_t1 } } } }) -}
bd2539ed84360f360a08990f0a8f318d
  _geq_t1 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("`>=`: Illegal input type: LHS="#) -}
12ad9bd199617daac3ff7c9a1f64271a
  _geq_t2 :: Types.Wrd
  {- Strictness: b -}
61ce3e584263fb0db0af18116e87db36
  _getType :: Types.Wrd -> Types.Type
  {- Arity: 1, Strictness: <S,1*U> -}
10c1e554db32cd582e32b2e0fe5474a3
  _gt :: Types.Op
  {- Strictness: m1, Unfolding: (Types.BinOp Ops._gt0) -}
cd2848feb8174d09af958751749a9e7f
  _gt0 :: Types.Wrd -> Types.Wrd -> Types.Wrd
  {- Arity: 2, Strictness: <S,1*U><S,1*U>m8, Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Types.Wrd) (w1 :: Types.Wrd) ->
                 case w of wild {
                   DEFAULT -> Ops._gt1
                   Types.Double x
                   -> case w1 of wild1 {
                        DEFAULT -> Ops._gt1
                        Types.Double y
                        -> Types.Bool
                             (case x of wild2 { GHC.Types.D# x1 ->
                              case y of wild3 { GHC.Types.D# y1 ->
                              GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.>## x1 y1) } })
                        Types.Int y
                        -> Types.Bool
                             (case x of wild2 { GHC.Types.D# x1 ->
                              case y of wild3 { GHC.Types.I# i ->
                              GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.>## x1 (GHC.Prim.int2Double# i)) } }) }
                   Types.Int x
                   -> case w1 of wild1 {
                        DEFAULT -> Ops._gt1
                        Types.Double y
                        -> Types.Bool
                             (case x of wild2 { GHC.Types.I# i ->
                              case y of wild3 { GHC.Types.D# y1 ->
                              GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.>## (GHC.Prim.int2Double# i) y1) } })
                        Types.Int y -> Types.Bool (GHC.Classes.gtInt x y) } }) -}
def8fb29a8458a147dc65ea0a5cf9fdb
  _gt1 :: Types.Wrd
  {- Strictness: b -}
a32901c07b78e5eb028bb5874981efbb
  _gt_t :: Types.Wrd -> Types.Wrd -> Types.Wrd
  {- Arity: 2, Strictness: <S,1*U><S,U>,
     Unfolding: (\ (ds :: Types.Wrd) (ds1 :: Types.Wrd) ->
                 case ds of wild {
                   DEFAULT -> Ops._gt_t2
                   Types.TypeCheck ds2
                   -> let {
                        fail :: GHC.Prim.Void# -> Types.Wrd
                          <join 1> {- Arity: 1, Strictness: <L,A> -}
                        = \ (ds3 :: GHC.Prim.Void#)[OneShot] ->
                          case ds1 of wild1 {
                            DEFAULT -> Ops._gt_t2
                            Types.TypeCheck t2
                            -> Types.Err
                                 (GHC.CString.unpackAppendCString#
                                    Ops._gt_t1
                                    (GHC.Base.++
                                       @ GHC.Types.Char
                                       (Types.$fShowBind_$cshowsPrec1
                                          Types.$fShowBind2
                                          ds2
                                          (GHC.Types.[] @ GHC.Types.Char))
                                       (GHC.CString.unpackAppendCString#
                                          Ops._and_t2
                                          (Types.$fShowBind_$cshowsPrec1
                                             Types.$fShowBind2
                                             t2
                                             (GHC.Types.[] @ GHC.Types.Char))))) }
                      } in
                      case ds2 of wild1 {
                        DEFAULT -> fail GHC.Prim.void#
                        Types.T_Int
                        -> case ds1 of wild2 {
                             DEFAULT -> fail GHC.Prim.void#
                             Types.TypeCheck ds3
                             -> case ds3 of wild3 {
                                  DEFAULT -> fail GHC.Prim.void#
                                  Types.T_Int -> Ops._and_t1
                                  Types.T_Double -> Ops._and_t1 } }
                        Types.T_Double
                        -> case ds1 of wild2 {
                             DEFAULT -> fail GHC.Prim.void#
                             Types.TypeCheck ds3
                             -> case ds3 of wild3 {
                                  DEFAULT -> fail GHC.Prim.void#
                                  Types.T_Int -> Ops._and_t1
                                  Types.T_Double -> Ops._and_t1 } } } }) -}
59092bd74d2d278cba5cfbd0fa9b8e41
  _gt_t1 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("`>`: Illegal input type: LHS="#) -}
a64288728a96aab1a2539f66f472945b
  _gt_t2 :: Types.Wrd
  {- Strictness: b -}
f233998f3319ab14edd46dbf2c786e2d
  _head :: Types.Op
  {- Strictness: m2, Unfolding: (Types.UnOp Ops._head0) -}
6ffb729093c9b4409bce7d14bdb1afe0
  _head0 :: Types.Wrd -> Types.Wrd
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Types.Wrd) ->
                 case ds of wild {
                   DEFAULT -> Ops._head4
                   Types.List ds1
                   -> case ds1 of wild1 { [] -> Ops._head1 : x ds2 -> x } }) -}
543150125bb8e35a15f1e68b296f4fb8
  _head1 :: Types.Wrd
  {- Strictness: m12, Unfolding: (Types.Err Ops._head2) -}
10595b0063f9a03ed93ee60883e08627
  _head2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Ops._head3) -}
3872cd20e640f04e630362819e26fdd3
  _head3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("head: Empty list."#) -}
74047e8d1ea8019d93adb927c2de1942
  _head4 :: Types.Wrd
  {- Strictness: b -}
f6600d36d63907fe704d60e2bbcc68c6
  _head_t :: Types.Wrd -> Types.Wrd
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: Types.Wrd) ->
                 case ds of wild {
                   DEFAULT -> Ops._head_t2
                   Types.TypeCheck ds1
                   -> case ds1 of wild1 {
                        DEFAULT
                        -> Types.Err
                             (GHC.CString.unpackAppendCString#
                                Ops._head_t1
                                (Types.$fShowBind_$cshowsPrec1
                                   Types.$fShowBind2
                                   wild1
                                   (GHC.Types.[] @ GHC.Types.Char)))
                        Types.T_List t -> Types.TypeCheck t } }) -}
341a78104a1baa5a630af1beff815252
  _head_t1 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("head: Illegal input type: "#) -}
96a4f82a79f29e1a1d0a7533dd40340c
  _head_t2 :: Types.Wrd
  {- Strictness: b -}
d9804ac97bdf090501ea00d6b282fce9
  _isConsistentType :: Types.Exp -> GHC.Maybe.Maybe Types.Type
  {- Arity: 1, Strictness: <S,1*U> -}
cef60dfe0de8bf011e8990eb19497bf3
  _isEmpty :: Types.Op
  {- Strictness: m2, Unfolding: (Types.UnOp Ops._isEmpty1) -}
7c2bd0f7a8b861d14bd53fecabbf247c
  _isEmpty1 :: Types.Wrd -> Types.Wrd
  {- Arity: 1, Strictness: <S,1*U>m8,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Types.Wrd) ->
                 case ds of wild {
                   DEFAULT -> Ops._isEmpty2
                   Types.List ls
                   -> Types.Bool
                        (GHC.Classes.$fEq[]_$c==
                           @ Types.Wrd
                           Types.$fEqWrd
                           ls
                           (GHC.Types.[] @ Types.Wrd)) }) -}
27e075af8713c7d1015794b6d9b674b1
  _isEmpty2 :: Types.Wrd
  {- Strictness: b -}
431965d892e2b6a4f09b46963acb9535
  _isEmpty_t :: Types.Wrd -> Types.Wrd
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: Types.Wrd) ->
                 case ds of wild {
                   DEFAULT -> Ops._isEmpty_t2
                   Types.TypeCheck ds1
                   -> case ds1 of wild1 {
                        DEFAULT
                        -> Types.Err
                             (GHC.CString.unpackAppendCString#
                                Ops._isEmpty_t1
                                (Types.$fShowBind_$cshowsPrec1
                                   Types.$fShowBind2
                                   wild1
                                   (GHC.Types.[] @ GHC.Types.Char)))
                        Types.T_List ds2 -> Ops._and_t1 } }) -}
7ee732c9199798439f16df2880508448
  _isEmpty_t1 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("isEmpty: Illegal input type: "#) -}
52a3e13e54ffc52d7274ef5c2a0c958c
  _isEmpty_t2 :: Types.Wrd
  {- Strictness: b -}
ec4a64dacfd74c2e25c459a263bf103b
  _leq :: Types.Op
  {- Strictness: m1, Unfolding: (Types.BinOp Ops._leq0) -}
96580e36e3a3194d2178c5c1399518b7
  _leq0 :: Types.Wrd -> Types.Wrd -> Types.Wrd
  {- Arity: 2, Strictness: <S,1*U><S,1*U>m8, Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Types.Wrd) (w1 :: Types.Wrd) ->
                 case w of wild {
                   DEFAULT -> Ops._leq1
                   Types.Double x
                   -> case w1 of wild1 {
                        DEFAULT -> Ops._leq1
                        Types.Double y
                        -> Types.Bool
                             (case x of wild2 { GHC.Types.D# x1 ->
                              case y of wild3 { GHC.Types.D# y1 ->
                              GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<=## x1 y1) } })
                        Types.Int y
                        -> Types.Bool
                             (case x of wild2 { GHC.Types.D# x1 ->
                              case y of wild3 { GHC.Types.I# i ->
                              GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.<=## x1 (GHC.Prim.int2Double# i)) } }) }
                   Types.Int x
                   -> case w1 of wild1 {
                        DEFAULT -> Ops._leq1
                        Types.Double y
                        -> Types.Bool
                             (case x of wild2 { GHC.Types.I# i ->
                              case y of wild3 { GHC.Types.D# y1 ->
                              GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.<=## (GHC.Prim.int2Double# i) y1) } })
                        Types.Int y -> Types.Bool (GHC.Classes.leInt x y) } }) -}
79df9541b17b07c6d5d51b4ed0f3450e
  _leq1 :: Types.Wrd
  {- Strictness: b -}
ec683e3ce413056a1a07c115d3e93566
  _leq_t :: Types.Wrd -> Types.Wrd -> Types.Wrd
  {- Arity: 2, Strictness: <S,1*U><S,U>,
     Unfolding: (\ (ds :: Types.Wrd) (ds1 :: Types.Wrd) ->
                 case ds of wild {
                   DEFAULT -> Ops._leq_t1
                   Types.TypeCheck ds2
                   -> let {
                        fail :: GHC.Prim.Void# -> Types.Wrd
                          <join 1> {- Arity: 1, Strictness: <L,A> -}
                        = \ (ds3 :: GHC.Prim.Void#)[OneShot] ->
                          case ds1 of wild1 {
                            DEFAULT -> Ops._leq_t1
                            Types.TypeCheck t2
                            -> Types.Err
                                 (GHC.CString.unpackAppendCString#
                                    Ops._geq_t1
                                    (GHC.Base.++
                                       @ GHC.Types.Char
                                       (Types.$fShowBind_$cshowsPrec1
                                          Types.$fShowBind2
                                          ds2
                                          (GHC.Types.[] @ GHC.Types.Char))
                                       (GHC.CString.unpackAppendCString#
                                          Ops._and_t2
                                          (Types.$fShowBind_$cshowsPrec1
                                             Types.$fShowBind2
                                             t2
                                             (GHC.Types.[] @ GHC.Types.Char))))) }
                      } in
                      case ds2 of wild1 {
                        DEFAULT -> fail GHC.Prim.void#
                        Types.T_Int
                        -> case ds1 of wild2 {
                             DEFAULT -> fail GHC.Prim.void#
                             Types.TypeCheck ds3
                             -> case ds3 of wild3 {
                                  DEFAULT -> fail GHC.Prim.void#
                                  Types.T_Int -> Ops._and_t1
                                  Types.T_Double -> Ops._and_t1 } }
                        Types.T_Double
                        -> case ds1 of wild2 {
                             DEFAULT -> fail GHC.Prim.void#
                             Types.TypeCheck ds3
                             -> case ds3 of wild3 {
                                  DEFAULT -> fail GHC.Prim.void#
                                  Types.T_Int -> Ops._and_t1
                                  Types.T_Double -> Ops._and_t1 } } } }) -}
bfde3e222592188fb46b74c1e2e21522
  _leq_t1 :: Types.Wrd
  {- Strictness: b -}
b71937b3e209d9ec203facf934f56aa4
  _lt :: Types.Op
  {- Strictness: m1, Unfolding: (Types.BinOp Ops._lt0) -}
95be6f09728ca03cc43b08ddf7e62d01
  _lt0 :: Types.Wrd -> Types.Wrd -> Types.Wrd
  {- Arity: 2, Strictness: <S,1*U><S,1*U>m8, Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Types.Wrd) (w1 :: Types.Wrd) ->
                 case w of wild {
                   DEFAULT -> Ops._lt1
                   Types.Double x
                   -> case w1 of wild1 {
                        DEFAULT -> Ops._lt1
                        Types.Double y
                        -> Types.Bool
                             (case x of wild2 { GHC.Types.D# x1 ->
                              case y of wild3 { GHC.Types.D# y1 ->
                              GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<## x1 y1) } })
                        Types.Int y
                        -> Types.Bool
                             (case x of wild2 { GHC.Types.D# x1 ->
                              case y of wild3 { GHC.Types.I# i ->
                              GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.<## x1 (GHC.Prim.int2Double# i)) } }) }
                   Types.Int x
                   -> case w1 of wild1 {
                        DEFAULT -> Ops._lt1
                        Types.Double y
                        -> Types.Bool
                             (case x of wild2 { GHC.Types.I# i ->
                              case y of wild3 { GHC.Types.D# y1 ->
                              GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.<## (GHC.Prim.int2Double# i) y1) } })
                        Types.Int y -> Types.Bool (GHC.Classes.ltInt x y) } }) -}
1bb107a6397e7a6f0ff5bca225cc2d0a
  _lt1 :: Types.Wrd
  {- Strictness: b -}
30dae757c9b8f9ce3df8a767799a55b2
  _lt_t :: Types.Wrd -> Types.Wrd -> Types.Wrd
  {- Arity: 2, Strictness: <S,1*U><S,U>,
     Unfolding: (\ (ds :: Types.Wrd) (ds1 :: Types.Wrd) ->
                 case ds of wild {
                   DEFAULT -> Ops._lt_t2
                   Types.TypeCheck ds2
                   -> let {
                        fail :: GHC.Prim.Void# -> Types.Wrd
                          <join 1> {- Arity: 1, Strictness: <L,A> -}
                        = \ (ds3 :: GHC.Prim.Void#)[OneShot] ->
                          case ds1 of wild1 {
                            DEFAULT -> Ops._lt_t2
                            Types.TypeCheck t2
                            -> Types.Err
                                 (GHC.CString.unpackAppendCString#
                                    Ops._lt_t1
                                    (GHC.Base.++
                                       @ GHC.Types.Char
                                       (Types.$fShowBind_$cshowsPrec1
                                          Types.$fShowBind2
                                          ds2
                                          (GHC.Types.[] @ GHC.Types.Char))
                                       (GHC.CString.unpackAppendCString#
                                          Ops._and_t2
                                          (Types.$fShowBind_$cshowsPrec1
                                             Types.$fShowBind2
                                             t2
                                             (GHC.Types.[] @ GHC.Types.Char))))) }
                      } in
                      case ds2 of wild1 {
                        DEFAULT -> fail GHC.Prim.void#
                        Types.T_Int
                        -> case ds1 of wild2 {
                             DEFAULT -> fail GHC.Prim.void#
                             Types.TypeCheck ds3
                             -> case ds3 of wild3 {
                                  DEFAULT -> fail GHC.Prim.void#
                                  Types.T_Int -> Ops._and_t1
                                  Types.T_Double -> Ops._and_t1 } }
                        Types.T_Double
                        -> case ds1 of wild2 {
                             DEFAULT -> fail GHC.Prim.void#
                             Types.TypeCheck ds3
                             -> case ds3 of wild3 {
                                  DEFAULT -> fail GHC.Prim.void#
                                  Types.T_Int -> Ops._and_t1
                                  Types.T_Double -> Ops._and_t1 } } } }) -}
ad669454c0d29617cb7160243300953c
  _lt_t1 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("`<`: Illegal input type: LHS="#) -}
cf39bbdd99966e42cb93443d967ea025
  _lt_t2 :: Types.Wrd
  {- Strictness: b -}
5e61e4c8c5e4279be0fdd31f9f6c4649
  _map :: Types.Op
  {- Strictness: m3, Unfolding: (Types.FuncOp Ops._map1) -}
41bf598ee21cf0654b76bf275279c65f
  _map0 :: Types.Exp -> Types.Wrd
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ (ds :: [Types.Wrd]) ->
                 let {
                   fail :: GHC.Prim.Void# -> Types.Wrd
                     <join 1> {- Arity: 1, Strictness: <L,A> -}
                   = \ (ds1 :: GHC.Prim.Void#)[OneShot] ->
                     Types.Err
                       (GHC.CString.unpackAppendCString#
                          Ops._map2
                          (case ds of wild {
                             [] -> Ops.toList1
                             : x xs
                             -> GHC.Types.:
                                  @ GHC.Types.Char
                                  GHC.Show.showList__3
                                  (GHC.Base.++
                                     @ GHC.Types.Char
                                     (Types.$fShowBind_$cshow x)
                                     (case Ops.$wshowl xs of ww { (#,#) ww1 ww2 ->
                                      GHC.Types.: @ GHC.Types.Char ww1 ww2 })) }))
                 } in
                 case ds of wild {
                   [] -> fail GHC.Prim.void#
                   : ds1 ds2
                   -> case ds1 of wild1 {
                        DEFAULT -> fail GHC.Prim.void#
                        Types.Func f
                        -> case ds2 of wild2 {
                             [] -> fail GHC.Prim.void#
                             : ds3 ds4
                             -> case ds3 of wild3 {
                                  DEFAULT -> fail GHC.Prim.void#
                                  Types.List ls
                                  -> case ds4 of wild4 {
                                       []
                                       -> Types.PreList
                                            (GHC.Base.map
                                               @ Types.Wrd
                                               @ [Types.Wrd]
                                               (\ (w :: Types.Wrd) ->
                                                GHC.Types.:
                                                  @ Types.Wrd
                                                  wild1
                                                  (GHC.Types.:
                                                     @ Types.Wrd
                                                     w
                                                     (GHC.Types.[] @ Types.Wrd)))
                                               ls)
                                       : ipv ipv1 -> fail GHC.Prim.void# } } } } }) -}
38514ef66db8038c6afa23e1d444abf2
  _map1 :: (GHC.Types.Int, Types.Exp -> Types.Wrd)
  {- Strictness: m, Unfolding: ((Ops._map3, Ops._map0)) -}
5a980710633d0031752e33525ab306c7
  _map2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("map: Illegal input value: "#) -}
26cbd2d6ef0999513a82757469e015cc
  _map3 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 2#) -}
b72c2548240667c5067939ef45ec7369
  _map_t :: Types.Exp -> Types.Wrd
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ (ds :: [Types.Wrd]) ->
                 let {
                   fail :: GHC.Prim.Void# -> Types.Wrd
                     <join 1> {- Arity: 1, Strictness: <L,A> -}
                   = \ (ds1 :: GHC.Prim.Void#)[OneShot] ->
                     Types.Err
                       (GHC.CString.unpackAppendCString#
                          Ops._map_t2
                          (case ds of wild {
                             [] -> Ops.toList1
                             : x xs
                             -> GHC.Types.:
                                  @ GHC.Types.Char
                                  GHC.Show.showList__3
                                  (GHC.Base.++
                                     @ GHC.Types.Char
                                     (Types.$fShowBind_$cshow x)
                                     (case Ops.$wshowl xs of ww { (#,#) ww1 ww2 ->
                                      GHC.Types.: @ GHC.Types.Char ww1 ww2 })) }))
                 } in
                 case ds of wild {
                   [] -> fail GHC.Prim.void#
                   : ds1 ds2
                   -> case ds1 of wild1 {
                        DEFAULT -> fail GHC.Prim.void#
                        Types.TypeCheck ds3
                        -> case ds3 of wild2 {
                             DEFAULT -> fail GHC.Prim.void#
                             Types.T_Func ds4
                             -> case ds2 of wild3 {
                                  [] -> fail GHC.Prim.void#
                                  : ds5 ds6
                                  -> case ds5 of wild4 {
                                       DEFAULT -> fail GHC.Prim.void#
                                       Types.TypeCheck ds7
                                       -> case ds7 of wild5 {
                                            DEFAULT -> fail GHC.Prim.void#
                                            Types.T_List t
                                            -> case ds6 of wild6 {
                                                 [] -> Ops._map_t1
                                                 : ipv ipv1 -> fail GHC.Prim.void# } } } } } } }) -}
8a5f87431d1f11d7bf62df526ba8a76a
  _map_t1 :: Types.Wrd
  {- HasNoCafRefs, Strictness: m18,
     Unfolding: (Types.TypeCheck Types.T_PreList) -}
5666b8c9336195b9a1a82d74f67442c0
  _map_t2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("seq: Illegal input type: "#) -}
a051d9f308344f05a608d3aeddadf2b9
  _mul :: Types.Op
  {- Strictness: m1, Unfolding: (Types.BinOp Ops._mul0) -}
46a2cbf47aa9c055cdb44a3798ddcc6a
  _mul0 :: Types.Wrd -> Types.Wrd -> Types.Wrd
  {- Arity: 2, Strictness: <S,U><L,U>,
     Unfolding: (\ (ds :: Types.Wrd) (ds1 :: Types.Wrd) ->
                 let {
                   fail :: GHC.Prim.Void# -> Types.Wrd
                     <join 1> {- Arity: 1, Strictness: <L,A> -}
                   = \ (ds2 :: GHC.Prim.Void#)[OneShot] ->
                     Types.Err
                       (GHC.CString.unpackAppendCString#
                          Ops._mul1
                          (GHC.Base.++
                             @ GHC.Types.Char
                             (Types.$fShowBind_$cshow ds)
                             (GHC.CString.unpackAppendCString#
                                Ops._add1
                                (Types.$fShowBind_$cshow ds1))))
                 } in
                 case ds of wild {
                   DEFAULT -> fail GHC.Prim.void#
                   Types.Double x
                   -> case ds1 of wild1 {
                        DEFAULT -> fail GHC.Prim.void#
                        Types.Double y -> Types.Double (GHC.Float.timesDouble x y)
                        Types.Int y
                        -> Types.Double
                             (case x of wild2 { GHC.Types.D# x1 ->
                              case y of wild3 { GHC.Types.I# i ->
                              GHC.Types.D# (GHC.Prim.*## x1 (GHC.Prim.int2Double# i)) } }) }
                   Types.Int x
                   -> case ds1 of wild1 {
                        DEFAULT -> fail GHC.Prim.void#
                        Types.Double y
                        -> Types.Double
                             (case x of wild2 { GHC.Types.I# i ->
                              case y of wild3 { GHC.Types.D# y1 ->
                              GHC.Types.D# (GHC.Prim.*## (GHC.Prim.int2Double# i) y1) } })
                        Types.Int y -> Types.Int (GHC.Num.$fNumInt_$c* x y) } }) -}
872dd2587431d4cda8474aedd8a39577
  _mul1 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("`*`: Illegal input value: x="#) -}
ff8705e11c17fc62e66b809c0b3a1db0
  _mul_t :: Types.Wrd -> Types.Wrd -> Types.Wrd
  {- Arity: 2, Strictness: <S,U><L,U>,
     Unfolding: (\ (ds :: Types.Wrd) (ds1 :: Types.Wrd) ->
                 let {
                   fail :: GHC.Prim.Void# -> Types.Wrd
                     <join 1> {- Arity: 1, Strictness: <L,A> -}
                   = \ (ds2 :: GHC.Prim.Void#)[OneShot] ->
                     Types.Err
                       (GHC.CString.unpackAppendCString#
                          Ops._mul_t1
                          (GHC.Base.++
                             @ GHC.Types.Char
                             (Types.$fShowBind_$cshow ds)
                             (GHC.CString.unpackAppendCString#
                                Ops._add_t6
                                (Types.$fShowBind_$cshow ds1))))
                 } in
                 case ds of wild {
                   DEFAULT -> fail GHC.Prim.void#
                   Types.TypeCheck ds2
                   -> case ds2 of wild1 {
                        DEFAULT -> fail GHC.Prim.void#
                        Types.T_Int
                        -> case ds1 of wild2 {
                             DEFAULT -> fail GHC.Prim.void#
                             Types.TypeCheck ds3
                             -> case ds3 of wild3 {
                                  DEFAULT -> fail GHC.Prim.void#
                                  Types.T_Int -> Ops._add_t5
                                  Types.T_Double -> Ops._add_t4 } }
                        Types.T_Double
                        -> case ds1 of wild2 {
                             DEFAULT -> fail GHC.Prim.void#
                             Types.TypeCheck ds3
                             -> case ds3 of wild3 {
                                  DEFAULT -> fail GHC.Prim.void#
                                  Types.T_Int -> Ops._add_t4
                                  Types.T_Double -> Ops._add_t4 } } } }) -}
3b28df4fd6f5288e63fc840b80fb328a
  _mul_t1 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("`*`: Illegal input type: t_x="#) -}
d79823e22df75a44684136c59c88058c
  _neq :: Types.Op
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (Types.BinOp Ops._neq1) -}
3edca622fdecbfe802460f4f3bde2480
  _neq1 :: Types.Wrd -> Types.Wrd -> Types.Wrd
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U><L,1*U>m8,
     Unfolding: InlineRule (2, True, False)
                (\ (a :: Types.Wrd) (b :: Types.Wrd) ->
                 Types.Bool
                   (case Types.$fEqBind_$c==2 a b of wild {
                      GHC.Types.False -> GHC.Types.True
                      GHC.Types.True -> GHC.Types.False })) -}
e486db333126873a6b1d30b0e78e94e3
  _neq_t :: Types.Wrd -> Types.Wrd -> Types.Wrd
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (ds :: Types.Wrd) (ds1 :: Types.Wrd) ->
                 case ds of wild {
                   DEFAULT -> Ops._neq_t2
                   Types.TypeCheck t1
                   -> case ds1 of wild1 {
                        DEFAULT -> Ops._neq_t2
                        Types.TypeCheck t2
                        -> case Types.$fEqBind_$c==1 t1 t2 of wild2 {
                             GHC.Types.False
                             -> Types.Err
                                  (GHC.CString.unpackAppendCString#
                                     Ops._neq_t1
                                     (GHC.Base.++
                                        @ GHC.Types.Char
                                        (Types.$fShowBind_$cshowsPrec1
                                           Types.$fShowBind2
                                           t1
                                           (GHC.Types.[] @ GHC.Types.Char))
                                        (GHC.CString.unpackAppendCString#
                                           Ops._and_t2
                                           (Types.$fShowBind_$cshowsPrec1
                                              Types.$fShowBind2
                                              t2
                                              (GHC.Types.[] @ GHC.Types.Char)))))
                             GHC.Types.True -> Ops._and_t1 } } }) -}
25f61afe81a6cef5b012c00fa422eab8
  _neq_t1 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("`!=`: Wrd mismatch of both sides: LHS="#) -}
90b7cd80c0bc7e4f9eb8ef00ebbef7ed
  _neq_t2 :: Types.Wrd
  {- Strictness: b -}
a65510cb8f47ae923832075fd1a89342
  _not :: Types.Op
  {- Strictness: m2, Unfolding: (Types.UnOp Ops._not1) -}
2e32f8b1bef196b54e178f31838f20a8
  _not1 :: Types.Wrd -> Types.Wrd
  {- Arity: 1, Strictness: <S,1*U>m8,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Types.Wrd) ->
                 case ds of wild {
                   DEFAULT -> Ops._not2
                   Types.Bool b
                   -> Types.Bool
                        (case b of wild1 {
                           GHC.Types.False -> GHC.Types.True
                           GHC.Types.True -> GHC.Types.False }) }) -}
0aeec3e4c926e0927fdd8b1e5332a6f3
  _not2 :: Types.Wrd
  {- Strictness: b -}
d5ef90f6c2e9cc24b4d26b4d99048ee9
  _not_t :: Types.Wrd -> Types.Wrd
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: Types.Wrd) ->
                 case ds of wild {
                   DEFAULT -> Ops._not_t2
                   Types.TypeCheck ds1
                   -> case ds1 of wild1 {
                        DEFAULT
                        -> Types.Err
                             (GHC.CString.unpackAppendCString#
                                Ops._not_t1
                                (Types.$fShowBind_$cshowsPrec1
                                   Types.$fShowBind2
                                   wild1
                                   (GHC.Types.[] @ GHC.Types.Char)))
                        Types.T_Bool -> Ops._and_t1 } }) -}
fa61e4f175816c91155851d86c7dc9a6
  _not_t1 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("`!`: Illegal input type: "#) -}
b7a68909212e0e8ff386eae137cde6b6
  _not_t2 :: Types.Wrd
  {- Strictness: b -}
e818ece1458be5a239b38177a8de4882
  _opls :: [Types.StrOp]
  {- Strictness: m2,
     Unfolding: (GHC.Types.: @ Types.StrOp Ops._opls93 Ops._opls1) -}
d53cb77b9c5a5467b8e4b87d5c5a0175
  _opls1 :: [Types.StrOp]
  {- Strictness: m2,
     Unfolding: (GHC.Types.: @ Types.StrOp Ops._opls90 Ops._opls2) -}
bacc4c811bbcf9dc2e9eb957b778ca7c
  _opls10 :: [Types.StrOp]
  {- Strictness: m2,
     Unfolding: (GHC.Types.: @ Types.StrOp Ops._opls63 Ops._opls11) -}
bdf6d0b9258e19ee8c7282d3221729fb
  _opls11 :: [Types.StrOp]
  {- Strictness: m2,
     Unfolding: (GHC.Types.: @ Types.StrOp Ops._opls60 Ops._opls12) -}
d8bf223fbf13b5f204ccb46a9ede15ff
  _opls12 :: [Types.StrOp]
  {- Strictness: m2,
     Unfolding: (GHC.Types.: @ Types.StrOp Ops._opls57 Ops._opls13) -}
afb5781d064c4931bc0f17c2385a8324
  _opls13 :: [Types.StrOp]
  {- Strictness: m2,
     Unfolding: (GHC.Types.: @ Types.StrOp Ops._opls54 Ops._opls14) -}
5f4c92b5c0e79c414e7ceabec3f9d8b9
  _opls14 :: [Types.StrOp]
  {- Strictness: m2,
     Unfolding: (GHC.Types.: @ Types.StrOp Ops._opls51 Ops._opls15) -}
c500f46fe69e5ea89f99b6f99f491a24
  _opls15 :: [Types.StrOp]
  {- Strictness: m2,
     Unfolding: (GHC.Types.: @ Types.StrOp Ops._opls48 Ops._opls16) -}
d26ae9ccf42ebc75d713d821fe00dbcf
  _opls16 :: [Types.StrOp]
  {- Strictness: m2,
     Unfolding: (GHC.Types.: @ Types.StrOp Ops._opls45 Ops._opls17) -}
0f38d104f73de9e6a782ea7ba57c5685
  _opls17 :: [Types.StrOp]
  {- Strictness: m2,
     Unfolding: (GHC.Types.: @ Types.StrOp Ops._opls42 Ops._opls18) -}
97e7424e8319b4900bb4f276232f88e8
  _opls18 :: [Types.StrOp]
  {- Strictness: m2,
     Unfolding: (GHC.Types.: @ Types.StrOp Ops._opls39 Ops._opls19) -}
9b713514c6bb6194a5fe60218529b755
  _opls19 :: [Types.StrOp]
  {- Strictness: m2,
     Unfolding: (GHC.Types.: @ Types.StrOp Ops._opls36 Ops._opls20) -}
e0b7c837aba0b9a35b8aecd9557d5295
  _opls2 :: [Types.StrOp]
  {- Strictness: m2,
     Unfolding: (GHC.Types.: @ Types.StrOp Ops._opls87 Ops._opls3) -}
9457b86f1ae4c08754956e13624dbe1a
  _opls20 :: [Types.StrOp]
  {- Strictness: m2,
     Unfolding: (GHC.Types.: @ Types.StrOp Ops._opls33 Ops._opls21) -}
f2ce498fe17c81201e51220289c62ea3
  _opls21 :: [Types.StrOp]
  {- Strictness: m2,
     Unfolding: (GHC.Types.: @ Types.StrOp Ops._opls30 Ops._opls22) -}
9d06a8b6d33a1b1ad82a1ba6b348c0ce
  _opls22 :: [Types.StrOp]
  {- Strictness: m2,
     Unfolding: (GHC.Types.: @ Types.StrOp Ops._opls27 Ops._opls23) -}
1c2b1f1f87704ab211eee93f62ec2260
  _opls23 :: [Types.StrOp]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Types.StrOp
                   Ops._opls24
                   (GHC.Types.[] @ Types.StrOp)) -}
41f88bfcda951febd56de5e6c690f1e6
  _opls24 :: ([GHC.Types.Char], Types.Op)
  {- Strictness: m, Unfolding: ((Ops._opls25, Ops._snd)) -}
b88b8fc9929c1c4af4643d3dd5a72755
  _opls25 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Ops._opls26) -}
f6d6d1045b849e71c2400e298cafe159
  _opls26 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("snd"#) -}
40eb1b594347f031f6730e727c769ac8
  _opls27 :: ([GHC.Types.Char], Types.Op)
  {- Strictness: m, Unfolding: ((Ops._opls28, Ops._fst)) -}
c730c3ad857427250719d9810b3868a0
  _opls28 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Ops._opls29) -}
9a39b858520e54a0ae3292d1cb887f3e
  _opls29 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("fst"#) -}
dc8350876585a8758bc992682f91711e
  _opls3 :: [Types.StrOp]
  {- Strictness: m2,
     Unfolding: (GHC.Types.: @ Types.StrOp Ops._opls84 Ops._opls4) -}
53419e64df36ad0d3e79dac58f859528
  _opls30 :: ([GHC.Types.Char], Types.Op)
  {- Strictness: m, Unfolding: ((Ops._opls31, Ops._map)) -}
d097d06a0173844d8f0ed5f15c16af21
  _opls31 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Ops._opls32) -}
20547c1bfb1f11a855800ad592b7d804
  _opls32 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("map"#) -}
56969dfdf87eb4902a5abbc4186328db
  _opls33 :: ([GHC.Types.Char], Types.Op)
  {- Strictness: m, Unfolding: ((Ops._opls34, Ops._seq)) -}
bef029383f7f054f5dc4d887c23b5308
  _opls34 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Ops._opls35) -}
d0cb0bbb153c2f40d84da7691ad78481
  _opls35 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("seq"#) -}
46fb8e45faad3600d1980fe53d8ad995
  _opls36 :: ([GHC.Types.Char], Types.Op)
  {- Strictness: m, Unfolding: ((Ops._opls37, Ops._take)) -}
bc484a1f13b4457563addcce392fef3a
  _opls37 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Ops._opls38) -}
b00287ca2ad9203459ff29407fe8f4ef
  _opls38 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("take"#) -}
19f16a089e67ef0ba53a997a6642c74e
  _opls39 :: ([GHC.Types.Char], Types.Op)
  {- Strictness: m, Unfolding: ((Ops._opls40, Ops._isEmpty)) -}
bee11b24f2c3f98649acfa952ae52026
  _opls4 :: [Types.StrOp]
  {- Strictness: m2,
     Unfolding: (GHC.Types.: @ Types.StrOp Ops._opls81 Ops._opls5) -}
6b9dd39b72e6bcba97227a8a571c1675
  _opls40 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Ops._opls41) -}
c362ddada30e4c38c2095049ccb5eded
  _opls41 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("isEmpty"#) -}
e38da5e26c6532dc28811691710443b7
  _opls42 :: ([GHC.Types.Char], Types.Op)
  {- Strictness: m, Unfolding: ((Ops._opls43, Ops._pop)) -}
ab391930ad4b47703e2a372fc33cceeb
  _opls43 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Ops._opls44) -}
adf273349e2eb5c88a12c0f2ca68f6aa
  _opls44 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("pop"#) -}
70d54caef98754eb24fac496d240364e
  _opls45 :: ([GHC.Types.Char], Types.Op)
  {- Strictness: m, Unfolding: ((Ops._opls46, Ops._tail)) -}
b46f996224ca64f162de47a2ee3d210b
  _opls46 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Ops._opls47) -}
604b80a69de52eb9631a126ea9bdcbf4
  _opls47 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("tail"#) -}
73ab7803bc2336cba1430520ae56c443
  _opls48 :: ([GHC.Types.Char], Types.Op)
  {- Strictness: m, Unfolding: ((Ops._opls49, Ops._head)) -}
e92fbe548db57e876b4052c9d7c43968
  _opls49 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Ops._opls50) -}
fb1396b6b2f4efd71b4b7829f2ab94be
  _opls5 :: [Types.StrOp]
  {- Strictness: m2,
     Unfolding: (GHC.Types.: @ Types.StrOp Ops._opls78 Ops._opls6) -}
f6486a2b694ad4c9c9201bafdc96f49c
  _opls50 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("head"#) -}
469d7661abff5031cde723be335e3816
  _opls51 :: ([GHC.Types.Char], Types.Op)
  {- Strictness: m, Unfolding: ((Ops._opls52, Ops._succ)) -}
8d538b21620dc8d7ed9271ab6e25155d
  _opls52 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Ops._opls53) -}
55e5ab72180d5c460fdb3239248f9581
  _opls53 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("succ"#) -}
9669e301d23707199d6091b4bf209faa
  _opls54 :: ([GHC.Types.Char], Types.Op)
  {- Strictness: m, Unfolding: ((Ops._opls55, Ops._div)) -}
13f7afebc69a107591209c8572bfb7b3
  _opls55 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Ops._opls56) -}
1e449ce76a81b2bae75a4391fcbe782d
  _opls56 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("/"#) -}
9a915a52d60729a527dcf8a71fbe190d
  _opls57 :: ([GHC.Types.Char], Types.Op)
  {- Strictness: m, Unfolding: ((Ops._opls58, Ops._mul)) -}
86762afb55361060c5c8ee07dc85dc54
  _opls58 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Ops._opls59) -}
830575ddf031d0e4175a79a4d5eb20ad
  _opls59 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("*"#) -}
757ff89e6e8e6e1a043253ec72edff6f
  _opls6 :: [Types.StrOp]
  {- Strictness: m2,
     Unfolding: (GHC.Types.: @ Types.StrOp Ops._opls75 Ops._opls7) -}
284b603a8149c9d038588bf05e5b6411
  _opls60 :: ([GHC.Types.Char], Types.Op)
  {- Strictness: m, Unfolding: ((Ops._opls61, Ops._sub)) -}
f26e8fc64340a22e9383ef37347e3a49
  _opls61 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Ops._opls62) -}
6d4847201cfca8adde0a2afe221f6481
  _opls62 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("-"#) -}
a3ec4e240c199d7ad3b6adc654184629
  _opls63 :: ([GHC.Types.Char], Types.Op)
  {- Strictness: m, Unfolding: ((Ops._opls64, Ops._add)) -}
ee8849ac7f8733f33453bc48b964ce55
  _opls64 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Ops._opls65) -}
7f465072c7f91da8ce161791cb4eb660
  _opls65 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("+"#) -}
8abc1a8b335854110b914c132741e5a1
  _opls66 :: ([GHC.Types.Char], Types.Op)
  {- Strictness: m, Unfolding: ((Ops._opls67, Ops._leq)) -}
9a5f6895167821d505a7235542ec98b9
  _opls67 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Ops._opls68) -}
b28c0efc2a392a70f53855a5279ec78c
  _opls68 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("<="#) -}
167016044b52466ab4ba4482777c0b2f
  _opls69 :: ([GHC.Types.Char], Types.Op)
  {- Strictness: m, Unfolding: ((Ops._opls70, Ops._lt)) -}
fddf042a76a9eff7ae84f29aebe0ab3b
  _opls7 :: [Types.StrOp]
  {- Strictness: m2,
     Unfolding: (GHC.Types.: @ Types.StrOp Ops._opls72 Ops._opls8) -}
d2e9a3240c2f589c49d7826f3a901c4d
  _opls70 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Ops._opls71) -}
117cfd264e23e52794383ec6e0ca1191
  _opls71 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("<"#) -}
be68e58cb896a197dd467809eb32a537
  _opls72 :: ([GHC.Types.Char], Types.Op)
  {- Strictness: m, Unfolding: ((Ops._opls73, Ops._geq)) -}
6509007735eeab324393305a2001de50
  _opls73 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Ops._opls74) -}
3cdadd35db43e0afb722099783af8686
  _opls74 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: (">="#) -}
20c9e6cdf1c1b1b4bbb63612ea95ce61
  _opls75 :: ([GHC.Types.Char], Types.Op)
  {- Strictness: m, Unfolding: ((Ops._opls76, Ops._gt)) -}
7274999d9f5eb12b72540e0e5ed864fe
  _opls76 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Ops._opls77) -}
0a32d4011c6818f0a574c8eec8671995
  _opls77 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: (">"#) -}
48fb0b19bd2f20b0627a2d7ec4bbd5bc
  _opls78 :: ([GHC.Types.Char], Types.Op)
  {- Strictness: m, Unfolding: ((Ops._opls79, Ops._neq)) -}
673e2fb7a637aff44195c0b9f16b97ea
  _opls79 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Ops._opls80) -}
3c5db7635f74a0811cd886d61d8b2562
  _opls8 :: [Types.StrOp]
  {- Strictness: m2,
     Unfolding: (GHC.Types.: @ Types.StrOp Ops._opls69 Ops._opls9) -}
a97b446e5af557ebc9b461585fc38a03
  _opls80 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("!="#) -}
90c85b32c16d0c79d3b54dce884d15f2
  _opls81 :: ([GHC.Types.Char], Types.Op)
  {- Strictness: m, Unfolding: ((Ops._opls82, Ops._eq)) -}
e87650bf00bc7522fbe9a8f17e2dd889
  _opls82 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Ops._opls83) -}
c0ea8113dd5b68bac078f3c6dd253382
  _opls83 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("=="#) -}
099d14418f665c8ad50baf129368a374
  _opls84 :: ([GHC.Types.Char], Types.Op)
  {- Strictness: m, Unfolding: ((Ops._opls85, Ops._not)) -}
1f95dd299eed2d69f11491f6af520b56
  _opls85 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Ops._opls86) -}
eef00eeaee9e7fdbc323d2e4a8f6dce3
  _opls86 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("!"#) -}
77b146b60346a73093e2e728680f41c2
  _opls87 :: ([GHC.Types.Char], Types.Op)
  {- Strictness: m, Unfolding: ((Ops._opls88, Ops._and)) -}
3e64020a7ff41fcbc87f39fbeddb2763
  _opls88 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Ops._opls89) -}
d36ef3c7d62a80d628ddd8f05d8465e5
  _opls89 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("&&"#) -}
ffda46f12a50b4ca8ba11037daf63022
  _opls9 :: [Types.StrOp]
  {- Strictness: m2,
     Unfolding: (GHC.Types.: @ Types.StrOp Ops._opls66 Ops._opls10) -}
780c9b0fde9c7d386f5e95bdef0c9bf6
  _opls90 :: ([GHC.Types.Char], Types.Op)
  {- Strictness: m, Unfolding: ((Ops._opls91, Ops._or)) -}
6dfc362a54503c3d25dbab516cf70894
  _opls91 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Ops._opls92) -}
a94a348462aba4bb2b94ceb983f7215e
  _opls92 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("||"#) -}
7da2ae2867f6c2aaea805694bd443154
  _opls93 :: ([GHC.Types.Char], Types.Op)
  {- Strictness: m, Unfolding: ((Ops._opls94, Ops._print)) -}
62c08972a06d5331db7e28e4470e08fe
  _opls94 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Ops._opls95) -}
0ff339576c251c9fb6e4e5f764ab22c2
  _opls95 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("print"#) -}
4fdae104e3cb477fac4af3f60e9882f1
  _opls_dec :: [Types.StrOp]
  {- Unfolding: (GHC.List.reverse1
                   @ Types.StrOp
                   Ops._opls
                   (GHC.Types.[] @ Types.StrOp)) -}
2dad54012d1d4183e30cbb4f648be85d
  _or :: Types.Op
  {- Strictness: m1, Unfolding: (Types.BinOp Ops._or1) -}
f68cc639da88272c668bdc890fa04674
  _or1 :: Types.Wrd -> Types.Wrd -> Types.Wrd
  {- Arity: 2, Strictness: <S,1*U><S,1*U>m8, Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Types.Wrd) (w1 :: Types.Wrd) ->
                 case w of wild {
                   DEFAULT
                   -> Control.Exception.Base.patError
                        @ 'GHC.Types.LiftedRep
                        @ Types.Wrd
                        Ops._or2
                   Types.Bool a
                   -> case w1 of wild1 {
                        DEFAULT
                        -> Control.Exception.Base.patError
                             @ 'GHC.Types.LiftedRep
                             @ Types.Wrd
                             Ops._or2
                        Types.Bool b
                        -> Types.Bool
                             (case a of wild2 {
                                GHC.Types.False -> b GHC.Types.True -> GHC.Types.True }) } }) -}
19c8cec9d0f561af4b45d78201f1463b
  _or2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("src/Ops.hs:253:14-50|lambda"#) -}
d6236793377f6f670b31cc0073f004d8
  _or_t :: Types.Wrd -> Types.Wrd -> Types.Wrd
  {- Arity: 2, Strictness: <S,1*U><S,U>,
     Unfolding: (\ (ds :: Types.Wrd) (ds1 :: Types.Wrd) ->
                 case ds of wild {
                   DEFAULT -> Ops._or_t2
                   Types.TypeCheck ds2
                   -> let {
                        fail :: GHC.Prim.Void# -> Types.Wrd
                          <join 1> {- Arity: 1, Strictness: <L,A> -}
                        = \ (ds3 :: GHC.Prim.Void#)[OneShot] ->
                          case ds1 of wild1 {
                            DEFAULT -> Ops._or_t2
                            Types.TypeCheck t2
                            -> Types.Err
                                 (GHC.CString.unpackAppendCString#
                                    Ops._or_t1
                                    (GHC.Base.++
                                       @ GHC.Types.Char
                                       (Types.$fShowBind_$cshowsPrec1
                                          Types.$fShowBind2
                                          ds2
                                          (GHC.Types.[] @ GHC.Types.Char))
                                       (GHC.CString.unpackAppendCString#
                                          Ops._and_t2
                                          (Types.$fShowBind_$cshowsPrec1
                                             Types.$fShowBind2
                                             t2
                                             (GHC.Types.[] @ GHC.Types.Char))))) }
                      } in
                      case ds2 of wild1 {
                        DEFAULT -> fail GHC.Prim.void#
                        Types.T_Bool
                        -> case ds1 of wild2 {
                             DEFAULT -> fail GHC.Prim.void#
                             Types.TypeCheck ds3
                             -> case ds3 of wild3 {
                                  DEFAULT -> fail GHC.Prim.void#
                                  Types.T_Bool -> Ops._and_t1 } } } }) -}
856996f8fdef8285cf1f5129fafbb4ef
  _or_t1 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("`||`: Illegal input type: LHS="#) -}
87ef047113c19c2ca6e6a07f130bfafb
  _or_t2 :: Types.Wrd
  {- Strictness: b -}
df57e6f9a3f1b44a88f121806f113b49
  _pop :: Types.Op
  {- Strictness: m2, Unfolding: (Types.UnOp Ops._pop0) -}
a43863421cb195ba4a81ac2b795976d0
  _pop0 :: Types.Wrd -> Types.Wrd
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Types.Wrd) ->
                 case ds of wild {
                   DEFAULT -> Ops._pop4
                   Types.List ds1
                   -> case ds1 of wild1 {
                        [] -> Ops._pop1
                        : x xs
                        -> Types.Tuple
                             (GHC.Types.:
                                @ Types.Wrd
                                x
                                (GHC.Types.:
                                   @ Types.Wrd
                                   (Types.List xs)
                                   (GHC.Types.[] @ Types.Wrd))) } }) -}
709d369fb1758868880d1fb071ed0f52
  _pop1 :: Types.Wrd
  {- Strictness: m12, Unfolding: (Types.Err Ops._pop2) -}
67820d80a490bcd1292746a61771d56a
  _pop2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Ops._pop3) -}
2b468eb485d5183768e6da337648fc34
  _pop3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("pop: Empty list."#) -}
c107aca5cd4933cc2198d0720dd0a71a
  _pop4 :: Types.Wrd
  {- Strictness: b -}
7b28d897efcd51c53f0f5aac16ba00e7
  _pop_t :: Types.Wrd -> Types.Wrd
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: Types.Wrd) ->
                 case ds of wild {
                   DEFAULT -> Ops._pop_t2
                   Types.TypeCheck ds1
                   -> case ds1 of wild1 {
                        DEFAULT
                        -> Types.Err
                             (GHC.CString.unpackAppendCString#
                                Ops._pop_t1
                                (Types.$fShowBind_$cshowsPrec1
                                   Types.$fShowBind2
                                   wild1
                                   (GHC.Types.[] @ GHC.Types.Char)))
                        Types.T_List t
                        -> Types.TypeCheck
                             (Types.T_Tuple
                                (GHC.Types.:
                                   @ Types.Type
                                   t
                                   (GHC.Types.:
                                      @ Types.Type
                                      wild1
                                      (GHC.Types.[] @ Types.Type)))) } }) -}
4ee8181b34bb8af5a603e9b7cd5b63eb
  _pop_t1 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("pop: Illegal input type: "#) -}
c0229d1d856a735304e427f6db3d6ac4
  _pop_t2 :: Types.Wrd
  {- Strictness: b -}
eda6ef382233d8eaf5158800a77e8265
  _print :: Types.Op
  {- Strictness: m2, Unfolding: (Types.UnOp Ops._print0) -}
1a8cb3abd12085fea6a1ce5fd292bb5d
  _print0 :: Types.Wrd -> Types.Wrd
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Types.Wrd) ->
                 case ds of wild {
                   DEFAULT -> Types.Print (Types.$fShowBind_$cshow wild)
                   Types.Err e -> Types.Err e }) -}
a73db97c132a9eb6be1f40eb071cef24
  _print_t :: Types.Wrd -> Types.Wrd
  {- Arity: 1, Strictness: <S,1*U>m18,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Types.Wrd) ->
                 case ds of wild {
                   DEFAULT -> Ops._print_t3
                   Types.TypeCheck ds1
                   -> case ds1 of wild1 {
                        DEFAULT -> Ops._print_t2 Types.T_Error -> Ops._print_t1 } }) -}
778912fc82bbe1c0c8a9c2119ee0376e
  _print_t1 :: Types.Wrd
  {- HasNoCafRefs, Strictness: m18,
     Unfolding: (Types.TypeCheck Types.T_Error) -}
a8c95293fd2007032728adf806d1c737
  _print_t2 :: Types.Wrd
  {- HasNoCafRefs, Strictness: m18,
     Unfolding: (Types.TypeCheck Types.T_Print) -}
c0d8809ebbb7aa0dbcef4cef8fee8565
  _print_t3 :: Types.Wrd
  {- Strictness: b -}
d2fa608ce95f0fd0f24a64ac0e7ba98e
  _seq :: Types.Op
  {- Strictness: m3, Unfolding: (Types.FuncOp Ops._seq1) -}
5c58475960d4f7c34fb7b9105246807a
  _seq0 :: Types.Exp -> Types.Wrd
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ (ds :: [Types.Wrd]) ->
                 let {
                   fail :: GHC.Prim.Void# -> Types.Wrd
                     <join 1> {- Arity: 1, Strictness: <L,A> -}
                   = \ (ds1 :: GHC.Prim.Void#)[OneShot] ->
                     Types.Err
                       (GHC.CString.unpackAppendCString#
                          Ops._seq2
                          (case ds of wild {
                             [] -> Ops.toList1
                             : x xs
                             -> GHC.Types.:
                                  @ GHC.Types.Char
                                  GHC.Show.showList__3
                                  (GHC.Base.++
                                     @ GHC.Types.Char
                                     (Types.$fShowBind_$cshow x)
                                     (case Ops.$wshowl xs of ww { (#,#) ww1 ww2 ->
                                      GHC.Types.: @ GHC.Types.Char ww1 ww2 })) }))
                 } in
                 case ds of wild {
                   [] -> fail GHC.Prim.void#
                   : ds1 ds2
                   -> case ds1 of wild1 {
                        DEFAULT -> fail GHC.Prim.void#
                        Types.Int n
                        -> case ds2 of wild2 {
                             [] -> fail GHC.Prim.void#
                             : ds3 ds4
                             -> case ds3 of wild3 {
                                  DEFAULT -> fail GHC.Prim.void#
                                  Types.Int m
                                  -> case ds4 of wild4 {
                                       []
                                       -> Types.List
                                            (case n of wild5 { GHC.Types.I# x ->
                                             case m of wild6 { GHC.Types.I# y ->
                                             case GHC.Prim.># x y of lwild {
                                               DEFAULT
                                               -> letrec {
                                                    go :: GHC.Prim.Int# -> [Types.Wrd]
                                                      {- Arity: 1, Strictness: <L,U> -}
                                                    = \ (x1 :: GHC.Prim.Int#) ->
                                                      GHC.Types.:
                                                        @ Types.Wrd
                                                        (Types.Int (GHC.Types.I# x1))
                                                        (case GHC.Prim.==# x1 y of lwild1 {
                                                           DEFAULT -> go (GHC.Prim.+# x1 1#)
                                                           1# -> GHC.Types.[] @ Types.Wrd })
                                                  } in
                                                  go x
                                               1# -> GHC.Types.[] @ Types.Wrd } } })
                                       : ipv ipv1 -> fail GHC.Prim.void# } } } } }) -}
9f59b30d948edab820ae7bd0a9ec5b8b
  _seq1 :: (GHC.Types.Int, Types.Exp -> Types.Wrd)
  {- Strictness: m, Unfolding: ((Ops._map3, Ops._seq0)) -}
459f705f54d958ea106e5d280b7fdd22
  _seq2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("seq: Illegal input value: "#) -}
84ceff338091f1ba14cbd22e1a5e11eb
  _seq_t :: Types.Exp -> Types.Wrd
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ (ds :: [Types.Wrd]) ->
                 let {
                   fail :: GHC.Prim.Void# -> Types.Wrd
                     <join 1> {- Arity: 1, Strictness: <L,A> -}
                   = \ (ds1 :: GHC.Prim.Void#)[OneShot] ->
                     Types.Err
                       (GHC.CString.unpackAppendCString#
                          Ops._map_t2
                          (case ds of wild {
                             [] -> Ops.toList1
                             : x xs
                             -> GHC.Types.:
                                  @ GHC.Types.Char
                                  GHC.Show.showList__3
                                  (GHC.Base.++
                                     @ GHC.Types.Char
                                     (Types.$fShowBind_$cshow x)
                                     (case Ops.$wshowl xs of ww { (#,#) ww1 ww2 ->
                                      GHC.Types.: @ GHC.Types.Char ww1 ww2 })) }))
                 } in
                 case ds of wild {
                   [] -> fail GHC.Prim.void#
                   : ds1 ds2
                   -> case ds1 of wild1 {
                        DEFAULT -> fail GHC.Prim.void#
                        Types.TypeCheck ds3
                        -> case ds3 of wild2 {
                             DEFAULT -> fail GHC.Prim.void#
                             Types.T_Int
                             -> case ds2 of wild3 {
                                  [] -> fail GHC.Prim.void#
                                  : ds4 ds5
                                  -> case ds4 of wild4 {
                                       DEFAULT -> fail GHC.Prim.void#
                                       Types.TypeCheck ds6
                                       -> case ds6 of wild5 {
                                            DEFAULT -> fail GHC.Prim.void#
                                            Types.T_Int
                                            -> case ds5 of wild6 {
                                                 [] -> Ops._seq_t1
                                                 : ipv ipv1 -> fail GHC.Prim.void# } } } } } } }) -}
0fb3b14c4dc88304c907828cb1a7c31d
  _seq_t1 :: Types.Wrd
  {- HasNoCafRefs, Strictness: m18,
     Unfolding: (Types.TypeCheck Ops._seq_t2) -}
2b9118bcbc7b9e1043fccc128d4f8ecd
  _seq_t2 :: Types.Type
  {- HasNoCafRefs, Strictness: m10,
     Unfolding: (Types.T_List Types.T_Int) -}
e84ef485f36f52ab4e216a87a2ba462e
  _snd :: Types.Op
  {- Strictness: m2, Unfolding: (Types.UnOp Ops._snd1) -}
1dd344d8ef4b23cfd57f69c0be093838
  _snd1 :: Types.Wrd -> Types.Wrd
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: Types.Wrd) ->
                 case ds of wild {
                   DEFAULT -> Ops._snd2
                   Types.Tuple ds1
                   -> case ds1 of wild1 {
                        [] -> Ops._snd2
                        : ds2 ds3
                        -> case ds3 of wild2 { [] -> Ops._snd2 : w2 ds4 -> w2 } } }) -}
5392c2898a2292c44e4705cf2d555b3f
  _snd2 :: Types.Wrd
  {- Strictness: b -}
0848ed9b9036c10b4a0cfe6b8a823a96
  _snd_t :: Types.Wrd -> Types.Wrd
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: Types.Wrd) ->
                 case ds of wild {
                   DEFAULT
                   -> Types.Err
                        (GHC.CString.unpackAppendCString#
                           Ops._snd_t1
                           (Types.$fShowBind_$cshow wild))
                   Types.TypeCheck ds1
                   -> case ds1 of wild1 {
                        DEFAULT
                        -> Types.Err
                             (GHC.CString.unpackAppendCString#
                                Ops._snd_t1
                                (Types.$fShowBind_$cshow wild))
                        Types.T_Tuple ds2
                        -> case ds2 of wild2 {
                             []
                             -> Types.Err
                                  (GHC.CString.unpackAppendCString#
                                     Ops._snd_t1
                                     (Types.$fShowBind_$cshow wild))
                             : ds3 ds4
                             -> case ds4 of wild3 {
                                  []
                                  -> Types.Err
                                       (GHC.CString.unpackAppendCString#
                                          Ops._snd_t1
                                          (Types.$fShowBind_$cshow wild))
                                  : t ds5 -> Types.TypeCheck t } } } }) -}
fb5fb730789a7a098c792d2650fc4236
  _snd_t1 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("snd: Illegal input type: "#) -}
c65baf7f63f0bfe2c7b94d5202a5363c
  _sub :: Types.Op
  {- Strictness: m1, Unfolding: (Types.BinOp Ops._sub0) -}
380126703182f0513c5a6e449c3612e7
  _sub0 :: Types.Wrd -> Types.Wrd -> Types.Wrd
  {- Arity: 2, Strictness: <S,U><L,U>,
     Unfolding: (\ (ds :: Types.Wrd) (ds1 :: Types.Wrd) ->
                 let {
                   fail :: GHC.Prim.Void# -> Types.Wrd
                     <join 1> {- Arity: 1, Strictness: <L,A> -}
                   = \ (ds2 :: GHC.Prim.Void#)[OneShot] ->
                     Types.Err
                       (GHC.CString.unpackAppendCString#
                          Ops._sub1
                          (GHC.Base.++
                             @ GHC.Types.Char
                             (Types.$fShowBind_$cshow ds)
                             (GHC.CString.unpackAppendCString#
                                Ops._add1
                                (Types.$fShowBind_$cshow ds1))))
                 } in
                 case ds of wild {
                   DEFAULT -> fail GHC.Prim.void#
                   Types.Double x
                   -> case ds1 of wild1 {
                        DEFAULT -> fail GHC.Prim.void#
                        Types.Double y -> Types.Double (GHC.Float.minusDouble x y)
                        Types.Int y
                        -> Types.Double
                             (case x of wild2 { GHC.Types.D# x1 ->
                              case y of wild3 { GHC.Types.I# i ->
                              GHC.Types.D# (GHC.Prim.-## x1 (GHC.Prim.int2Double# i)) } }) }
                   Types.Int x
                   -> case ds1 of wild1 {
                        DEFAULT -> fail GHC.Prim.void#
                        Types.Double y
                        -> Types.Double
                             (case x of wild2 { GHC.Types.I# i ->
                              case y of wild3 { GHC.Types.D# y1 ->
                              GHC.Types.D# (GHC.Prim.-## (GHC.Prim.int2Double# i) y1) } })
                        Types.Int y -> Types.Int (GHC.Num.$fNumInt_$c- x y) } }) -}
35c261a5b9aaa69c8ef7ad1d509bd398
  _sub1 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("`-`: Illegal input value: x="#) -}
40cd0b20fde53dd78e2991bf886f9e36
  _sub_t :: Types.Wrd -> Types.Wrd -> Types.Wrd
  {- Arity: 2, Strictness: <S,U><L,U>,
     Unfolding: (\ (ds :: Types.Wrd) (ds1 :: Types.Wrd) ->
                 let {
                   fail :: GHC.Prim.Void# -> Types.Wrd
                     <join 1> {- Arity: 1, Strictness: <L,A> -}
                   = \ (ds2 :: GHC.Prim.Void#)[OneShot] ->
                     Types.Err
                       (GHC.CString.unpackAppendCString#
                          Ops._sub_t1
                          (GHC.Base.++
                             @ GHC.Types.Char
                             (Types.$fShowBind_$cshow ds)
                             (GHC.CString.unpackAppendCString#
                                Ops._add_t6
                                (Types.$fShowBind_$cshow ds1))))
                 } in
                 case ds of wild {
                   DEFAULT -> fail GHC.Prim.void#
                   Types.TypeCheck ds2
                   -> case ds2 of wild1 {
                        DEFAULT -> fail GHC.Prim.void#
                        Types.T_Int
                        -> case ds1 of wild2 {
                             DEFAULT -> fail GHC.Prim.void#
                             Types.TypeCheck ds3
                             -> case ds3 of wild3 {
                                  DEFAULT -> fail GHC.Prim.void#
                                  Types.T_Int -> Ops._add_t5
                                  Types.T_Double -> Ops._add_t4 } }
                        Types.T_Double
                        -> case ds1 of wild2 {
                             DEFAULT -> fail GHC.Prim.void#
                             Types.TypeCheck ds3
                             -> case ds3 of wild3 {
                                  DEFAULT -> fail GHC.Prim.void#
                                  Types.T_Int -> Ops._add_t4
                                  Types.T_Double -> Ops._add_t4 } } } }) -}
a1f446f17c4d6891251efc4b2fb25dcf
  _sub_t1 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("`-`: Illegal input type: t_x="#) -}
2477eb98e633f7db715310a63b6538fb
  _succ :: Types.Op
  {- Strictness: m2, Unfolding: (Types.UnOp Ops._succ0) -}
50b724e6e0b2226fe4172250f967bada
  _succ0 :: Types.Wrd -> Types.Wrd
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: Types.Wrd) ->
                 case ds of wild {
                   DEFAULT
                   -> Types.Err
                        (GHC.CString.unpackAppendCString#
                           Ops._succ1
                           (Types.$fShowBind_$cshow wild))
                   Types.Double x
                   -> Types.Double
                        (case x of wild1 { GHC.Types.D# x1 ->
                         GHC.Types.D# (GHC.Prim.+## x1 1.0##) })
                   Types.Int x
                   -> Types.Int
                        (case x of wild1 { GHC.Types.I# x1 ->
                         GHC.Types.I# (GHC.Prim.+# x1 1#) }) }) -}
1e1bec2b7d8324d8c8a13fc675c5884a
  _succ1 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("succ: Illegal input value: "#) -}
71d957eebe0c35be710ba79dec49035f
  _succ_t :: Types.Wrd -> Types.Wrd
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: Types.Wrd) ->
                 case ds of wild {
                   DEFAULT
                   -> Types.Err
                        (GHC.CString.unpackAppendCString#
                           Ops._succ_t1
                           (Types.$fShowBind_$cshow wild))
                   Types.TypeCheck ds1
                   -> case ds1 of wild1 {
                        DEFAULT
                        -> Types.Err
                             (GHC.CString.unpackAppendCString#
                                Ops._succ_t1
                                (Types.$fShowBind_$cshow wild))
                        Types.T_Int -> Ops._add_t5
                        Types.T_Double -> Ops._add_t4 } }) -}
6b00d16e376d0e6f0254d253382e9977
  _succ_t1 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("succ: Illegal input type: "#) -}
4d3f9fd1b4c251916b6f7b5a79282d1b
  _tail :: Types.Op
  {- Strictness: m2, Unfolding: (Types.UnOp Ops._tail0) -}
d752ced8c141b038dfbe64684799fc1e
  _tail0 :: Types.Wrd -> Types.Wrd
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Types.Wrd) ->
                 case ds of wild {
                   DEFAULT -> Ops._tail4
                   Types.List ds1
                   -> case ds1 of wild1 {
                        [] -> Ops._tail1 : ds2 xs -> Types.List xs } }) -}
1aed59bd94427900fdd063e064d1b4f6
  _tail1 :: Types.Wrd
  {- Strictness: m12, Unfolding: (Types.Err Ops._tail2) -}
5b6bde3d420f44567d3b89d1b48068a7
  _tail2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Ops._tail3) -}
7707e6923ff15a353d267fc53e690104
  _tail3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("tail: Empty list."#) -}
10dd5138a58cf4e10e6703d552a239a4
  _tail4 :: Types.Wrd
  {- Strictness: b -}
c11119d19ca66daa40e00e64d99b5edb
  _tail_t :: Types.Wrd -> Types.Wrd
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: Types.Wrd) ->
                 case ds of wild {
                   DEFAULT -> Ops._tail_t2
                   Types.TypeCheck ds1
                   -> case ds1 of wild1 {
                        DEFAULT
                        -> Types.Err
                             (GHC.CString.unpackAppendCString#
                                Ops._tail_t1
                                (Types.$fShowBind_$cshowsPrec1
                                   Types.$fShowBind2
                                   wild1
                                   (GHC.Types.[] @ GHC.Types.Char)))
                        Types.T_List t -> wild } }) -}
b57e45550d23ed2e01b4e297d7c50947
  _tail_t1 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("tail: Illegal input type: "#) -}
857d590cf81fdc5b0c3ff276bb2c3792
  _tail_t2 :: Types.Wrd
  {- Strictness: b -}
3ec75950f44373679e5ab7acbfa10b43
  _take :: Types.Op
  {- Strictness: m3, Unfolding: (Types.FuncOp Ops._take1) -}
c412a6b0ac453ac304587d4da2b8dd3b
  _take0 :: Types.Exp -> Types.Wrd
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ (ds :: [Types.Wrd]) ->
                 let {
                   fail :: GHC.Prim.Void# -> Types.Wrd
                     <join 1> {- Arity: 1, Strictness: <L,A> -}
                   = \ (ds1 :: GHC.Prim.Void#)[OneShot] ->
                     Types.Err
                       (GHC.CString.unpackAppendCString#
                          Ops._take2
                          (case ds of wild {
                             [] -> Ops.toList1
                             : x xs
                             -> GHC.Types.:
                                  @ GHC.Types.Char
                                  GHC.Show.showList__3
                                  (GHC.Base.++
                                     @ GHC.Types.Char
                                     (Types.$fShowBind_$cshow x)
                                     (case Ops.$wshowl xs of ww { (#,#) ww1 ww2 ->
                                      GHC.Types.: @ GHC.Types.Char ww1 ww2 })) }))
                 } in
                 case ds of wild {
                   [] -> fail GHC.Prim.void#
                   : ds1 ds2
                   -> case ds1 of wild1 {
                        DEFAULT -> fail GHC.Prim.void#
                        Types.Int n
                        -> case ds2 of wild2 {
                             [] -> fail GHC.Prim.void#
                             : ds3 ds4
                             -> case ds3 of wild3 {
                                  DEFAULT -> fail GHC.Prim.void#
                                  Types.List ls
                                  -> case ds4 of wild4 {
                                       []
                                       -> Types.List
                                            (case n of wild5 { GHC.Types.I# y ->
                                             case GHC.Prim.<# 0# y of lwild {
                                               DEFAULT -> GHC.Types.[] @ Types.Wrd
                                               1# -> GHC.List.$wunsafeTake @ Types.Wrd y ls } })
                                       : ipv ipv1 -> fail GHC.Prim.void# } } } } }) -}
4ac6979170d3a4f5c827f576cfffd6bf
  _take1 :: (GHC.Types.Int, Types.Exp -> Types.Wrd)
  {- Strictness: m, Unfolding: ((Ops._map3, Ops._take0)) -}
dc225380dbafec91e9b60dbf1b066df7
  _take2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("take: Illegal input value: "#) -}
fe67517ccf12bff65158b08c0ae18a43
  _take_t :: Types.Exp -> Types.Wrd
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ (ds :: [Types.Wrd]) ->
                 let {
                   fail :: GHC.Prim.Void# -> Types.Wrd
                     <join 1> {- Arity: 1, Strictness: <L,A> -}
                   = \ (ds1 :: GHC.Prim.Void#)[OneShot] ->
                     Types.Err
                       (GHC.CString.unpackAppendCString#
                          Ops._take_t1
                          (case ds of wild {
                             [] -> Ops.toList1
                             : x xs
                             -> GHC.Types.:
                                  @ GHC.Types.Char
                                  GHC.Show.showList__3
                                  (GHC.Base.++
                                     @ GHC.Types.Char
                                     (Types.$fShowBind_$cshow x)
                                     (case Ops.$wshowl xs of ww { (#,#) ww1 ww2 ->
                                      GHC.Types.: @ GHC.Types.Char ww1 ww2 })) }))
                 } in
                 case ds of wild {
                   [] -> fail GHC.Prim.void#
                   : ds1 ds2
                   -> case ds1 of wild1 {
                        DEFAULT -> fail GHC.Prim.void#
                        Types.TypeCheck ds3
                        -> case ds3 of wild2 {
                             DEFAULT -> fail GHC.Prim.void#
                             Types.T_Int
                             -> case ds2 of wild3 {
                                  [] -> fail GHC.Prim.void#
                                  : ds4 ds5
                                  -> case ds4 of wild4 {
                                       DEFAULT -> fail GHC.Prim.void#
                                       Types.TypeCheck ds6
                                       -> case ds6 of wild5 {
                                            DEFAULT -> fail GHC.Prim.void#
                                            Types.T_List t
                                            -> case ds5 of wild6 {
                                                 [] -> wild4
                                                 : ipv ipv1 -> fail GHC.Prim.void# } } } } } } }) -}
9412bd3a2c7ab6d7e81729cb7bf9fb84
  _take_t1 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("take: Illegal input type: "#) -}
ee95a08bf525ca090c305cc8c1f3aeb0
  _typeFunction :: GHC.Base.String -> Types.Op
  {- Arity: 1, Strictness: <S,U> -}
3ffb66a67b1e4fd04be337d8a2eceda7
  isConsistentType :: Types.Exp -> GHC.Types.Bool
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (expr :: Types.Exp) ->
                 case Ops._isConsistentType expr of wild {
                   GHC.Maybe.Nothing -> GHC.Types.False
                   GHC.Maybe.Just a1 -> GHC.Types.True }) -}
27a51ba87381b8245ff7c9b364acdd1f
  toList :: Types.Exp -> Types.Wrd
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ (expr :: Types.Exp) ->
                 case Ops._isConsistentType expr of wild {
                   GHC.Maybe.Nothing
                   -> Types.Err
                        (GHC.CString.unpackAppendCString#
                           Ops.toList2
                           (case expr of wild1 {
                              [] -> Ops.toList1
                              : x xs
                              -> GHC.Types.:
                                   @ GHC.Types.Char
                                   GHC.Show.showList__3
                                   (GHC.Base.++
                                      @ GHC.Types.Char
                                      (Types.$fShowBind_$cshow x)
                                      (case Ops.$wshowl xs of ww { (#,#) ww1 ww2 ->
                                       GHC.Types.: @ GHC.Types.Char ww1 ww2 })) }))
                   GHC.Maybe.Just a1 -> Types.List expr }) -}
1577133c85b45b42e3461d9132adfe1e
  toList1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackAppendCString#
                   GHC.Show.showList__4
                   (GHC.Types.[] @ GHC.Types.Char)) -}
68cdf96fce1d1672afe67fde5d863d2f
  toList2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("List: Inconsistent type: "#) -}
trusted: none
require own pkg trusted: False
module header:
  Nothing
declaration docs:
arg docs:

